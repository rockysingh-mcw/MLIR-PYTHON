
# Autogenerated by mlir-tblgen; don't manually edit.

from ._ods_common import _cext as _ods_cext
from ._ods_common import (
    equally_sized_accessor as _ods_equally_sized_accessor,
    get_default_loc_context as _ods_get_default_loc_context,
    get_op_result_or_op_results as _get_op_result_or_op_results,
    get_op_results_or_values as _get_op_results_or_values,
    segmented_accessor as _ods_segmented_accessor,
)
_ods_ir = _ods_cext.ir

import builtins
from typing import Sequence as _Sequence, Union as _Union


@_ods_cext.register_dialect
class _Dialect(_ods_ir.Dialect):
  DIALECT_NAMESPACE = "amdgpu"

@_ods_cext.register_operation(_Dialect)
class DPPOp(_ods_ir.OpView):
  OPERATION_NAME = "amdgpu.dpp"

  _ODS_REGIONS = (0, True)

  def __init__(self, old, src, kind, *, permArgument=None, row_mask=None, bank_mask=None, bound_ctrl=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(old)
    operands.append(src)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["kind"] = (kind if (
    isinstance(kind, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('AMDGPU_DPPPermAttr')) else
      _ods_ir.AttrBuilder.get('AMDGPU_DPPPermAttr')(kind, context=_ods_context))
    if permArgument is not None: attributes["permArgument"] = (permArgument if (
        isinstance(permArgument, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('anonymous_510')) else
          _ods_ir.AttrBuilder.get('anonymous_510')(permArgument, context=_ods_context))
    if row_mask is not None: attributes["row_mask"] = (row_mask if (
        isinstance(row_mask, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I32Attr')) else
          _ods_ir.AttrBuilder.get('I32Attr')(row_mask, context=_ods_context))
    if bank_mask is not None: attributes["bank_mask"] = (bank_mask if (
        isinstance(bank_mask, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I32Attr')) else
          _ods_ir.AttrBuilder.get('I32Attr')(bank_mask, context=_ods_context))
    if bound_ctrl is not None: attributes["bound_ctrl"] = (bound_ctrl if (
        isinstance(bound_ctrl, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(bound_ctrl, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def old(self):
    return self.operation.operands[0]

  @builtins.property
  def src(self):
    return self.operation.operands[1]

  @builtins.property
  def kind(self):
    return self.operation.attributes["kind"]

  @kind.setter
  def kind(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["kind"] = value

  @builtins.property
  def permArgument(self):
    if "permArgument" not in self.operation.attributes:
      return None
    return self.operation.attributes["permArgument"]

  @permArgument.setter
  def permArgument(self, value):
    if value is not None:
      self.operation.attributes["permArgument"] = value
    elif "permArgument" in self.operation.attributes:
      del self.operation.attributes["permArgument"]

  @permArgument.deleter
  def permArgument(self):
    del self.operation.attributes["permArgument"]

  @builtins.property
  def row_mask(self):
    return self.operation.attributes["row_mask"]

  @row_mask.setter
  def row_mask(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["row_mask"] = value

  @builtins.property
  def bank_mask(self):
    return self.operation.attributes["bank_mask"]

  @bank_mask.setter
  def bank_mask(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["bank_mask"] = value

  @builtins.property
  def bound_ctrl(self):
    return self.operation.attributes["bound_ctrl"]

  @bound_ctrl.setter
  def bound_ctrl(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["bound_ctrl"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def dpp(old, src, kind, *, perm_argument=None, row_mask=None, bank_mask=None, bound_ctrl=None, loc=None, ip=None) -> _ods_ir.Value:
  return DPPOp(old=old, src=src, kind=kind, permArgument=perm_argument, row_mask=row_mask, bank_mask=bank_mask, bound_ctrl=bound_ctrl, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ExtPackedFp8Op(_ods_ir.OpView):
  OPERATION_NAME = "amdgpu.ext_packed_fp8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, source, index, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(source)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["index"] = (index if (
    isinstance(index, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(index, context=_ods_context))
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def source(self):
    return self.operation.operands[0]

  @builtins.property
  def index(self):
    return self.operation.attributes["index"]

  @index.setter
  def index(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["index"] = value

  @builtins.property
  def res(self):
    return self.operation.results[0]

def ext_packed_fp8(res, source, index, *, loc=None, ip=None) -> _ods_ir.Value:
  return ExtPackedFp8Op(res=res, source=source, index=index, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FatRawBufferCastOp(_ods_ir.OpView):
  OPERATION_NAME = "amdgpu.fat_raw_buffer_cast"

  _ODS_OPERAND_SEGMENTS = [1,0,0,]

  _ODS_REGIONS = (0, True)

  def __init__(self, source, boundsCheck, resetOffset, *, validBytes=None, cacheSwizzleStride=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(source)
    operands.append(validBytes)
    operands.append(cacheSwizzleStride)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def source(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def validBytes(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def cacheSwizzleStride(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def result(self):
    return self.operation.results[0]

def fat_raw_buffer_cast(source, bounds_check, reset_offset, *, valid_bytes=None, cache_swizzle_stride=None, loc=None, ip=None) -> _ods_ir.Value:
  return FatRawBufferCastOp(source=source, boundsCheck=bounds_check, resetOffset=reset_offset, validBytes=valid_bytes, cacheSwizzleStride=cache_swizzle_stride, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GatherToLDSOp(_ods_ir.OpView):
  OPERATION_NAME = "amdgpu.gather_to_lds"

  _ODS_REGIONS = (0, True)

  def __init__(self, src, srcIndices, dst, dstIndices, transferType, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.extend(_get_op_results_or_values(srcIndices))
    operands.append(dst)
    operands.extend(_get_op_results_or_values(dstIndices))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["transferType"] = (transferType if (
    isinstance(transferType, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypeAttr')) else
      _ods_ir.AttrBuilder.get('TypeAttr')(transferType, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self):
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.operands, 2, 2, 0, 0)
    return self.operation.operands[start]

  @builtins.property
  def srcIndices(self):
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.operands, 2, 2, 1, 0)
    return self.operation.operands[start:start + elements_per_group]

  @builtins.property
  def dst(self):
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.operands, 2, 2, 1, 1)
    return self.operation.operands[start]

  @builtins.property
  def dstIndices(self):
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.operands, 2, 2, 2, 1)
    return self.operation.operands[start:start + elements_per_group]

  @builtins.property
  def transferType(self):
    return self.operation.attributes["transferType"]

  @transferType.setter
  def transferType(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["transferType"] = value

def gather_to_lds(src, src_indices, dst, dst_indices, transfer_type, *, loc=None, ip=None) -> _ods_ir.Operation:
  return GatherToLDSOp(src=src, srcIndices=src_indices, dst=dst, dstIndices=dst_indices, transferType=transfer_type, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class LDSBarrierOp(_ods_ir.OpView):
  OPERATION_NAME = "amdgpu.lds_barrier"

  _ODS_REGIONS = (0, True)

  def __init__(self, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

def lds_barrier(*, loc=None, ip=None) -> _ods_ir.Operation:
  return LDSBarrierOp(loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class MFMAOp(_ods_ir.OpView):
  OPERATION_NAME = "amdgpu.mfma"

  _ODS_REGIONS = (0, True)

  def __init__(self, m, n, k, blocks, sourceA, sourceB, destC, *, cbsz=None, abid=None, blgp=None, reducePrecision=None, negateA=None, negateB=None, negateC=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(sourceA)
    operands.append(sourceB)
    operands.append(destC)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["m"] = (m if (
    isinstance(m, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(m, context=_ods_context))
    attributes["n"] = (n if (
    isinstance(n, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(n, context=_ods_context))
    attributes["k"] = (k if (
    isinstance(k, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(k, context=_ods_context))
    attributes["blocks"] = (blocks if (
    isinstance(blocks, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(blocks, context=_ods_context))
    if cbsz is not None: attributes["cbsz"] = (cbsz if (
        isinstance(cbsz, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I32Attr')) else
          _ods_ir.AttrBuilder.get('I32Attr')(cbsz, context=_ods_context))
    if abid is not None: attributes["abid"] = (abid if (
        isinstance(abid, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I32Attr')) else
          _ods_ir.AttrBuilder.get('I32Attr')(abid, context=_ods_context))
    if blgp is not None: attributes["blgp"] = (blgp if (
        isinstance(blgp, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('AMDGPU_MFMAPermBAttr')) else
          _ods_ir.AttrBuilder.get('AMDGPU_MFMAPermBAttr')(blgp, context=_ods_context))
    if bool(reducePrecision): attributes["reducePrecision"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    if bool(negateA): attributes["negateA"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    if bool(negateB): attributes["negateB"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    if bool(negateC): attributes["negateC"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sourceA(self):
    return self.operation.operands[0]

  @builtins.property
  def sourceB(self):
    return self.operation.operands[1]

  @builtins.property
  def destC(self):
    return self.operation.operands[2]

  @builtins.property
  def m(self):
    return self.operation.attributes["m"]

  @m.setter
  def m(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["m"] = value

  @builtins.property
  def n(self):
    return self.operation.attributes["n"]

  @n.setter
  def n(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["n"] = value

  @builtins.property
  def k(self):
    return self.operation.attributes["k"]

  @k.setter
  def k(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["k"] = value

  @builtins.property
  def blocks(self):
    return self.operation.attributes["blocks"]

  @blocks.setter
  def blocks(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["blocks"] = value

  @builtins.property
  def cbsz(self):
    return self.operation.attributes["cbsz"]

  @cbsz.setter
  def cbsz(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["cbsz"] = value

  @builtins.property
  def abid(self):
    return self.operation.attributes["abid"]

  @abid.setter
  def abid(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["abid"] = value

  @builtins.property
  def blgp(self):
    return self.operation.attributes["blgp"]

  @blgp.setter
  def blgp(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["blgp"] = value

  @builtins.property
  def reducePrecision(self):
    return "reducePrecision" in self.operation.attributes

  @reducePrecision.setter
  def reducePrecision(self, value):
    if bool(value):
      self.operation.attributes["reducePrecision"] = _ods_ir.UnitAttr.get()
    elif "reducePrecision" in self.operation.attributes:
      del self.operation.attributes["reducePrecision"]

  @reducePrecision.deleter
  def reducePrecision(self):
    del self.operation.attributes["reducePrecision"]

  @builtins.property
  def negateA(self):
    return "negateA" in self.operation.attributes

  @negateA.setter
  def negateA(self, value):
    if bool(value):
      self.operation.attributes["negateA"] = _ods_ir.UnitAttr.get()
    elif "negateA" in self.operation.attributes:
      del self.operation.attributes["negateA"]

  @negateA.deleter
  def negateA(self):
    del self.operation.attributes["negateA"]

  @builtins.property
  def negateB(self):
    return "negateB" in self.operation.attributes

  @negateB.setter
  def negateB(self, value):
    if bool(value):
      self.operation.attributes["negateB"] = _ods_ir.UnitAttr.get()
    elif "negateB" in self.operation.attributes:
      del self.operation.attributes["negateB"]

  @negateB.deleter
  def negateB(self):
    del self.operation.attributes["negateB"]

  @builtins.property
  def negateC(self):
    return "negateC" in self.operation.attributes

  @negateC.setter
  def negateC(self, value):
    if bool(value):
      self.operation.attributes["negateC"] = _ods_ir.UnitAttr.get()
    elif "negateC" in self.operation.attributes:
      del self.operation.attributes["negateC"]

  @negateC.deleter
  def negateC(self):
    del self.operation.attributes["negateC"]

  @builtins.property
  def destD(self):
    return self.operation.results[0]

def mfma(m, n, k, blocks, source_a, source_b, dest_c, *, cbsz=None, abid=None, blgp=None, reduce_precision=None, negate_a=None, negate_b=None, negate_c=None, loc=None, ip=None) -> _ods_ir.Value:
  return MFMAOp(m=m, n=n, k=k, blocks=blocks, sourceA=source_a, sourceB=source_b, destC=dest_c, cbsz=cbsz, abid=abid, blgp=blgp, reducePrecision=reduce_precision, negateA=negate_a, negateB=negate_b, negateC=negate_c, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class PackedStochRoundFp8Op(_ods_ir.OpView):
  OPERATION_NAME = "amdgpu.packed_stoch_round_fp8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, source, stochiasticParam, storeIndex, *, existing=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(source)
    operands.append(stochiasticParam)
    if existing is not None: operands.append(existing)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["storeIndex"] = (storeIndex if (
    isinstance(storeIndex, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(storeIndex, context=_ods_context))
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def source(self):
    return self.operation.operands[0]

  @builtins.property
  def stochiasticParam(self):
    return self.operation.operands[1]

  @builtins.property
  def existing(self):
    return None if len(self.operation.operands) < 3 else self.operation.operands[2]

  @builtins.property
  def storeIndex(self):
    return self.operation.attributes["storeIndex"]

  @storeIndex.setter
  def storeIndex(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["storeIndex"] = value

  @builtins.property
  def res(self):
    return self.operation.results[0]

def packed_stoch_round_fp8(res, source, stochiastic_param, store_index, *, existing=None, loc=None, ip=None) -> _ods_ir.Value:
  return PackedStochRoundFp8Op(res=res, source=source, stochiasticParam=stochiastic_param, storeIndex=store_index, existing=existing, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class PackedTrunc2xFp8Op(_ods_ir.OpView):
  OPERATION_NAME = "amdgpu.packed_trunc_2xfp8"

  _ODS_OPERAND_SEGMENTS = [1,0,0,]

  _ODS_REGIONS = (0, True)

  def __init__(self, res, sourceA, wordIndex, *, sourceB=None, existing=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(sourceA)
    operands.append(sourceB)
    operands.append(existing)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["wordIndex"] = (wordIndex if (
    isinstance(wordIndex, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(wordIndex, context=_ods_context))
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sourceA(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def sourceB(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def existing(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def wordIndex(self):
    return self.operation.attributes["wordIndex"]

  @wordIndex.setter
  def wordIndex(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["wordIndex"] = value

  @builtins.property
  def res(self):
    return self.operation.results[0]

def packed_trunc_2xfp8(res, source_a, word_index, *, source_b=None, existing=None, loc=None, ip=None) -> _ods_ir.Value:
  return PackedTrunc2xFp8Op(res=res, sourceA=source_a, wordIndex=word_index, sourceB=source_b, existing=existing, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class RawBufferAtomicCmpswapOp(_ods_ir.OpView):
  OPERATION_NAME = "amdgpu.raw_buffer_atomic_cmpswap"

  _ODS_OPERAND_SEGMENTS = [1,1,1,-1,0,]

  _ODS_REGIONS = (0, True)

  def __init__(self, src, cmp, memref, indices, *, boundsCheck=None, indexOffset=None, sgprOffset=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(cmp)
    operands.append(memref)
    operands.append(_get_op_results_or_values(indices))
    operands.append(sgprOffset)
    _ods_context = _ods_get_default_loc_context(loc)
    if boundsCheck is not None: attributes["boundsCheck"] = (boundsCheck if (
        isinstance(boundsCheck, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(boundsCheck, context=_ods_context))
    if indexOffset is not None: attributes["indexOffset"] = (indexOffset if (
        isinstance(indexOffset, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I32Attr')) else
          _ods_ir.AttrBuilder.get('I32Attr')(indexOffset, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def cmp(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range[0]

  @builtins.property
  def memref(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range[0]

  @builtins.property
  def indices(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range

  @builtins.property
  def sgprOffset(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 4)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def boundsCheck(self):
    return self.operation.attributes["boundsCheck"]

  @boundsCheck.setter
  def boundsCheck(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["boundsCheck"] = value

  @builtins.property
  def indexOffset(self):
    if "indexOffset" not in self.operation.attributes:
      return None
    return self.operation.attributes["indexOffset"]

  @indexOffset.setter
  def indexOffset(self, value):
    if value is not None:
      self.operation.attributes["indexOffset"] = value
    elif "indexOffset" in self.operation.attributes:
      del self.operation.attributes["indexOffset"]

  @indexOffset.deleter
  def indexOffset(self):
    del self.operation.attributes["indexOffset"]

  @builtins.property
  def value(self):
    return self.operation.results[0]

def raw_buffer_atomic_cmpswap(src, cmp, memref, indices, *, bounds_check=None, index_offset=None, sgpr_offset=None, loc=None, ip=None) -> _ods_ir.Value:
  return RawBufferAtomicCmpswapOp(src=src, cmp=cmp, memref=memref, indices=indices, boundsCheck=bounds_check, indexOffset=index_offset, sgprOffset=sgpr_offset, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class RawBufferAtomicFaddOp(_ods_ir.OpView):
  OPERATION_NAME = "amdgpu.raw_buffer_atomic_fadd"

  _ODS_OPERAND_SEGMENTS = [1,1,-1,0,]

  _ODS_REGIONS = (0, True)

  def __init__(self, value, memref, indices, *, boundsCheck=None, indexOffset=None, sgprOffset=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(value)
    operands.append(memref)
    operands.append(_get_op_results_or_values(indices))
    operands.append(sgprOffset)
    _ods_context = _ods_get_default_loc_context(loc)
    if boundsCheck is not None: attributes["boundsCheck"] = (boundsCheck if (
        isinstance(boundsCheck, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(boundsCheck, context=_ods_context))
    if indexOffset is not None: attributes["indexOffset"] = (indexOffset if (
        isinstance(indexOffset, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I32Attr')) else
          _ods_ir.AttrBuilder.get('I32Attr')(indexOffset, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def memref(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range[0]

  @builtins.property
  def indices(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def sgprOffset(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def boundsCheck(self):
    return self.operation.attributes["boundsCheck"]

  @boundsCheck.setter
  def boundsCheck(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["boundsCheck"] = value

  @builtins.property
  def indexOffset(self):
    if "indexOffset" not in self.operation.attributes:
      return None
    return self.operation.attributes["indexOffset"]

  @indexOffset.setter
  def indexOffset(self, value):
    if value is not None:
      self.operation.attributes["indexOffset"] = value
    elif "indexOffset" in self.operation.attributes:
      del self.operation.attributes["indexOffset"]

  @indexOffset.deleter
  def indexOffset(self):
    del self.operation.attributes["indexOffset"]

def raw_buffer_atomic_fadd(value, memref, indices, *, bounds_check=None, index_offset=None, sgpr_offset=None, loc=None, ip=None) -> _ods_ir.Operation:
  return RawBufferAtomicFaddOp(value=value, memref=memref, indices=indices, boundsCheck=bounds_check, indexOffset=index_offset, sgprOffset=sgpr_offset, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class RawBufferAtomicFmaxOp(_ods_ir.OpView):
  OPERATION_NAME = "amdgpu.raw_buffer_atomic_fmax"

  _ODS_OPERAND_SEGMENTS = [1,1,-1,0,]

  _ODS_REGIONS = (0, True)

  def __init__(self, value, memref, indices, *, boundsCheck=None, indexOffset=None, sgprOffset=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(value)
    operands.append(memref)
    operands.append(_get_op_results_or_values(indices))
    operands.append(sgprOffset)
    _ods_context = _ods_get_default_loc_context(loc)
    if boundsCheck is not None: attributes["boundsCheck"] = (boundsCheck if (
        isinstance(boundsCheck, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(boundsCheck, context=_ods_context))
    if indexOffset is not None: attributes["indexOffset"] = (indexOffset if (
        isinstance(indexOffset, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I32Attr')) else
          _ods_ir.AttrBuilder.get('I32Attr')(indexOffset, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def memref(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range[0]

  @builtins.property
  def indices(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def sgprOffset(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def boundsCheck(self):
    return self.operation.attributes["boundsCheck"]

  @boundsCheck.setter
  def boundsCheck(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["boundsCheck"] = value

  @builtins.property
  def indexOffset(self):
    if "indexOffset" not in self.operation.attributes:
      return None
    return self.operation.attributes["indexOffset"]

  @indexOffset.setter
  def indexOffset(self, value):
    if value is not None:
      self.operation.attributes["indexOffset"] = value
    elif "indexOffset" in self.operation.attributes:
      del self.operation.attributes["indexOffset"]

  @indexOffset.deleter
  def indexOffset(self):
    del self.operation.attributes["indexOffset"]

def raw_buffer_atomic_fmax(value, memref, indices, *, bounds_check=None, index_offset=None, sgpr_offset=None, loc=None, ip=None) -> _ods_ir.Operation:
  return RawBufferAtomicFmaxOp(value=value, memref=memref, indices=indices, boundsCheck=bounds_check, indexOffset=index_offset, sgprOffset=sgpr_offset, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class RawBufferAtomicSmaxOp(_ods_ir.OpView):
  OPERATION_NAME = "amdgpu.raw_buffer_atomic_smax"

  _ODS_OPERAND_SEGMENTS = [1,1,-1,0,]

  _ODS_REGIONS = (0, True)

  def __init__(self, value, memref, indices, *, boundsCheck=None, indexOffset=None, sgprOffset=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(value)
    operands.append(memref)
    operands.append(_get_op_results_or_values(indices))
    operands.append(sgprOffset)
    _ods_context = _ods_get_default_loc_context(loc)
    if boundsCheck is not None: attributes["boundsCheck"] = (boundsCheck if (
        isinstance(boundsCheck, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(boundsCheck, context=_ods_context))
    if indexOffset is not None: attributes["indexOffset"] = (indexOffset if (
        isinstance(indexOffset, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I32Attr')) else
          _ods_ir.AttrBuilder.get('I32Attr')(indexOffset, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def memref(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range[0]

  @builtins.property
  def indices(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def sgprOffset(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def boundsCheck(self):
    return self.operation.attributes["boundsCheck"]

  @boundsCheck.setter
  def boundsCheck(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["boundsCheck"] = value

  @builtins.property
  def indexOffset(self):
    if "indexOffset" not in self.operation.attributes:
      return None
    return self.operation.attributes["indexOffset"]

  @indexOffset.setter
  def indexOffset(self, value):
    if value is not None:
      self.operation.attributes["indexOffset"] = value
    elif "indexOffset" in self.operation.attributes:
      del self.operation.attributes["indexOffset"]

  @indexOffset.deleter
  def indexOffset(self):
    del self.operation.attributes["indexOffset"]

def raw_buffer_atomic_smax(value, memref, indices, *, bounds_check=None, index_offset=None, sgpr_offset=None, loc=None, ip=None) -> _ods_ir.Operation:
  return RawBufferAtomicSmaxOp(value=value, memref=memref, indices=indices, boundsCheck=bounds_check, indexOffset=index_offset, sgprOffset=sgpr_offset, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class RawBufferAtomicUminOp(_ods_ir.OpView):
  OPERATION_NAME = "amdgpu.raw_buffer_atomic_umin"

  _ODS_OPERAND_SEGMENTS = [1,1,-1,0,]

  _ODS_REGIONS = (0, True)

  def __init__(self, value, memref, indices, *, boundsCheck=None, indexOffset=None, sgprOffset=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(value)
    operands.append(memref)
    operands.append(_get_op_results_or_values(indices))
    operands.append(sgprOffset)
    _ods_context = _ods_get_default_loc_context(loc)
    if boundsCheck is not None: attributes["boundsCheck"] = (boundsCheck if (
        isinstance(boundsCheck, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(boundsCheck, context=_ods_context))
    if indexOffset is not None: attributes["indexOffset"] = (indexOffset if (
        isinstance(indexOffset, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I32Attr')) else
          _ods_ir.AttrBuilder.get('I32Attr')(indexOffset, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def memref(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range[0]

  @builtins.property
  def indices(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def sgprOffset(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def boundsCheck(self):
    return self.operation.attributes["boundsCheck"]

  @boundsCheck.setter
  def boundsCheck(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["boundsCheck"] = value

  @builtins.property
  def indexOffset(self):
    if "indexOffset" not in self.operation.attributes:
      return None
    return self.operation.attributes["indexOffset"]

  @indexOffset.setter
  def indexOffset(self, value):
    if value is not None:
      self.operation.attributes["indexOffset"] = value
    elif "indexOffset" in self.operation.attributes:
      del self.operation.attributes["indexOffset"]

  @indexOffset.deleter
  def indexOffset(self):
    del self.operation.attributes["indexOffset"]

def raw_buffer_atomic_umin(value, memref, indices, *, bounds_check=None, index_offset=None, sgpr_offset=None, loc=None, ip=None) -> _ods_ir.Operation:
  return RawBufferAtomicUminOp(value=value, memref=memref, indices=indices, boundsCheck=bounds_check, indexOffset=index_offset, sgprOffset=sgpr_offset, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class RawBufferLoadOp(_ods_ir.OpView):
  OPERATION_NAME = "amdgpu.raw_buffer_load"

  _ODS_OPERAND_SEGMENTS = [1,-1,0,]

  _ODS_REGIONS = (0, True)

  def __init__(self, value, memref, indices, *, boundsCheck=None, indexOffset=None, sgprOffset=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(memref)
    operands.append(_get_op_results_or_values(indices))
    operands.append(sgprOffset)
    _ods_context = _ods_get_default_loc_context(loc)
    if boundsCheck is not None: attributes["boundsCheck"] = (boundsCheck if (
        isinstance(boundsCheck, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(boundsCheck, context=_ods_context))
    if indexOffset is not None: attributes["indexOffset"] = (indexOffset if (
        isinstance(indexOffset, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I32Attr')) else
          _ods_ir.AttrBuilder.get('I32Attr')(indexOffset, context=_ods_context))
    results.append(value)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def memref(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def indices(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def sgprOffset(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def boundsCheck(self):
    return self.operation.attributes["boundsCheck"]

  @boundsCheck.setter
  def boundsCheck(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["boundsCheck"] = value

  @builtins.property
  def indexOffset(self):
    if "indexOffset" not in self.operation.attributes:
      return None
    return self.operation.attributes["indexOffset"]

  @indexOffset.setter
  def indexOffset(self, value):
    if value is not None:
      self.operation.attributes["indexOffset"] = value
    elif "indexOffset" in self.operation.attributes:
      del self.operation.attributes["indexOffset"]

  @indexOffset.deleter
  def indexOffset(self):
    del self.operation.attributes["indexOffset"]

  @builtins.property
  def value(self):
    return self.operation.results[0]

def raw_buffer_load(value, memref, indices, *, bounds_check=None, index_offset=None, sgpr_offset=None, loc=None, ip=None) -> _ods_ir.Value:
  return RawBufferLoadOp(value=value, memref=memref, indices=indices, boundsCheck=bounds_check, indexOffset=index_offset, sgprOffset=sgpr_offset, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class RawBufferStoreOp(_ods_ir.OpView):
  OPERATION_NAME = "amdgpu.raw_buffer_store"

  _ODS_OPERAND_SEGMENTS = [1,1,-1,0,]

  _ODS_REGIONS = (0, True)

  def __init__(self, value, memref, indices, *, boundsCheck=None, indexOffset=None, sgprOffset=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(value)
    operands.append(memref)
    operands.append(_get_op_results_or_values(indices))
    operands.append(sgprOffset)
    _ods_context = _ods_get_default_loc_context(loc)
    if boundsCheck is not None: attributes["boundsCheck"] = (boundsCheck if (
        isinstance(boundsCheck, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(boundsCheck, context=_ods_context))
    if indexOffset is not None: attributes["indexOffset"] = (indexOffset if (
        isinstance(indexOffset, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I32Attr')) else
          _ods_ir.AttrBuilder.get('I32Attr')(indexOffset, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def memref(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range[0]

  @builtins.property
  def indices(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def sgprOffset(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def boundsCheck(self):
    return self.operation.attributes["boundsCheck"]

  @boundsCheck.setter
  def boundsCheck(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["boundsCheck"] = value

  @builtins.property
  def indexOffset(self):
    if "indexOffset" not in self.operation.attributes:
      return None
    return self.operation.attributes["indexOffset"]

  @indexOffset.setter
  def indexOffset(self, value):
    if value is not None:
      self.operation.attributes["indexOffset"] = value
    elif "indexOffset" in self.operation.attributes:
      del self.operation.attributes["indexOffset"]

  @indexOffset.deleter
  def indexOffset(self):
    del self.operation.attributes["indexOffset"]

def raw_buffer_store(value, memref, indices, *, bounds_check=None, index_offset=None, sgpr_offset=None, loc=None, ip=None) -> _ods_ir.Operation:
  return RawBufferStoreOp(value=value, memref=memref, indices=indices, boundsCheck=bounds_check, indexOffset=index_offset, sgprOffset=sgpr_offset, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class SchedBarrierOp(_ods_ir.OpView):
  OPERATION_NAME = "amdgpu.sched_barrier"

  _ODS_REGIONS = (0, True)

  def __init__(self, opts, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["opts"] = (opts if (
    isinstance(opts, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('AMDGPU_SchedBarrierOpOptAttr')) else
      _ods_ir.AttrBuilder.get('AMDGPU_SchedBarrierOpOptAttr')(opts, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def opts(self):
    return self.operation.attributes["opts"]

  @opts.setter
  def opts(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["opts"] = value

def sched_barrier(opts, *, loc=None, ip=None) -> _ods_ir.Operation:
  return SchedBarrierOp(opts=opts, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class SwizzleBitModeOp(_ods_ir.OpView):
  OPERATION_NAME = "amdgpu.swizzle_bitmode"

  _ODS_REGIONS = (0, True)

  def __init__(self, src, and_mask, or_mask, xor_mask, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(src)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["and_mask"] = (and_mask if (
    isinstance(and_mask, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(and_mask, context=_ods_context))
    attributes["or_mask"] = (or_mask if (
    isinstance(or_mask, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(or_mask, context=_ods_context))
    attributes["xor_mask"] = (xor_mask if (
    isinstance(xor_mask, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(xor_mask, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self):
    return self.operation.operands[0]

  @builtins.property
  def and_mask(self):
    return self.operation.attributes["and_mask"]

  @and_mask.setter
  def and_mask(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["and_mask"] = value

  @builtins.property
  def or_mask(self):
    return self.operation.attributes["or_mask"]

  @or_mask.setter
  def or_mask(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["or_mask"] = value

  @builtins.property
  def xor_mask(self):
    return self.operation.attributes["xor_mask"]

  @xor_mask.setter
  def xor_mask(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["xor_mask"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def swizzle_bitmode(src, and_mask, or_mask, xor_mask, *, loc=None, ip=None) -> _ods_ir.Value:
  return SwizzleBitModeOp(src=src, and_mask=and_mask, or_mask=or_mask, xor_mask=xor_mask, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class WMMAOp(_ods_ir.OpView):
  OPERATION_NAME = "amdgpu.wmma"

  _ODS_REGIONS = (0, True)

  def __init__(self, sourceA, sourceB, destC, *, subwordOffset=None, unsignedA=None, unsignedB=None, clamp=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(sourceA)
    operands.append(sourceB)
    operands.append(destC)
    _ods_context = _ods_get_default_loc_context(loc)
    if subwordOffset is not None: attributes["subwordOffset"] = (subwordOffset if (
        isinstance(subwordOffset, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I32Attr')) else
          _ods_ir.AttrBuilder.get('I32Attr')(subwordOffset, context=_ods_context))
    if bool(unsignedA): attributes["unsignedA"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    if bool(unsignedB): attributes["unsignedB"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    if bool(clamp): attributes["clamp"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sourceA(self):
    return self.operation.operands[0]

  @builtins.property
  def sourceB(self):
    return self.operation.operands[1]

  @builtins.property
  def destC(self):
    return self.operation.operands[2]

  @builtins.property
  def subwordOffset(self):
    return self.operation.attributes["subwordOffset"]

  @subwordOffset.setter
  def subwordOffset(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["subwordOffset"] = value

  @builtins.property
  def unsignedA(self):
    return "unsignedA" in self.operation.attributes

  @unsignedA.setter
  def unsignedA(self, value):
    if bool(value):
      self.operation.attributes["unsignedA"] = _ods_ir.UnitAttr.get()
    elif "unsignedA" in self.operation.attributes:
      del self.operation.attributes["unsignedA"]

  @unsignedA.deleter
  def unsignedA(self):
    del self.operation.attributes["unsignedA"]

  @builtins.property
  def unsignedB(self):
    return "unsignedB" in self.operation.attributes

  @unsignedB.setter
  def unsignedB(self, value):
    if bool(value):
      self.operation.attributes["unsignedB"] = _ods_ir.UnitAttr.get()
    elif "unsignedB" in self.operation.attributes:
      del self.operation.attributes["unsignedB"]

  @unsignedB.deleter
  def unsignedB(self):
    del self.operation.attributes["unsignedB"]

  @builtins.property
  def clamp(self):
    return "clamp" in self.operation.attributes

  @clamp.setter
  def clamp(self, value):
    if bool(value):
      self.operation.attributes["clamp"] = _ods_ir.UnitAttr.get()
    elif "clamp" in self.operation.attributes:
      del self.operation.attributes["clamp"]

  @clamp.deleter
  def clamp(self):
    del self.operation.attributes["clamp"]

  @builtins.property
  def destD(self):
    return self.operation.results[0]

def wmma(source_a, source_b, dest_c, *, subword_offset=None, unsigned_a=None, unsigned_b=None, clamp=None, loc=None, ip=None) -> _ods_ir.Value:
  return WMMAOp(sourceA=source_a, sourceB=source_b, destC=dest_c, subwordOffset=subword_offset, unsignedA=unsigned_a, unsignedB=unsigned_b, clamp=clamp, loc=loc, ip=ip).result
