
# Autogenerated by mlir-tblgen; don't manually edit.

from ._ods_common import _cext as _ods_cext
from ._ods_common import (
    equally_sized_accessor as _ods_equally_sized_accessor,
    get_default_loc_context as _ods_get_default_loc_context,
    get_op_result_or_op_results as _get_op_result_or_op_results,
    get_op_results_or_values as _get_op_results_or_values,
    segmented_accessor as _ods_segmented_accessor,
)
_ods_ir = _ods_cext.ir

import builtins
from typing import Sequence as _Sequence, Union as _Union


@_ods_cext.register_dialect
class _Dialect(_ods_ir.Dialect):
  DIALECT_NAMESPACE = "affine"

@_ods_cext.register_operation(_Dialect)
class AffineApplyOp(_ods_ir.OpView):
  OPERATION_NAME = "affine.apply"

  _ODS_REGIONS = (0, True)

  def __init__(self, map, mapOperands, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(mapOperands))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["map"] = (map if (
    isinstance(map, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('AffineMapAttr')) else
      _ods_ir.AttrBuilder.get('AffineMapAttr')(map, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def mapOperands(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def map(self):
    return self.operation.attributes["map"]

  @map.setter
  def map(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["map"] = value

def apply(map, map_operands, *, loc=None, ip=None) -> _ods_ir.Value:
  return AffineApplyOp(map=map, mapOperands=map_operands, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AffineDelinearizeIndexOp(_ods_ir.OpView):
  OPERATION_NAME = "affine.delinearize_index"

  _ODS_REGIONS = (0, True)

  def __init__(self, multi_index, linear_index, dynamic_basis, static_basis, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(linear_index)
    operands.extend(_get_op_results_or_values(dynamic_basis))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["static_basis"] = (static_basis if (
    isinstance(static_basis, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('DenseI64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('DenseI64ArrayAttr')(static_basis, context=_ods_context))
    results.extend(multi_index)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def linear_index(self):
    return self.operation.operands[0]

  @builtins.property
  def dynamic_basis(self):
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[1:1 + _ods_variadic_group_length]

  @builtins.property
  def static_basis(self):
    return self.operation.attributes["static_basis"]

  @static_basis.setter
  def static_basis(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["static_basis"] = value

  @builtins.property
  def multi_index(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

def delinearize_index(multi_index, linear_index, dynamic_basis, static_basis, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(AffineDelinearizeIndexOp(multi_index=multi_index, linear_index=linear_index, dynamic_basis=dynamic_basis, static_basis=static_basis, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class AffineForOp(_ods_ir.OpView):
  OPERATION_NAME = "affine.for"

  _ODS_OPERAND_SEGMENTS = [-1,-1,-1,]

  _ODS_REGIONS = (1, True)

  def __init__(self, results_, lowerBoundOperands, upperBoundOperands, inits, lowerBoundMap, upperBoundMap, step, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(lowerBoundOperands))
    operands.append(_get_op_results_or_values(upperBoundOperands))
    operands.append(_get_op_results_or_values(inits))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["lowerBoundMap"] = (lowerBoundMap if (
    isinstance(lowerBoundMap, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('AffineMapAttr')) else
      _ods_ir.AttrBuilder.get('AffineMapAttr')(lowerBoundMap, context=_ods_context))
    attributes["upperBoundMap"] = (upperBoundMap if (
    isinstance(upperBoundMap, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('AffineMapAttr')) else
      _ods_ir.AttrBuilder.get('AffineMapAttr')(upperBoundMap, context=_ods_context))
    attributes["step"] = (step if (
    isinstance(step, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('IndexAttr')) else
      _ods_ir.AttrBuilder.get('IndexAttr')(step, context=_ods_context))
    results.extend(results_)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lowerBoundOperands(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def upperBoundOperands(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def inits(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def lowerBoundMap(self):
    return self.operation.attributes["lowerBoundMap"]

  @lowerBoundMap.setter
  def lowerBoundMap(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["lowerBoundMap"] = value

  @builtins.property
  def upperBoundMap(self):
    return self.operation.attributes["upperBoundMap"]

  @upperBoundMap.setter
  def upperBoundMap(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["upperBoundMap"] = value

  @builtins.property
  def step(self):
    return self.operation.attributes["step"]

  @step.setter
  def step(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["step"] = value

  @builtins.property
  def results_(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def region(self):
    return self.regions[0]

def for_(results_, lower_bound_operands, upper_bound_operands, inits, lower_bound_map, upper_bound_map, step, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(AffineForOp(results_=results_, lowerBoundOperands=lower_bound_operands, upperBoundOperands=upper_bound_operands, inits=inits, lowerBoundMap=lower_bound_map, upperBoundMap=upper_bound_map, step=step, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class AffineIfOp(_ods_ir.OpView):
  OPERATION_NAME = "affine.if"

  _ODS_REGIONS = (2, True)

  def __init__(self, results_, _gen_arg_0, condition, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(_gen_arg_0))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["condition"] = (condition if (
    isinstance(condition, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('IntegerSetAttr')) else
      _ods_ir.AttrBuilder.get('IntegerSetAttr')(condition, context=_ods_context))
    results.extend(results_)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def condition(self):
    return self.operation.attributes["condition"]

  @condition.setter
  def condition(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["condition"] = value

  @builtins.property
  def results_(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def thenRegion(self):
    return self.regions[0]

  @builtins.property
  def elseRegion(self):
    return self.regions[1]

def if_(results_, _gen_arg_0, condition, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(AffineIfOp(results_=results_, _gen_arg_0=_gen_arg_0, condition=condition, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class AffineLinearizeIndexOp(_ods_ir.OpView):
  OPERATION_NAME = "affine.linearize_index"

  _ODS_OPERAND_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, multi_index, dynamic_basis, static_basis, disjoint, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(multi_index))
    operands.append(_get_op_results_or_values(dynamic_basis))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["static_basis"] = (static_basis if (
    isinstance(static_basis, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('DenseI64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('DenseI64ArrayAttr')(static_basis, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def multi_index(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def dynamic_basis(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def static_basis(self):
    return self.operation.attributes["static_basis"]

  @static_basis.setter
  def static_basis(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["static_basis"] = value

  @builtins.property
  def linear_index(self):
    return self.operation.results[0]

def linearize_index(multi_index, dynamic_basis, static_basis, disjoint, *, loc=None, ip=None) -> _ods_ir.Value:
  return AffineLinearizeIndexOp(multi_index=multi_index, dynamic_basis=dynamic_basis, static_basis=static_basis, disjoint=disjoint, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AffineLoadOp(_ods_ir.OpView):
  OPERATION_NAME = "affine.load"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, memref, indices, map, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(memref)
    operands.extend(_get_op_results_or_values(indices))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["map"] = (map if (
    isinstance(map, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('AffineMapAttr')) else
      _ods_ir.AttrBuilder.get('AffineMapAttr')(map, context=_ods_context))
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def memref(self):
    return self.operation.operands[0]

  @builtins.property
  def indices(self):
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[1:1 + _ods_variadic_group_length]

  @builtins.property
  def map(self):
    return self.operation.attributes["map"]

  @map.setter
  def map(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["map"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def load(result, memref, indices, map, *, loc=None, ip=None) -> _ods_ir.Value:
  return AffineLoadOp(result=result, memref=memref, indices=indices, map=map, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AffineMaxOp(_ods_ir.OpView):
  OPERATION_NAME = "affine.max"

  _ODS_REGIONS = (0, True)

  def __init__(self, map, operands_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(operands_))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["map"] = (map if (
    isinstance(map, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('AffineMapAttr')) else
      _ods_ir.AttrBuilder.get('AffineMapAttr')(map, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operands_(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def map(self):
    return self.operation.attributes["map"]

  @map.setter
  def map(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["map"] = value

def max(map, operands_, *, loc=None, ip=None) -> _ods_ir.Value:
  return AffineMaxOp(map=map, operands_=operands_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AffineMinOp(_ods_ir.OpView):
  OPERATION_NAME = "affine.min"

  _ODS_REGIONS = (0, True)

  def __init__(self, map, operands_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(operands_))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["map"] = (map if (
    isinstance(map, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('AffineMapAttr')) else
      _ods_ir.AttrBuilder.get('AffineMapAttr')(map, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operands_(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def map(self):
    return self.operation.attributes["map"]

  @map.setter
  def map(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["map"] = value

def min(map, operands_, *, loc=None, ip=None) -> _ods_ir.Value:
  return AffineMinOp(map=map, operands_=operands_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AffineParallelOp(_ods_ir.OpView):
  OPERATION_NAME = "affine.parallel"

  _ODS_REGIONS = (1, True)

  def __init__(self, results_, reductions, lowerBoundsMap, lowerBoundsGroups, upperBoundsMap, upperBoundsGroups, steps, mapOperands, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(mapOperands))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["reductions"] = (reductions if (
    isinstance(reductions, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('anonymous_487')) else
      _ods_ir.AttrBuilder.get('anonymous_487')(reductions, context=_ods_context))
    attributes["lowerBoundsMap"] = (lowerBoundsMap if (
    isinstance(lowerBoundsMap, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('AffineMapAttr')) else
      _ods_ir.AttrBuilder.get('AffineMapAttr')(lowerBoundsMap, context=_ods_context))
    attributes["lowerBoundsGroups"] = (lowerBoundsGroups if (
    isinstance(lowerBoundsGroups, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32ElementsAttr')) else
      _ods_ir.AttrBuilder.get('I32ElementsAttr')(lowerBoundsGroups, context=_ods_context))
    attributes["upperBoundsMap"] = (upperBoundsMap if (
    isinstance(upperBoundsMap, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('AffineMapAttr')) else
      _ods_ir.AttrBuilder.get('AffineMapAttr')(upperBoundsMap, context=_ods_context))
    attributes["upperBoundsGroups"] = (upperBoundsGroups if (
    isinstance(upperBoundsGroups, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32ElementsAttr')) else
      _ods_ir.AttrBuilder.get('I32ElementsAttr')(upperBoundsGroups, context=_ods_context))
    attributes["steps"] = (steps if (
    isinstance(steps, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64SmallVectorArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64SmallVectorArrayAttr')(steps, context=_ods_context))
    results.extend(results_)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def mapOperands(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def reductions(self):
    return self.operation.attributes["reductions"]

  @reductions.setter
  def reductions(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["reductions"] = value

  @builtins.property
  def lowerBoundsMap(self):
    return self.operation.attributes["lowerBoundsMap"]

  @lowerBoundsMap.setter
  def lowerBoundsMap(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["lowerBoundsMap"] = value

  @builtins.property
  def lowerBoundsGroups(self):
    return self.operation.attributes["lowerBoundsGroups"]

  @lowerBoundsGroups.setter
  def lowerBoundsGroups(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["lowerBoundsGroups"] = value

  @builtins.property
  def upperBoundsMap(self):
    return self.operation.attributes["upperBoundsMap"]

  @upperBoundsMap.setter
  def upperBoundsMap(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["upperBoundsMap"] = value

  @builtins.property
  def upperBoundsGroups(self):
    return self.operation.attributes["upperBoundsGroups"]

  @upperBoundsGroups.setter
  def upperBoundsGroups(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["upperBoundsGroups"] = value

  @builtins.property
  def steps(self):
    return self.operation.attributes["steps"]

  @steps.setter
  def steps(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["steps"] = value

  @builtins.property
  def results_(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def region(self):
    return self.regions[0]

def parallel(results_, reductions, lower_bounds_map, lower_bounds_groups, upper_bounds_map, upper_bounds_groups, steps, map_operands, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(AffineParallelOp(results_=results_, reductions=reductions, lowerBoundsMap=lower_bounds_map, lowerBoundsGroups=lower_bounds_groups, upperBoundsMap=upper_bounds_map, upperBoundsGroups=upper_bounds_groups, steps=steps, mapOperands=map_operands, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class AffinePrefetchOp(_ods_ir.OpView):
  OPERATION_NAME = "affine.prefetch"

  _ODS_REGIONS = (0, True)

  def __init__(self, memref, indices, isWrite, localityHint, isDataCache, map, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(memref)
    operands.extend(_get_op_results_or_values(indices))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["isWrite"] = (isWrite if (
    isinstance(isWrite, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(isWrite, context=_ods_context))
    attributes["localityHint"] = (localityHint if (
    isinstance(localityHint, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(localityHint, context=_ods_context))
    attributes["isDataCache"] = (isDataCache if (
    isinstance(isDataCache, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(isDataCache, context=_ods_context))
    attributes["map"] = (map if (
    isinstance(map, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('AffineMapAttr')) else
      _ods_ir.AttrBuilder.get('AffineMapAttr')(map, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def memref(self):
    return self.operation.operands[0]

  @builtins.property
  def indices(self):
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[1:1 + _ods_variadic_group_length]

  @builtins.property
  def isWrite(self):
    return self.operation.attributes["isWrite"]

  @isWrite.setter
  def isWrite(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["isWrite"] = value

  @builtins.property
  def localityHint(self):
    return self.operation.attributes["localityHint"]

  @localityHint.setter
  def localityHint(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["localityHint"] = value

  @builtins.property
  def isDataCache(self):
    return self.operation.attributes["isDataCache"]

  @isDataCache.setter
  def isDataCache(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["isDataCache"] = value

  @builtins.property
  def map(self):
    return self.operation.attributes["map"]

  @map.setter
  def map(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["map"] = value

def prefetch(memref, indices, is_write, locality_hint, is_data_cache, map, *, loc=None, ip=None) -> _ods_ir.Operation:
  return AffinePrefetchOp(memref=memref, indices=indices, isWrite=is_write, localityHint=locality_hint, isDataCache=is_data_cache, map=map, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class AffineStoreOp(_ods_ir.OpView):
  OPERATION_NAME = "affine.store"

  _ODS_REGIONS = (0, True)

  def __init__(self, value, memref, indices, map, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(value)
    operands.append(memref)
    operands.extend(_get_op_results_or_values(indices))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["map"] = (map if (
    isinstance(map, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('AffineMapAttr')) else
      _ods_ir.AttrBuilder.get('AffineMapAttr')(map, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self):
    return self.operation.operands[0]

  @builtins.property
  def memref(self):
    return self.operation.operands[1]

  @builtins.property
  def indices(self):
    _ods_variadic_group_length = len(self.operation.operands) - 3 + 1
    return self.operation.operands[2:2 + _ods_variadic_group_length]

  @builtins.property
  def map(self):
    return self.operation.attributes["map"]

  @map.setter
  def map(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["map"] = value

def store(value, memref, indices, map, *, loc=None, ip=None) -> _ods_ir.Operation:
  return AffineStoreOp(value=value, memref=memref, indices=indices, map=map, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class AffineVectorLoadOp(_ods_ir.OpView):
  OPERATION_NAME = "affine.vector_load"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, memref, indices, map, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(memref)
    operands.extend(_get_op_results_or_values(indices))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["map"] = (map if (
    isinstance(map, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('AffineMapAttr')) else
      _ods_ir.AttrBuilder.get('AffineMapAttr')(map, context=_ods_context))
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def memref(self):
    return self.operation.operands[0]

  @builtins.property
  def indices(self):
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[1:1 + _ods_variadic_group_length]

  @builtins.property
  def map(self):
    return self.operation.attributes["map"]

  @map.setter
  def map(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["map"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def vector_load(result, memref, indices, map, *, loc=None, ip=None) -> _ods_ir.Value:
  return AffineVectorLoadOp(result=result, memref=memref, indices=indices, map=map, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AffineVectorStoreOp(_ods_ir.OpView):
  OPERATION_NAME = "affine.vector_store"

  _ODS_REGIONS = (0, True)

  def __init__(self, value, memref, indices, map, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(value)
    operands.append(memref)
    operands.extend(_get_op_results_or_values(indices))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["map"] = (map if (
    isinstance(map, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('AffineMapAttr')) else
      _ods_ir.AttrBuilder.get('AffineMapAttr')(map, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self):
    return self.operation.operands[0]

  @builtins.property
  def memref(self):
    return self.operation.operands[1]

  @builtins.property
  def indices(self):
    _ods_variadic_group_length = len(self.operation.operands) - 3 + 1
    return self.operation.operands[2:2 + _ods_variadic_group_length]

  @builtins.property
  def map(self):
    return self.operation.attributes["map"]

  @map.setter
  def map(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["map"] = value

def vector_store(value, memref, indices, map, *, loc=None, ip=None) -> _ods_ir.Operation:
  return AffineVectorStoreOp(value=value, memref=memref, indices=indices, map=map, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class AffineYieldOp(_ods_ir.OpView):
  OPERATION_NAME = "affine.yield"

  _ODS_REGIONS = (0, True)

  def __init__(self, operands_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(operands_))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operands_(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

def yield_(operands_, *, loc=None, ip=None) -> _ods_ir.Operation:
  return AffineYieldOp(operands_=operands_, loc=loc, ip=ip)
