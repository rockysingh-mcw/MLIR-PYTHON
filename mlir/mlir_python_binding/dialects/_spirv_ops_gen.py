
# Autogenerated by mlir-tblgen; don't manually edit.

from ._ods_common import _cext as _ods_cext
from ._ods_common import (
    equally_sized_accessor as _ods_equally_sized_accessor,
    get_default_loc_context as _ods_get_default_loc_context,
    get_op_result_or_op_results as _get_op_result_or_op_results,
    get_op_results_or_values as _get_op_results_or_values,
    segmented_accessor as _ods_segmented_accessor,
)
_ods_ir = _ods_cext.ir

import builtins
from typing import Sequence as _Sequence, Union as _Union


@_ods_cext.register_dialect
class _Dialect(_ods_ir.Dialect):
  DIALECT_NAMESPACE = "spirv"

@_ods_cext.register_operation(_Dialect)
class AccessChainOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.AccessChain"

  _ODS_REGIONS = (0, True)

  def __init__(self, component_ptr, base_ptr, indices, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(base_ptr)
    operands.extend(_get_op_results_or_values(indices))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(component_ptr)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def base_ptr(self):
    return self.operation.operands[0]

  @builtins.property
  def indices(self):
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[1:1 + _ods_variadic_group_length]

  @builtins.property
  def component_ptr(self):
    return self.operation.results[0]

def AccessChain(component_ptr, base_ptr, indices, *, loc=None, ip=None) -> _ods_ir.Value:
  return AccessChainOp(component_ptr=component_ptr, base_ptr=base_ptr, indices=indices, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AddressOfOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.mlir.addressof"

  _ODS_REGIONS = (0, True)

  def __init__(self, pointer, variable, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["variable"] = (variable if (
    isinstance(variable, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('FlatSymbolRefAttr')) else
      _ods_ir.AttrBuilder.get('FlatSymbolRefAttr')(variable, context=_ods_context))
    results.append(pointer)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def variable(self):
    return self.operation.attributes["variable"]

  @variable.setter
  def variable(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["variable"] = value

  @builtins.property
  def pointer(self):
    return self.operation.results[0]

def mlir_addressof(pointer, variable, *, loc=None, ip=None) -> _ods_ir.Value:
  return AddressOfOp(pointer=pointer, variable=variable, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtomicAndOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.AtomicAnd"

  _ODS_REGIONS = (0, True)

  def __init__(self, pointer, memory_scope, semantics, value, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(pointer)
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["memory_scope"] = (memory_scope if (
    isinstance(memory_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(memory_scope, context=_ods_context))
    attributes["semantics"] = (semantics if (
    isinstance(semantics, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_MemorySemanticsAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_MemorySemanticsAttr')(semantics, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def pointer(self):
    return self.operation.operands[0]

  @builtins.property
  def value(self):
    return self.operation.operands[1]

  @builtins.property
  def memory_scope(self):
    return self.operation.attributes["memory_scope"]

  @memory_scope.setter
  def memory_scope(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["memory_scope"] = value

  @builtins.property
  def semantics(self):
    return self.operation.attributes["semantics"]

  @semantics.setter
  def semantics(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["semantics"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def AtomicAnd(pointer, memory_scope, semantics, value, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtomicAndOp(pointer=pointer, memory_scope=memory_scope, semantics=semantics, value=value, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtomicCompareExchangeOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.AtomicCompareExchange"

  _ODS_REGIONS = (0, True)

  def __init__(self, pointer, memory_scope, equal_semantics, unequal_semantics, value, comparator, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(pointer)
    operands.append(value)
    operands.append(comparator)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["memory_scope"] = (memory_scope if (
    isinstance(memory_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(memory_scope, context=_ods_context))
    attributes["equal_semantics"] = (equal_semantics if (
    isinstance(equal_semantics, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_MemorySemanticsAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_MemorySemanticsAttr')(equal_semantics, context=_ods_context))
    attributes["unequal_semantics"] = (unequal_semantics if (
    isinstance(unequal_semantics, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_MemorySemanticsAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_MemorySemanticsAttr')(unequal_semantics, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def pointer(self):
    return self.operation.operands[0]

  @builtins.property
  def value(self):
    return self.operation.operands[1]

  @builtins.property
  def comparator(self):
    return self.operation.operands[2]

  @builtins.property
  def memory_scope(self):
    return self.operation.attributes["memory_scope"]

  @memory_scope.setter
  def memory_scope(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["memory_scope"] = value

  @builtins.property
  def equal_semantics(self):
    return self.operation.attributes["equal_semantics"]

  @equal_semantics.setter
  def equal_semantics(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["equal_semantics"] = value

  @builtins.property
  def unequal_semantics(self):
    return self.operation.attributes["unequal_semantics"]

  @unequal_semantics.setter
  def unequal_semantics(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["unequal_semantics"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def AtomicCompareExchange(pointer, memory_scope, equal_semantics, unequal_semantics, value, comparator, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtomicCompareExchangeOp(pointer=pointer, memory_scope=memory_scope, equal_semantics=equal_semantics, unequal_semantics=unequal_semantics, value=value, comparator=comparator, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtomicCompareExchangeWeakOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.AtomicCompareExchangeWeak"

  _ODS_REGIONS = (0, True)

  def __init__(self, pointer, memory_scope, equal_semantics, unequal_semantics, value, comparator, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(pointer)
    operands.append(value)
    operands.append(comparator)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["memory_scope"] = (memory_scope if (
    isinstance(memory_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(memory_scope, context=_ods_context))
    attributes["equal_semantics"] = (equal_semantics if (
    isinstance(equal_semantics, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_MemorySemanticsAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_MemorySemanticsAttr')(equal_semantics, context=_ods_context))
    attributes["unequal_semantics"] = (unequal_semantics if (
    isinstance(unequal_semantics, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_MemorySemanticsAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_MemorySemanticsAttr')(unequal_semantics, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def pointer(self):
    return self.operation.operands[0]

  @builtins.property
  def value(self):
    return self.operation.operands[1]

  @builtins.property
  def comparator(self):
    return self.operation.operands[2]

  @builtins.property
  def memory_scope(self):
    return self.operation.attributes["memory_scope"]

  @memory_scope.setter
  def memory_scope(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["memory_scope"] = value

  @builtins.property
  def equal_semantics(self):
    return self.operation.attributes["equal_semantics"]

  @equal_semantics.setter
  def equal_semantics(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["equal_semantics"] = value

  @builtins.property
  def unequal_semantics(self):
    return self.operation.attributes["unequal_semantics"]

  @unequal_semantics.setter
  def unequal_semantics(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["unequal_semantics"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def AtomicCompareExchangeWeak(pointer, memory_scope, equal_semantics, unequal_semantics, value, comparator, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtomicCompareExchangeWeakOp(pointer=pointer, memory_scope=memory_scope, equal_semantics=equal_semantics, unequal_semantics=unequal_semantics, value=value, comparator=comparator, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtomicExchangeOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.AtomicExchange"

  _ODS_REGIONS = (0, True)

  def __init__(self, pointer, memory_scope, semantics, value, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(pointer)
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["memory_scope"] = (memory_scope if (
    isinstance(memory_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(memory_scope, context=_ods_context))
    attributes["semantics"] = (semantics if (
    isinstance(semantics, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_MemorySemanticsAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_MemorySemanticsAttr')(semantics, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def pointer(self):
    return self.operation.operands[0]

  @builtins.property
  def value(self):
    return self.operation.operands[1]

  @builtins.property
  def memory_scope(self):
    return self.operation.attributes["memory_scope"]

  @memory_scope.setter
  def memory_scope(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["memory_scope"] = value

  @builtins.property
  def semantics(self):
    return self.operation.attributes["semantics"]

  @semantics.setter
  def semantics(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["semantics"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def AtomicExchange(pointer, memory_scope, semantics, value, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtomicExchangeOp(pointer=pointer, memory_scope=memory_scope, semantics=semantics, value=value, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtomicIAddOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.AtomicIAdd"

  _ODS_REGIONS = (0, True)

  def __init__(self, pointer, memory_scope, semantics, value, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(pointer)
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["memory_scope"] = (memory_scope if (
    isinstance(memory_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(memory_scope, context=_ods_context))
    attributes["semantics"] = (semantics if (
    isinstance(semantics, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_MemorySemanticsAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_MemorySemanticsAttr')(semantics, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def pointer(self):
    return self.operation.operands[0]

  @builtins.property
  def value(self):
    return self.operation.operands[1]

  @builtins.property
  def memory_scope(self):
    return self.operation.attributes["memory_scope"]

  @memory_scope.setter
  def memory_scope(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["memory_scope"] = value

  @builtins.property
  def semantics(self):
    return self.operation.attributes["semantics"]

  @semantics.setter
  def semantics(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["semantics"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def AtomicIAdd(pointer, memory_scope, semantics, value, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtomicIAddOp(pointer=pointer, memory_scope=memory_scope, semantics=semantics, value=value, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtomicIDecrementOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.AtomicIDecrement"

  _ODS_REGIONS = (0, True)

  def __init__(self, pointer, memory_scope, semantics, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(pointer)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["memory_scope"] = (memory_scope if (
    isinstance(memory_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(memory_scope, context=_ods_context))
    attributes["semantics"] = (semantics if (
    isinstance(semantics, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_MemorySemanticsAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_MemorySemanticsAttr')(semantics, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def pointer(self):
    return self.operation.operands[0]

  @builtins.property
  def memory_scope(self):
    return self.operation.attributes["memory_scope"]

  @memory_scope.setter
  def memory_scope(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["memory_scope"] = value

  @builtins.property
  def semantics(self):
    return self.operation.attributes["semantics"]

  @semantics.setter
  def semantics(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["semantics"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def AtomicIDecrement(pointer, memory_scope, semantics, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtomicIDecrementOp(pointer=pointer, memory_scope=memory_scope, semantics=semantics, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtomicIIncrementOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.AtomicIIncrement"

  _ODS_REGIONS = (0, True)

  def __init__(self, pointer, memory_scope, semantics, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(pointer)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["memory_scope"] = (memory_scope if (
    isinstance(memory_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(memory_scope, context=_ods_context))
    attributes["semantics"] = (semantics if (
    isinstance(semantics, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_MemorySemanticsAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_MemorySemanticsAttr')(semantics, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def pointer(self):
    return self.operation.operands[0]

  @builtins.property
  def memory_scope(self):
    return self.operation.attributes["memory_scope"]

  @memory_scope.setter
  def memory_scope(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["memory_scope"] = value

  @builtins.property
  def semantics(self):
    return self.operation.attributes["semantics"]

  @semantics.setter
  def semantics(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["semantics"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def AtomicIIncrement(pointer, memory_scope, semantics, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtomicIIncrementOp(pointer=pointer, memory_scope=memory_scope, semantics=semantics, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtomicISubOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.AtomicISub"

  _ODS_REGIONS = (0, True)

  def __init__(self, pointer, memory_scope, semantics, value, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(pointer)
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["memory_scope"] = (memory_scope if (
    isinstance(memory_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(memory_scope, context=_ods_context))
    attributes["semantics"] = (semantics if (
    isinstance(semantics, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_MemorySemanticsAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_MemorySemanticsAttr')(semantics, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def pointer(self):
    return self.operation.operands[0]

  @builtins.property
  def value(self):
    return self.operation.operands[1]

  @builtins.property
  def memory_scope(self):
    return self.operation.attributes["memory_scope"]

  @memory_scope.setter
  def memory_scope(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["memory_scope"] = value

  @builtins.property
  def semantics(self):
    return self.operation.attributes["semantics"]

  @semantics.setter
  def semantics(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["semantics"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def AtomicISub(pointer, memory_scope, semantics, value, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtomicISubOp(pointer=pointer, memory_scope=memory_scope, semantics=semantics, value=value, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtomicOrOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.AtomicOr"

  _ODS_REGIONS = (0, True)

  def __init__(self, pointer, memory_scope, semantics, value, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(pointer)
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["memory_scope"] = (memory_scope if (
    isinstance(memory_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(memory_scope, context=_ods_context))
    attributes["semantics"] = (semantics if (
    isinstance(semantics, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_MemorySemanticsAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_MemorySemanticsAttr')(semantics, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def pointer(self):
    return self.operation.operands[0]

  @builtins.property
  def value(self):
    return self.operation.operands[1]

  @builtins.property
  def memory_scope(self):
    return self.operation.attributes["memory_scope"]

  @memory_scope.setter
  def memory_scope(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["memory_scope"] = value

  @builtins.property
  def semantics(self):
    return self.operation.attributes["semantics"]

  @semantics.setter
  def semantics(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["semantics"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def AtomicOr(pointer, memory_scope, semantics, value, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtomicOrOp(pointer=pointer, memory_scope=memory_scope, semantics=semantics, value=value, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtomicSMaxOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.AtomicSMax"

  _ODS_REGIONS = (0, True)

  def __init__(self, pointer, memory_scope, semantics, value, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(pointer)
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["memory_scope"] = (memory_scope if (
    isinstance(memory_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(memory_scope, context=_ods_context))
    attributes["semantics"] = (semantics if (
    isinstance(semantics, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_MemorySemanticsAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_MemorySemanticsAttr')(semantics, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def pointer(self):
    return self.operation.operands[0]

  @builtins.property
  def value(self):
    return self.operation.operands[1]

  @builtins.property
  def memory_scope(self):
    return self.operation.attributes["memory_scope"]

  @memory_scope.setter
  def memory_scope(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["memory_scope"] = value

  @builtins.property
  def semantics(self):
    return self.operation.attributes["semantics"]

  @semantics.setter
  def semantics(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["semantics"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def AtomicSMax(pointer, memory_scope, semantics, value, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtomicSMaxOp(pointer=pointer, memory_scope=memory_scope, semantics=semantics, value=value, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtomicSMinOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.AtomicSMin"

  _ODS_REGIONS = (0, True)

  def __init__(self, pointer, memory_scope, semantics, value, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(pointer)
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["memory_scope"] = (memory_scope if (
    isinstance(memory_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(memory_scope, context=_ods_context))
    attributes["semantics"] = (semantics if (
    isinstance(semantics, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_MemorySemanticsAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_MemorySemanticsAttr')(semantics, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def pointer(self):
    return self.operation.operands[0]

  @builtins.property
  def value(self):
    return self.operation.operands[1]

  @builtins.property
  def memory_scope(self):
    return self.operation.attributes["memory_scope"]

  @memory_scope.setter
  def memory_scope(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["memory_scope"] = value

  @builtins.property
  def semantics(self):
    return self.operation.attributes["semantics"]

  @semantics.setter
  def semantics(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["semantics"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def AtomicSMin(pointer, memory_scope, semantics, value, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtomicSMinOp(pointer=pointer, memory_scope=memory_scope, semantics=semantics, value=value, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtomicUMaxOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.AtomicUMax"

  _ODS_REGIONS = (0, True)

  def __init__(self, pointer, memory_scope, semantics, value, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(pointer)
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["memory_scope"] = (memory_scope if (
    isinstance(memory_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(memory_scope, context=_ods_context))
    attributes["semantics"] = (semantics if (
    isinstance(semantics, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_MemorySemanticsAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_MemorySemanticsAttr')(semantics, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def pointer(self):
    return self.operation.operands[0]

  @builtins.property
  def value(self):
    return self.operation.operands[1]

  @builtins.property
  def memory_scope(self):
    return self.operation.attributes["memory_scope"]

  @memory_scope.setter
  def memory_scope(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["memory_scope"] = value

  @builtins.property
  def semantics(self):
    return self.operation.attributes["semantics"]

  @semantics.setter
  def semantics(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["semantics"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def AtomicUMax(pointer, memory_scope, semantics, value, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtomicUMaxOp(pointer=pointer, memory_scope=memory_scope, semantics=semantics, value=value, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtomicUMinOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.AtomicUMin"

  _ODS_REGIONS = (0, True)

  def __init__(self, pointer, memory_scope, semantics, value, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(pointer)
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["memory_scope"] = (memory_scope if (
    isinstance(memory_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(memory_scope, context=_ods_context))
    attributes["semantics"] = (semantics if (
    isinstance(semantics, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_MemorySemanticsAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_MemorySemanticsAttr')(semantics, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def pointer(self):
    return self.operation.operands[0]

  @builtins.property
  def value(self):
    return self.operation.operands[1]

  @builtins.property
  def memory_scope(self):
    return self.operation.attributes["memory_scope"]

  @memory_scope.setter
  def memory_scope(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["memory_scope"] = value

  @builtins.property
  def semantics(self):
    return self.operation.attributes["semantics"]

  @semantics.setter
  def semantics(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["semantics"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def AtomicUMin(pointer, memory_scope, semantics, value, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtomicUMinOp(pointer=pointer, memory_scope=memory_scope, semantics=semantics, value=value, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtomicXorOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.AtomicXor"

  _ODS_REGIONS = (0, True)

  def __init__(self, pointer, memory_scope, semantics, value, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(pointer)
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["memory_scope"] = (memory_scope if (
    isinstance(memory_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(memory_scope, context=_ods_context))
    attributes["semantics"] = (semantics if (
    isinstance(semantics, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_MemorySemanticsAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_MemorySemanticsAttr')(semantics, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def pointer(self):
    return self.operation.operands[0]

  @builtins.property
  def value(self):
    return self.operation.operands[1]

  @builtins.property
  def memory_scope(self):
    return self.operation.attributes["memory_scope"]

  @memory_scope.setter
  def memory_scope(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["memory_scope"] = value

  @builtins.property
  def semantics(self):
    return self.operation.attributes["semantics"]

  @semantics.setter
  def semantics(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["semantics"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def AtomicXor(pointer, memory_scope, semantics, value, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtomicXorOp(pointer=pointer, memory_scope=memory_scope, semantics=semantics, value=value, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BitCountOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.BitCount"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def BitCount(operand, *, loc=None, ip=None) -> _ods_ir.Value:
  return BitCountOp(operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BitFieldInsertOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.BitFieldInsert"

  _ODS_REGIONS = (0, True)

  def __init__(self, base, insert, offset, count, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(base)
    operands.append(insert)
    operands.append(offset)
    operands.append(count)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def base(self):
    return self.operation.operands[0]

  @builtins.property
  def insert(self):
    return self.operation.operands[1]

  @builtins.property
  def offset(self):
    return self.operation.operands[2]

  @builtins.property
  def count(self):
    return self.operation.operands[3]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def BitFieldInsert(base, insert, offset, count, *, loc=None, ip=None) -> _ods_ir.Value:
  return BitFieldInsertOp(base=base, insert=insert, offset=offset, count=count, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BitFieldSExtractOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.BitFieldSExtract"

  _ODS_REGIONS = (0, True)

  def __init__(self, base, offset, count, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(base)
    operands.append(offset)
    operands.append(count)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def base(self):
    return self.operation.operands[0]

  @builtins.property
  def offset(self):
    return self.operation.operands[1]

  @builtins.property
  def count(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def BitFieldSExtract(base, offset, count, *, loc=None, ip=None) -> _ods_ir.Value:
  return BitFieldSExtractOp(base=base, offset=offset, count=count, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BitFieldUExtractOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.BitFieldUExtract"

  _ODS_REGIONS = (0, True)

  def __init__(self, base, offset, count, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(base)
    operands.append(offset)
    operands.append(count)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def base(self):
    return self.operation.operands[0]

  @builtins.property
  def offset(self):
    return self.operation.operands[1]

  @builtins.property
  def count(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def BitFieldUExtract(base, offset, count, *, loc=None, ip=None) -> _ods_ir.Value:
  return BitFieldUExtractOp(base=base, offset=offset, count=count, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BitReverseOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.BitReverse"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def BitReverse(operand, *, loc=None, ip=None) -> _ods_ir.Value:
  return BitReverseOp(operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BitcastOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.Bitcast"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def Bitcast(result, operand, *, loc=None, ip=None) -> _ods_ir.Value:
  return BitcastOp(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BitwiseAndOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.BitwiseAnd"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand1, operand2, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand1)
    operands.append(operand2)
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand1(self):
    return self.operation.operands[0]

  @builtins.property
  def operand2(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def BitwiseAnd(operand1, operand2, *, loc=None, ip=None) -> _ods_ir.Value:
  return BitwiseAndOp(operand1=operand1, operand2=operand2, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BitwiseOrOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.BitwiseOr"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand1, operand2, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand1)
    operands.append(operand2)
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand1(self):
    return self.operation.operands[0]

  @builtins.property
  def operand2(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def BitwiseOr(operand1, operand2, *, loc=None, ip=None) -> _ods_ir.Value:
  return BitwiseOrOp(operand1=operand1, operand2=operand2, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BitwiseXorOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.BitwiseXor"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand1, operand2, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand1)
    operands.append(operand2)
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand1(self):
    return self.operation.operands[0]

  @builtins.property
  def operand2(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def BitwiseXor(operand1, operand2, *, loc=None, ip=None) -> _ods_ir.Value:
  return BitwiseXorOp(operand1=operand1, operand2=operand2, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BranchConditionalOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.BranchConditional"

  _ODS_OPERAND_SEGMENTS = [1,-1,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, condition, trueTargetOperands, falseTargetOperands, trueTarget, falseTarget, *, branch_weights=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(condition)
    operands.append(_get_op_results_or_values(trueTargetOperands))
    operands.append(_get_op_results_or_values(falseTargetOperands))
    _ods_context = _ods_get_default_loc_context(loc)
    if branch_weights is not None: attributes["branch_weights"] = (branch_weights if (
        isinstance(branch_weights, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I32ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I32ArrayAttr')(branch_weights, context=_ods_context))
    _ods_successors = []
    _ods_successors.append(trueTarget)
    _ods_successors.append(falseTarget)
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def condition(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def trueTargetOperands(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def falseTargetOperands(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def branch_weights(self):
    if "branch_weights" not in self.operation.attributes:
      return None
    return self.operation.attributes["branch_weights"]

  @branch_weights.setter
  def branch_weights(self, value):
    if value is not None:
      self.operation.attributes["branch_weights"] = value
    elif "branch_weights" in self.operation.attributes:
      del self.operation.attributes["branch_weights"]

  @branch_weights.deleter
  def branch_weights(self):
    del self.operation.attributes["branch_weights"]

def BranchConditional(condition, true_target_operands, false_target_operands, true_target, false_target, *, branch_weights=None, loc=None, ip=None) -> _ods_ir.Operation:
  return BranchConditionalOp(condition=condition, trueTargetOperands=true_target_operands, falseTargetOperands=false_target_operands, trueTarget=true_target, falseTarget=false_target, branch_weights=branch_weights, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class BranchOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.Branch"

  _ODS_REGIONS = (0, True)

  def __init__(self, targetOperands, target, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(targetOperands))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = []
    _ods_successors.append(target)
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def targetOperands(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

def Branch(target_operands, target, *, loc=None, ip=None) -> _ods_ir.Operation:
  return BranchOp(targetOperands=target_operands, target=target, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class CLAcosOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.CL.acos"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def CL_acos(operand, *, loc=None, ip=None) -> _ods_ir.Value:
  return CLAcosOp(operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CLAcoshOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.CL.acosh"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def CL_acosh(operand, *, loc=None, ip=None) -> _ods_ir.Value:
  return CLAcoshOp(operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CLAsinOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.CL.asin"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def CL_asin(operand, *, loc=None, ip=None) -> _ods_ir.Value:
  return CLAsinOp(operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CLAsinhOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.CL.asinh"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def CL_asinh(operand, *, loc=None, ip=None) -> _ods_ir.Value:
  return CLAsinhOp(operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CLAtan2Op(_ods_ir.OpView):
  OPERATION_NAME = "spirv.CL.atan2"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def CL_atan2(lhs, rhs, *, loc=None, ip=None) -> _ods_ir.Value:
  return CLAtan2Op(lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CLAtanOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.CL.atan"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def CL_atan(operand, *, loc=None, ip=None) -> _ods_ir.Value:
  return CLAtanOp(operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CLAtanhOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.CL.atanh"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def CL_atanh(operand, *, loc=None, ip=None) -> _ods_ir.Value:
  return CLAtanhOp(operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CLCeilOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.CL.ceil"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def CL_ceil(operand, *, loc=None, ip=None) -> _ods_ir.Value:
  return CLCeilOp(operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CLCosOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.CL.cos"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def CL_cos(operand, *, loc=None, ip=None) -> _ods_ir.Value:
  return CLCosOp(operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CLCoshOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.CL.cosh"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def CL_cosh(operand, *, loc=None, ip=None) -> _ods_ir.Value:
  return CLCoshOp(operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CLErfOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.CL.erf"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def CL_erf(operand, *, loc=None, ip=None) -> _ods_ir.Value:
  return CLErfOp(operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CLExpOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.CL.exp"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def CL_exp(operand, *, loc=None, ip=None) -> _ods_ir.Value:
  return CLExpOp(operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CLFAbsOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.CL.fabs"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def CL_fabs(operand, *, loc=None, ip=None) -> _ods_ir.Value:
  return CLFAbsOp(operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CLFMaxOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.CL.fmax"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def CL_fmax(lhs, rhs, *, loc=None, ip=None) -> _ods_ir.Value:
  return CLFMaxOp(lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CLFMinOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.CL.fmin"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def CL_fmin(lhs, rhs, *, loc=None, ip=None) -> _ods_ir.Value:
  return CLFMinOp(lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CLFloorOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.CL.floor"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def CL_floor(operand, *, loc=None, ip=None) -> _ods_ir.Value:
  return CLFloorOp(operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CLFmaOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.CL.fma"

  _ODS_REGIONS = (0, True)

  def __init__(self, x, y, z, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(x)
    operands.append(y)
    operands.append(z)
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def x(self):
    return self.operation.operands[0]

  @builtins.property
  def y(self):
    return self.operation.operands[1]

  @builtins.property
  def z(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def CL_fma(x, y, z, *, loc=None, ip=None) -> _ods_ir.Value:
  return CLFmaOp(x=x, y=y, z=z, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CLLogOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.CL.log"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def CL_log(operand, *, loc=None, ip=None) -> _ods_ir.Value:
  return CLLogOp(operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CLMixOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.CL.mix"

  _ODS_REGIONS = (0, True)

  def __init__(self, x, y, z, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(x)
    operands.append(y)
    operands.append(z)
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def x(self):
    return self.operation.operands[0]

  @builtins.property
  def y(self):
    return self.operation.operands[1]

  @builtins.property
  def z(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def CL_mix(x, y, z, *, loc=None, ip=None) -> _ods_ir.Value:
  return CLMixOp(x=x, y=y, z=z, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CLPowOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.CL.pow"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def CL_pow(lhs, rhs, *, loc=None, ip=None) -> _ods_ir.Value:
  return CLPowOp(lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CLPrintfOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.CL.printf"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, format, arguments, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(format)
    operands.extend(_get_op_results_or_values(arguments))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def format(self):
    return self.operation.operands[0]

  @builtins.property
  def arguments(self):
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[1:1 + _ods_variadic_group_length]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def CL_printf(result, format, arguments, *, loc=None, ip=None) -> _ods_ir.Value:
  return CLPrintfOp(result=result, format=format, arguments=arguments, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CLRintOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.CL.rint"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def CL_rint(operand, *, loc=None, ip=None) -> _ods_ir.Value:
  return CLRintOp(operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CLRoundOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.CL.round"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def CL_round(operand, *, loc=None, ip=None) -> _ods_ir.Value:
  return CLRoundOp(operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CLRsqrtOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.CL.rsqrt"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def CL_rsqrt(operand, *, loc=None, ip=None) -> _ods_ir.Value:
  return CLRsqrtOp(operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CLSAbsOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.CL.s_abs"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def CL_s_abs(operand, *, loc=None, ip=None) -> _ods_ir.Value:
  return CLSAbsOp(operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CLSMaxOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.CL.s_max"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def CL_s_max(lhs, rhs, *, loc=None, ip=None) -> _ods_ir.Value:
  return CLSMaxOp(lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CLSMinOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.CL.s_min"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def CL_s_min(lhs, rhs, *, loc=None, ip=None) -> _ods_ir.Value:
  return CLSMinOp(lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CLSinOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.CL.sin"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def CL_sin(operand, *, loc=None, ip=None) -> _ods_ir.Value:
  return CLSinOp(operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CLSinhOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.CL.sinh"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def CL_sinh(operand, *, loc=None, ip=None) -> _ods_ir.Value:
  return CLSinhOp(operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CLSqrtOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.CL.sqrt"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def CL_sqrt(operand, *, loc=None, ip=None) -> _ods_ir.Value:
  return CLSqrtOp(operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CLTanOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.CL.tan"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def CL_tan(operand, *, loc=None, ip=None) -> _ods_ir.Value:
  return CLTanOp(operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CLTanhOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.CL.tanh"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def CL_tanh(operand, *, loc=None, ip=None) -> _ods_ir.Value:
  return CLTanhOp(operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CLUMaxOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.CL.u_max"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def CL_u_max(lhs, rhs, *, loc=None, ip=None) -> _ods_ir.Value:
  return CLUMaxOp(lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CLUMinOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.CL.u_min"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def CL_u_min(lhs, rhs, *, loc=None, ip=None) -> _ods_ir.Value:
  return CLUMinOp(lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CompositeConstructOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.CompositeConstruct"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, constituents, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(constituents))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def constituents(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def CompositeConstruct(result, constituents, *, loc=None, ip=None) -> _ods_ir.Value:
  return CompositeConstructOp(result=result, constituents=constituents, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CompositeExtractOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.CompositeExtract"

  _ODS_REGIONS = (0, True)

  def __init__(self, component, composite, indices, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(composite)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["indices"] = (indices if (
    isinstance(indices, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I32ArrayAttr')(indices, context=_ods_context))
    results.append(component)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def composite(self):
    return self.operation.operands[0]

  @builtins.property
  def indices(self):
    return self.operation.attributes["indices"]

  @indices.setter
  def indices(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["indices"] = value

  @builtins.property
  def component(self):
    return self.operation.results[0]

def CompositeExtract(component, composite, indices, *, loc=None, ip=None) -> _ods_ir.Value:
  return CompositeExtractOp(component=component, composite=composite, indices=indices, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CompositeInsertOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.CompositeInsert"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, object, composite, indices, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(object)
    operands.append(composite)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["indices"] = (indices if (
    isinstance(indices, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I32ArrayAttr')(indices, context=_ods_context))
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def object(self):
    return self.operation.operands[0]

  @builtins.property
  def composite(self):
    return self.operation.operands[1]

  @builtins.property
  def indices(self):
    return self.operation.attributes["indices"]

  @indices.setter
  def indices(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["indices"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def CompositeInsert(result, object, composite, indices, *, loc=None, ip=None) -> _ods_ir.Value:
  return CompositeInsertOp(result=result, object=object, composite=composite, indices=indices, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ConstantOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.Constant"

  _ODS_REGIONS = (0, True)

  def __init__(self, constant, value, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["value"] = (value if (
    isinstance(value, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('AnyAttr')) else
      _ods_ir.AttrBuilder.get('AnyAttr')(value, context=_ods_context))
    results.append(constant)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self):
    return self.operation.attributes["value"]

  @value.setter
  def value(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["value"] = value

  @builtins.property
  def constant(self):
    return self.operation.results[0]

def Constant(constant, value, *, loc=None, ip=None) -> _ods_ir.Value:
  return ConstantOp(constant=constant, value=value, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ControlBarrierOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.ControlBarrier"

  _ODS_REGIONS = (0, True)

  def __init__(self, execution_scope, memory_scope, memory_semantics, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["execution_scope"] = (execution_scope if (
    isinstance(execution_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(execution_scope, context=_ods_context))
    attributes["memory_scope"] = (memory_scope if (
    isinstance(memory_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(memory_scope, context=_ods_context))
    attributes["memory_semantics"] = (memory_semantics if (
    isinstance(memory_semantics, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_MemorySemanticsAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_MemorySemanticsAttr')(memory_semantics, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def execution_scope(self):
    return self.operation.attributes["execution_scope"]

  @execution_scope.setter
  def execution_scope(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["execution_scope"] = value

  @builtins.property
  def memory_scope(self):
    return self.operation.attributes["memory_scope"]

  @memory_scope.setter
  def memory_scope(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["memory_scope"] = value

  @builtins.property
  def memory_semantics(self):
    return self.operation.attributes["memory_semantics"]

  @memory_semantics.setter
  def memory_semantics(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["memory_semantics"] = value

def ControlBarrier(execution_scope, memory_scope, memory_semantics, *, loc=None, ip=None) -> _ods_ir.Operation:
  return ControlBarrierOp(execution_scope=execution_scope, memory_scope=memory_scope, memory_semantics=memory_semantics, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ConvertFToSOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.ConvertFToS"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def ConvertFToS(result, operand, *, loc=None, ip=None) -> _ods_ir.Value:
  return ConvertFToSOp(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ConvertFToUOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.ConvertFToU"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def ConvertFToU(result, operand, *, loc=None, ip=None) -> _ods_ir.Value:
  return ConvertFToUOp(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ConvertPtrToUOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.ConvertPtrToU"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, pointer, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(pointer)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def pointer(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def ConvertPtrToU(result, pointer, *, loc=None, ip=None) -> _ods_ir.Value:
  return ConvertPtrToUOp(result=result, pointer=pointer, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ConvertSToFOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.ConvertSToF"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def ConvertSToF(result, operand, *, loc=None, ip=None) -> _ods_ir.Value:
  return ConvertSToFOp(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ConvertUToFOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.ConvertUToF"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def ConvertUToF(result, operand, *, loc=None, ip=None) -> _ods_ir.Value:
  return ConvertUToFOp(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ConvertUToPtrOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.ConvertUToPtr"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def ConvertUToPtr(result, operand, *, loc=None, ip=None) -> _ods_ir.Value:
  return ConvertUToPtrOp(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CopyMemoryOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.CopyMemory"

  _ODS_REGIONS = (0, True)

  def __init__(self, target, source, *, memory_access=None, alignment=None, source_memory_access=None, source_alignment=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(target)
    operands.append(source)
    _ods_context = _ods_get_default_loc_context(loc)
    if memory_access is not None: attributes["memory_access"] = (memory_access if (
        isinstance(memory_access, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('SPIRV_MemoryAccessAttr')) else
          _ods_ir.AttrBuilder.get('SPIRV_MemoryAccessAttr')(memory_access, context=_ods_context))
    if alignment is not None: attributes["alignment"] = (alignment if (
        isinstance(alignment, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I32Attr')) else
          _ods_ir.AttrBuilder.get('I32Attr')(alignment, context=_ods_context))
    if source_memory_access is not None: attributes["source_memory_access"] = (source_memory_access if (
        isinstance(source_memory_access, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('SPIRV_MemoryAccessAttr')) else
          _ods_ir.AttrBuilder.get('SPIRV_MemoryAccessAttr')(source_memory_access, context=_ods_context))
    if source_alignment is not None: attributes["source_alignment"] = (source_alignment if (
        isinstance(source_alignment, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I32Attr')) else
          _ods_ir.AttrBuilder.get('I32Attr')(source_alignment, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def source(self):
    return self.operation.operands[1]

  @builtins.property
  def memory_access(self):
    if "memory_access" not in self.operation.attributes:
      return None
    return self.operation.attributes["memory_access"]

  @memory_access.setter
  def memory_access(self, value):
    if value is not None:
      self.operation.attributes["memory_access"] = value
    elif "memory_access" in self.operation.attributes:
      del self.operation.attributes["memory_access"]

  @memory_access.deleter
  def memory_access(self):
    del self.operation.attributes["memory_access"]

  @builtins.property
  def alignment(self):
    if "alignment" not in self.operation.attributes:
      return None
    return self.operation.attributes["alignment"]

  @alignment.setter
  def alignment(self, value):
    if value is not None:
      self.operation.attributes["alignment"] = value
    elif "alignment" in self.operation.attributes:
      del self.operation.attributes["alignment"]

  @alignment.deleter
  def alignment(self):
    del self.operation.attributes["alignment"]

  @builtins.property
  def source_memory_access(self):
    if "source_memory_access" not in self.operation.attributes:
      return None
    return self.operation.attributes["source_memory_access"]

  @source_memory_access.setter
  def source_memory_access(self, value):
    if value is not None:
      self.operation.attributes["source_memory_access"] = value
    elif "source_memory_access" in self.operation.attributes:
      del self.operation.attributes["source_memory_access"]

  @source_memory_access.deleter
  def source_memory_access(self):
    del self.operation.attributes["source_memory_access"]

  @builtins.property
  def source_alignment(self):
    if "source_alignment" not in self.operation.attributes:
      return None
    return self.operation.attributes["source_alignment"]

  @source_alignment.setter
  def source_alignment(self, value):
    if value is not None:
      self.operation.attributes["source_alignment"] = value
    elif "source_alignment" in self.operation.attributes:
      del self.operation.attributes["source_alignment"]

  @source_alignment.deleter
  def source_alignment(self):
    del self.operation.attributes["source_alignment"]

def CopyMemory(target, source, *, memory_access=None, alignment=None, source_memory_access=None, source_alignment=None, loc=None, ip=None) -> _ods_ir.Operation:
  return CopyMemoryOp(target=target, source=source, memory_access=memory_access, alignment=alignment, source_memory_access=source_memory_access, source_alignment=source_alignment, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class DotOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.Dot"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, vector1, vector2, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(vector1)
    operands.append(vector2)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def vector1(self):
    return self.operation.operands[0]

  @builtins.property
  def vector2(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def Dot(result, vector1, vector2, *, loc=None, ip=None) -> _ods_ir.Value:
  return DotOp(result=result, vector1=vector1, vector2=vector2, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class EXTAtomicFAddOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.EXT.AtomicFAdd"

  _ODS_REGIONS = (0, True)

  def __init__(self, pointer, memory_scope, semantics, value, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(pointer)
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["memory_scope"] = (memory_scope if (
    isinstance(memory_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(memory_scope, context=_ods_context))
    attributes["semantics"] = (semantics if (
    isinstance(semantics, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_MemorySemanticsAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_MemorySemanticsAttr')(semantics, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def pointer(self):
    return self.operation.operands[0]

  @builtins.property
  def value(self):
    return self.operation.operands[1]

  @builtins.property
  def memory_scope(self):
    return self.operation.attributes["memory_scope"]

  @memory_scope.setter
  def memory_scope(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["memory_scope"] = value

  @builtins.property
  def semantics(self):
    return self.operation.attributes["semantics"]

  @semantics.setter
  def semantics(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["semantics"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def EXT_AtomicFAdd(pointer, memory_scope, semantics, value, *, loc=None, ip=None) -> _ods_ir.Value:
  return EXTAtomicFAddOp(pointer=pointer, memory_scope=memory_scope, semantics=semantics, value=value, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class EXTEmitMeshTasksOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.EXT.EmitMeshTasks"

  _ODS_REGIONS = (0, True)

  def __init__(self, group_count_x, group_count_y, group_count_z, *, payload=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(group_count_x)
    operands.append(group_count_y)
    operands.append(group_count_z)
    if payload is not None: operands.append(payload)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def group_count_x(self):
    return self.operation.operands[0]

  @builtins.property
  def group_count_y(self):
    return self.operation.operands[1]

  @builtins.property
  def group_count_z(self):
    return self.operation.operands[2]

  @builtins.property
  def payload(self):
    return None if len(self.operation.operands) < 4 else self.operation.operands[3]

def EXT_EmitMeshTasks(group_count_x, group_count_y, group_count_z, *, payload=None, loc=None, ip=None) -> _ods_ir.Operation:
  return EXTEmitMeshTasksOp(group_count_x=group_count_x, group_count_y=group_count_y, group_count_z=group_count_z, payload=payload, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class EXTSetMeshOutputsOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.EXT.SetMeshOutputs"

  _ODS_REGIONS = (0, True)

  def __init__(self, vertex_count, primitive_count, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(vertex_count)
    operands.append(primitive_count)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def vertex_count(self):
    return self.operation.operands[0]

  @builtins.property
  def primitive_count(self):
    return self.operation.operands[1]

def EXT_SetMeshOutputs(vertex_count, primitive_count, *, loc=None, ip=None) -> _ods_ir.Operation:
  return EXTSetMeshOutputsOp(vertex_count=vertex_count, primitive_count=primitive_count, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class EmitVertexOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.EmitVertex"

  _ODS_REGIONS = (0, True)

  def __init__(self, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

def EmitVertex(*, loc=None, ip=None) -> _ods_ir.Operation:
  return EmitVertexOp(loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class EndPrimitiveOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.EndPrimitive"

  _ODS_REGIONS = (0, True)

  def __init__(self, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

def EndPrimitive(*, loc=None, ip=None) -> _ods_ir.Operation:
  return EndPrimitiveOp(loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class EntryPointOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.EntryPoint"

  _ODS_REGIONS = (0, True)

  def __init__(self, execution_model, fn, interface, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["execution_model"] = (execution_model if (
    isinstance(execution_model, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ExecutionModelAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ExecutionModelAttr')(execution_model, context=_ods_context))
    attributes["fn"] = (fn if (
    isinstance(fn, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('FlatSymbolRefAttr')) else
      _ods_ir.AttrBuilder.get('FlatSymbolRefAttr')(fn, context=_ods_context))
    attributes["interface"] = (interface if (
    isinstance(interface, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolRefArrayAttr')) else
      _ods_ir.AttrBuilder.get('SymbolRefArrayAttr')(interface, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def execution_model(self):
    return self.operation.attributes["execution_model"]

  @execution_model.setter
  def execution_model(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["execution_model"] = value

  @builtins.property
  def fn(self):
    return self.operation.attributes["fn"]

  @fn.setter
  def fn(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fn"] = value

  @builtins.property
  def interface(self):
    return self.operation.attributes["interface"]

  @interface.setter
  def interface(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["interface"] = value

def EntryPoint(execution_model, fn, interface, *, loc=None, ip=None) -> _ods_ir.Operation:
  return EntryPointOp(execution_model=execution_model, fn=fn, interface=interface, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ExecutionModeOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.ExecutionMode"

  _ODS_REGIONS = (0, True)

  def __init__(self, fn, execution_mode, values, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["fn"] = (fn if (
    isinstance(fn, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('FlatSymbolRefAttr')) else
      _ods_ir.AttrBuilder.get('FlatSymbolRefAttr')(fn, context=_ods_context))
    attributes["execution_mode"] = (execution_mode if (
    isinstance(execution_mode, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ExecutionModeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ExecutionModeAttr')(execution_mode, context=_ods_context))
    attributes["values"] = (values if (
    isinstance(values, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I32ArrayAttr')(values, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def fn(self):
    return self.operation.attributes["fn"]

  @fn.setter
  def fn(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fn"] = value

  @builtins.property
  def execution_mode(self):
    return self.operation.attributes["execution_mode"]

  @execution_mode.setter
  def execution_mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["execution_mode"] = value

  @builtins.property
  def values(self):
    return self.operation.attributes["values"]

  @values.setter
  def values(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["values"] = value

def ExecutionMode(fn, execution_mode, values, *, loc=None, ip=None) -> _ods_ir.Operation:
  return ExecutionModeOp(fn=fn, execution_mode=execution_mode, values=values, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class FAddOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.FAdd"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand1, operand2, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand1)
    operands.append(operand2)
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand1(self):
    return self.operation.operands[0]

  @builtins.property
  def operand2(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def FAdd(operand1, operand2, *, loc=None, ip=None) -> _ods_ir.Value:
  return FAddOp(operand1=operand1, operand2=operand2, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FConvertOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.FConvert"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def FConvert(result, operand, *, loc=None, ip=None) -> _ods_ir.Value:
  return FConvertOp(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FDivOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.FDiv"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand1, operand2, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand1)
    operands.append(operand2)
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand1(self):
    return self.operation.operands[0]

  @builtins.property
  def operand2(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def FDiv(operand1, operand2, *, loc=None, ip=None) -> _ods_ir.Value:
  return FDivOp(operand1=operand1, operand2=operand2, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FModOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.FMod"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand1, operand2, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand1)
    operands.append(operand2)
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand1(self):
    return self.operation.operands[0]

  @builtins.property
  def operand2(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def FMod(operand1, operand2, *, loc=None, ip=None) -> _ods_ir.Value:
  return FModOp(operand1=operand1, operand2=operand2, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FMulOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.FMul"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand1, operand2, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand1)
    operands.append(operand2)
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand1(self):
    return self.operation.operands[0]

  @builtins.property
  def operand2(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def FMul(operand1, operand2, *, loc=None, ip=None) -> _ods_ir.Value:
  return FMulOp(operand1=operand1, operand2=operand2, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FNegateOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.FNegate"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def FNegate(operand, *, loc=None, ip=None) -> _ods_ir.Value:
  return FNegateOp(operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FOrdEqualOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.FOrdEqual"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand1, operand2, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand1)
    operands.append(operand2)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand1(self):
    return self.operation.operands[0]

  @builtins.property
  def operand2(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def FOrdEqual(operand1, operand2, *, loc=None, ip=None) -> _ods_ir.Value:
  return FOrdEqualOp(operand1=operand1, operand2=operand2, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FOrdGreaterThanEqualOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.FOrdGreaterThanEqual"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand1, operand2, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand1)
    operands.append(operand2)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand1(self):
    return self.operation.operands[0]

  @builtins.property
  def operand2(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def FOrdGreaterThanEqual(operand1, operand2, *, loc=None, ip=None) -> _ods_ir.Value:
  return FOrdGreaterThanEqualOp(operand1=operand1, operand2=operand2, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FOrdGreaterThanOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.FOrdGreaterThan"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand1, operand2, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand1)
    operands.append(operand2)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand1(self):
    return self.operation.operands[0]

  @builtins.property
  def operand2(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def FOrdGreaterThan(operand1, operand2, *, loc=None, ip=None) -> _ods_ir.Value:
  return FOrdGreaterThanOp(operand1=operand1, operand2=operand2, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FOrdLessThanEqualOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.FOrdLessThanEqual"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand1, operand2, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand1)
    operands.append(operand2)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand1(self):
    return self.operation.operands[0]

  @builtins.property
  def operand2(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def FOrdLessThanEqual(operand1, operand2, *, loc=None, ip=None) -> _ods_ir.Value:
  return FOrdLessThanEqualOp(operand1=operand1, operand2=operand2, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FOrdLessThanOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.FOrdLessThan"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand1, operand2, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand1)
    operands.append(operand2)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand1(self):
    return self.operation.operands[0]

  @builtins.property
  def operand2(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def FOrdLessThan(operand1, operand2, *, loc=None, ip=None) -> _ods_ir.Value:
  return FOrdLessThanOp(operand1=operand1, operand2=operand2, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FOrdNotEqualOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.FOrdNotEqual"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand1, operand2, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand1)
    operands.append(operand2)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand1(self):
    return self.operation.operands[0]

  @builtins.property
  def operand2(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def FOrdNotEqual(operand1, operand2, *, loc=None, ip=None) -> _ods_ir.Value:
  return FOrdNotEqualOp(operand1=operand1, operand2=operand2, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FRemOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.FRem"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand1, operand2, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand1)
    operands.append(operand2)
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand1(self):
    return self.operation.operands[0]

  @builtins.property
  def operand2(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def FRem(operand1, operand2, *, loc=None, ip=None) -> _ods_ir.Value:
  return FRemOp(operand1=operand1, operand2=operand2, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FSubOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.FSub"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand1, operand2, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand1)
    operands.append(operand2)
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand1(self):
    return self.operation.operands[0]

  @builtins.property
  def operand2(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def FSub(operand1, operand2, *, loc=None, ip=None) -> _ods_ir.Value:
  return FSubOp(operand1=operand1, operand2=operand2, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FUnordEqualOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.FUnordEqual"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand1, operand2, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand1)
    operands.append(operand2)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand1(self):
    return self.operation.operands[0]

  @builtins.property
  def operand2(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def FUnordEqual(operand1, operand2, *, loc=None, ip=None) -> _ods_ir.Value:
  return FUnordEqualOp(operand1=operand1, operand2=operand2, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FUnordGreaterThanEqualOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.FUnordGreaterThanEqual"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand1, operand2, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand1)
    operands.append(operand2)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand1(self):
    return self.operation.operands[0]

  @builtins.property
  def operand2(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def FUnordGreaterThanEqual(operand1, operand2, *, loc=None, ip=None) -> _ods_ir.Value:
  return FUnordGreaterThanEqualOp(operand1=operand1, operand2=operand2, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FUnordGreaterThanOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.FUnordGreaterThan"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand1, operand2, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand1)
    operands.append(operand2)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand1(self):
    return self.operation.operands[0]

  @builtins.property
  def operand2(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def FUnordGreaterThan(operand1, operand2, *, loc=None, ip=None) -> _ods_ir.Value:
  return FUnordGreaterThanOp(operand1=operand1, operand2=operand2, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FUnordLessThanEqualOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.FUnordLessThanEqual"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand1, operand2, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand1)
    operands.append(operand2)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand1(self):
    return self.operation.operands[0]

  @builtins.property
  def operand2(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def FUnordLessThanEqual(operand1, operand2, *, loc=None, ip=None) -> _ods_ir.Value:
  return FUnordLessThanEqualOp(operand1=operand1, operand2=operand2, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FUnordLessThanOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.FUnordLessThan"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand1, operand2, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand1)
    operands.append(operand2)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand1(self):
    return self.operation.operands[0]

  @builtins.property
  def operand2(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def FUnordLessThan(operand1, operand2, *, loc=None, ip=None) -> _ods_ir.Value:
  return FUnordLessThanOp(operand1=operand1, operand2=operand2, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FUnordNotEqualOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.FUnordNotEqual"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand1, operand2, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand1)
    operands.append(operand2)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand1(self):
    return self.operation.operands[0]

  @builtins.property
  def operand2(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def FUnordNotEqual(operand1, operand2, *, loc=None, ip=None) -> _ods_ir.Value:
  return FUnordNotEqualOp(operand1=operand1, operand2=operand2, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FuncOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.func"

  _ODS_REGIONS = (1, True)

  def __init__(self, function_type, sym_name, function_control, *, arg_attrs=None, res_attrs=None, linkage_attributes=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["function_type"] = (function_type if (
    isinstance(function_type, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('anonymous_1850')) else
      _ods_ir.AttrBuilder.get('anonymous_1850')(function_type, context=_ods_context))
    if arg_attrs is not None: attributes["arg_attrs"] = (arg_attrs if (
        isinstance(arg_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(arg_attrs, context=_ods_context))
    if res_attrs is not None: attributes["res_attrs"] = (res_attrs if (
        isinstance(res_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(res_attrs, context=_ods_context))
    attributes["sym_name"] = (sym_name if (
    isinstance(sym_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(sym_name, context=_ods_context))
    attributes["function_control"] = (function_control if (
    isinstance(function_control, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_FunctionControlAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_FunctionControlAttr')(function_control, context=_ods_context))
    if linkage_attributes is not None: attributes["linkage_attributes"] = (linkage_attributes if (
        isinstance(linkage_attributes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('SPIRV_LinkageAttributesAttr')) else
          _ods_ir.AttrBuilder.get('SPIRV_LinkageAttributesAttr')(linkage_attributes, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def function_type(self):
    return self.operation.attributes["function_type"]

  @function_type.setter
  def function_type(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["function_type"] = value

  @builtins.property
  def arg_attrs(self):
    if "arg_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["arg_attrs"]

  @arg_attrs.setter
  def arg_attrs(self, value):
    if value is not None:
      self.operation.attributes["arg_attrs"] = value
    elif "arg_attrs" in self.operation.attributes:
      del self.operation.attributes["arg_attrs"]

  @arg_attrs.deleter
  def arg_attrs(self):
    del self.operation.attributes["arg_attrs"]

  @builtins.property
  def res_attrs(self):
    if "res_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["res_attrs"]

  @res_attrs.setter
  def res_attrs(self, value):
    if value is not None:
      self.operation.attributes["res_attrs"] = value
    elif "res_attrs" in self.operation.attributes:
      del self.operation.attributes["res_attrs"]

  @res_attrs.deleter
  def res_attrs(self):
    del self.operation.attributes["res_attrs"]

  @builtins.property
  def sym_name(self):
    return self.operation.attributes["sym_name"]

  @sym_name.setter
  def sym_name(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sym_name"] = value

  @builtins.property
  def function_control(self):
    return self.operation.attributes["function_control"]

  @function_control.setter
  def function_control(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["function_control"] = value

  @builtins.property
  def linkage_attributes(self):
    if "linkage_attributes" not in self.operation.attributes:
      return None
    return self.operation.attributes["linkage_attributes"]

  @linkage_attributes.setter
  def linkage_attributes(self, value):
    if value is not None:
      self.operation.attributes["linkage_attributes"] = value
    elif "linkage_attributes" in self.operation.attributes:
      del self.operation.attributes["linkage_attributes"]

  @linkage_attributes.deleter
  def linkage_attributes(self):
    del self.operation.attributes["linkage_attributes"]

  @builtins.property
  def body(self):
    return self.regions[0]

def func(function_type, sym_name, function_control, *, arg_attrs=None, res_attrs=None, linkage_attributes=None, loc=None, ip=None) -> _ods_ir.Operation:
  return FuncOp(function_type=function_type, sym_name=sym_name, function_control=function_control, arg_attrs=arg_attrs, res_attrs=res_attrs, linkage_attributes=linkage_attributes, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class FunctionCallOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.FunctionCall"

  _ODS_REGIONS = (0, True)

  def __init__(self, return_value, callee, arguments, *, arg_attrs=None, res_attrs=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(arguments))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["callee"] = (callee if (
    isinstance(callee, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('FlatSymbolRefAttr')) else
      _ods_ir.AttrBuilder.get('FlatSymbolRefAttr')(callee, context=_ods_context))
    if arg_attrs is not None: attributes["arg_attrs"] = (arg_attrs if (
        isinstance(arg_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(arg_attrs, context=_ods_context))
    if res_attrs is not None: attributes["res_attrs"] = (res_attrs if (
        isinstance(res_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(res_attrs, context=_ods_context))
    if return_value is not None: results.append(return_value)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def arguments(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def callee(self):
    return self.operation.attributes["callee"]

  @callee.setter
  def callee(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["callee"] = value

  @builtins.property
  def arg_attrs(self):
    if "arg_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["arg_attrs"]

  @arg_attrs.setter
  def arg_attrs(self, value):
    if value is not None:
      self.operation.attributes["arg_attrs"] = value
    elif "arg_attrs" in self.operation.attributes:
      del self.operation.attributes["arg_attrs"]

  @arg_attrs.deleter
  def arg_attrs(self):
    del self.operation.attributes["arg_attrs"]

  @builtins.property
  def res_attrs(self):
    if "res_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["res_attrs"]

  @res_attrs.setter
  def res_attrs(self, value):
    if value is not None:
      self.operation.attributes["res_attrs"] = value
    elif "res_attrs" in self.operation.attributes:
      del self.operation.attributes["res_attrs"]

  @res_attrs.deleter
  def res_attrs(self):
    del self.operation.attributes["res_attrs"]

  @builtins.property
  def return_value(self):
    return None if len(self.operation.results) < 1 else self.operation.results[0]

def FunctionCall(return_value, callee, arguments, *, arg_attrs=None, res_attrs=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(FunctionCallOp(return_value=return_value, callee=callee, arguments=arguments, arg_attrs=arg_attrs, res_attrs=res_attrs, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class GLAcosOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.GL.Acos"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def GL_Acos(operand, *, loc=None, ip=None) -> _ods_ir.Value:
  return GLAcosOp(operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GLAsinOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.GL.Asin"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def GL_Asin(operand, *, loc=None, ip=None) -> _ods_ir.Value:
  return GLAsinOp(operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GLAtanOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.GL.Atan"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def GL_Atan(operand, *, loc=None, ip=None) -> _ods_ir.Value:
  return GLAtanOp(operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GLCeilOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.GL.Ceil"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def GL_Ceil(operand, *, loc=None, ip=None) -> _ods_ir.Value:
  return GLCeilOp(operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GLCosOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.GL.Cos"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def GL_Cos(operand, *, loc=None, ip=None) -> _ods_ir.Value:
  return GLCosOp(operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GLCoshOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.GL.Cosh"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def GL_Cosh(operand, *, loc=None, ip=None) -> _ods_ir.Value:
  return GLCoshOp(operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GLCrossOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.GL.Cross"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def GL_Cross(lhs, rhs, *, loc=None, ip=None) -> _ods_ir.Value:
  return GLCrossOp(lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GLDistanceOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.GL.Distance"

  _ODS_REGIONS = (0, True)

  def __init__(self, p0, p1, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(p0)
    operands.append(p1)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def p0(self):
    return self.operation.operands[0]

  @builtins.property
  def p1(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def GL_Distance(p0, p1, *, loc=None, ip=None) -> _ods_ir.Value:
  return GLDistanceOp(p0=p0, p1=p1, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GLExpOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.GL.Exp"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def GL_Exp(operand, *, loc=None, ip=None) -> _ods_ir.Value:
  return GLExpOp(operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GLFAbsOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.GL.FAbs"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def GL_FAbs(operand, *, loc=None, ip=None) -> _ods_ir.Value:
  return GLFAbsOp(operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GLFClampOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.GL.FClamp"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, x, y, z, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(x)
    operands.append(y)
    operands.append(z)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def x(self):
    return self.operation.operands[0]

  @builtins.property
  def y(self):
    return self.operation.operands[1]

  @builtins.property
  def z(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def GL_FClamp(result, x, y, z, *, loc=None, ip=None) -> _ods_ir.Value:
  return GLFClampOp(result=result, x=x, y=y, z=z, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GLFMaxOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.GL.FMax"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def GL_FMax(lhs, rhs, *, loc=None, ip=None) -> _ods_ir.Value:
  return GLFMaxOp(lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GLFMinOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.GL.FMin"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def GL_FMin(lhs, rhs, *, loc=None, ip=None) -> _ods_ir.Value:
  return GLFMinOp(lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GLFMixOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.GL.FMix"

  _ODS_REGIONS = (0, True)

  def __init__(self, x, y, a, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(x)
    operands.append(y)
    operands.append(a)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def x(self):
    return self.operation.operands[0]

  @builtins.property
  def y(self):
    return self.operation.operands[1]

  @builtins.property
  def a(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def GL_FMix(x, y, a, *, loc=None, ip=None) -> _ods_ir.Value:
  return GLFMixOp(x=x, y=y, a=a, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GLFSignOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.GL.FSign"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def GL_FSign(operand, *, loc=None, ip=None) -> _ods_ir.Value:
  return GLFSignOp(operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GLFindUMsbOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.GL.FindUMsb"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def GL_FindUMsb(operand, *, loc=None, ip=None) -> _ods_ir.Value:
  return GLFindUMsbOp(operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GLFloorOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.GL.Floor"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def GL_Floor(operand, *, loc=None, ip=None) -> _ods_ir.Value:
  return GLFloorOp(operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GLFmaOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.GL.Fma"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, x, y, z, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(x)
    operands.append(y)
    operands.append(z)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def x(self):
    return self.operation.operands[0]

  @builtins.property
  def y(self):
    return self.operation.operands[1]

  @builtins.property
  def z(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def GL_Fma(result, x, y, z, *, loc=None, ip=None) -> _ods_ir.Value:
  return GLFmaOp(result=result, x=x, y=y, z=z, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GLFractOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.GL.Fract"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def GL_Fract(operand, *, loc=None, ip=None) -> _ods_ir.Value:
  return GLFractOp(operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GLFrexpStructOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.GL.FrexpStruct"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def GL_FrexpStruct(result, operand, *, loc=None, ip=None) -> _ods_ir.Value:
  return GLFrexpStructOp(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GLInverseSqrtOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.GL.InverseSqrt"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def GL_InverseSqrt(operand, *, loc=None, ip=None) -> _ods_ir.Value:
  return GLInverseSqrtOp(operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GLLdexpOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.GL.Ldexp"

  _ODS_REGIONS = (0, True)

  def __init__(self, x, exp, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(x)
    operands.append(exp)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def x(self):
    return self.operation.operands[0]

  @builtins.property
  def exp(self):
    return self.operation.operands[1]

  @builtins.property
  def y(self):
    return self.operation.results[0]

def GL_Ldexp(x, exp, *, loc=None, ip=None) -> _ods_ir.Value:
  return GLLdexpOp(x=x, exp=exp, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GLLogOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.GL.Log"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def GL_Log(operand, *, loc=None, ip=None) -> _ods_ir.Value:
  return GLLogOp(operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GLNormalizeOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.GL.Normalize"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def GL_Normalize(operand, *, loc=None, ip=None) -> _ods_ir.Value:
  return GLNormalizeOp(operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GLPowOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.GL.Pow"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def GL_Pow(lhs, rhs, *, loc=None, ip=None) -> _ods_ir.Value:
  return GLPowOp(lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GLReflectOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.GL.Reflect"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def GL_Reflect(lhs, rhs, *, loc=None, ip=None) -> _ods_ir.Value:
  return GLReflectOp(lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GLRoundEvenOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.GL.RoundEven"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def GL_RoundEven(operand, *, loc=None, ip=None) -> _ods_ir.Value:
  return GLRoundEvenOp(operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GLRoundOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.GL.Round"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def GL_Round(operand, *, loc=None, ip=None) -> _ods_ir.Value:
  return GLRoundOp(operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GLSAbsOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.GL.SAbs"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def GL_SAbs(operand, *, loc=None, ip=None) -> _ods_ir.Value:
  return GLSAbsOp(operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GLSClampOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.GL.SClamp"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, x, y, z, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(x)
    operands.append(y)
    operands.append(z)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def x(self):
    return self.operation.operands[0]

  @builtins.property
  def y(self):
    return self.operation.operands[1]

  @builtins.property
  def z(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def GL_SClamp(result, x, y, z, *, loc=None, ip=None) -> _ods_ir.Value:
  return GLSClampOp(result=result, x=x, y=y, z=z, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GLSMaxOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.GL.SMax"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def GL_SMax(lhs, rhs, *, loc=None, ip=None) -> _ods_ir.Value:
  return GLSMaxOp(lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GLSMinOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.GL.SMin"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def GL_SMin(lhs, rhs, *, loc=None, ip=None) -> _ods_ir.Value:
  return GLSMinOp(lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GLSSignOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.GL.SSign"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def GL_SSign(operand, *, loc=None, ip=None) -> _ods_ir.Value:
  return GLSSignOp(operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GLSinOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.GL.Sin"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def GL_Sin(operand, *, loc=None, ip=None) -> _ods_ir.Value:
  return GLSinOp(operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GLSinhOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.GL.Sinh"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def GL_Sinh(operand, *, loc=None, ip=None) -> _ods_ir.Value:
  return GLSinhOp(operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GLSqrtOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.GL.Sqrt"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def GL_Sqrt(operand, *, loc=None, ip=None) -> _ods_ir.Value:
  return GLSqrtOp(operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GLTanOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.GL.Tan"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def GL_Tan(operand, *, loc=None, ip=None) -> _ods_ir.Value:
  return GLTanOp(operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GLTanhOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.GL.Tanh"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def GL_Tanh(operand, *, loc=None, ip=None) -> _ods_ir.Value:
  return GLTanhOp(operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GLUClampOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.GL.UClamp"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, x, y, z, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(x)
    operands.append(y)
    operands.append(z)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def x(self):
    return self.operation.operands[0]

  @builtins.property
  def y(self):
    return self.operation.operands[1]

  @builtins.property
  def z(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def GL_UClamp(result, x, y, z, *, loc=None, ip=None) -> _ods_ir.Value:
  return GLUClampOp(result=result, x=x, y=y, z=z, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GLUMaxOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.GL.UMax"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def GL_UMax(lhs, rhs, *, loc=None, ip=None) -> _ods_ir.Value:
  return GLUMaxOp(lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GLUMinOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.GL.UMin"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def GL_UMin(lhs, rhs, *, loc=None, ip=None) -> _ods_ir.Value:
  return GLUMinOp(lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GenericCastToPtrExplicitOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.GenericCastToPtrExplicit"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, pointer, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(pointer)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def pointer(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def GenericCastToPtrExplicit(result, pointer, *, loc=None, ip=None) -> _ods_ir.Value:
  return GenericCastToPtrExplicitOp(result=result, pointer=pointer, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GenericCastToPtrOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.GenericCastToPtr"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, pointer, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(pointer)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def pointer(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def GenericCastToPtr(result, pointer, *, loc=None, ip=None) -> _ods_ir.Value:
  return GenericCastToPtrOp(result=result, pointer=pointer, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GlobalVariableOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.GlobalVariable"

  _ODS_REGIONS = (0, True)

  def __init__(self, type_, sym_name, *, initializer=None, location=None, binding=None, descriptor_set=None, builtin=None, linkage_attributes=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["type"] = (type_ if (
    isinstance(type_, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypeAttr')) else
      _ods_ir.AttrBuilder.get('TypeAttr')(type_, context=_ods_context))
    attributes["sym_name"] = (sym_name if (
    isinstance(sym_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(sym_name, context=_ods_context))
    if initializer is not None: attributes["initializer"] = (initializer if (
        isinstance(initializer, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('FlatSymbolRefAttr')) else
          _ods_ir.AttrBuilder.get('FlatSymbolRefAttr')(initializer, context=_ods_context))
    if location is not None: attributes["location"] = (location if (
        isinstance(location, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I32Attr')) else
          _ods_ir.AttrBuilder.get('I32Attr')(location, context=_ods_context))
    if binding is not None: attributes["binding"] = (binding if (
        isinstance(binding, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I32Attr')) else
          _ods_ir.AttrBuilder.get('I32Attr')(binding, context=_ods_context))
    if descriptor_set is not None: attributes["descriptor_set"] = (descriptor_set if (
        isinstance(descriptor_set, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I32Attr')) else
          _ods_ir.AttrBuilder.get('I32Attr')(descriptor_set, context=_ods_context))
    if builtin is not None: attributes["builtin"] = (builtin if (
        isinstance(builtin, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(builtin, context=_ods_context))
    if linkage_attributes is not None: attributes["linkage_attributes"] = (linkage_attributes if (
        isinstance(linkage_attributes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('SPIRV_LinkageAttributesAttr')) else
          _ods_ir.AttrBuilder.get('SPIRV_LinkageAttributesAttr')(linkage_attributes, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def type_(self):
    return self.operation.attributes["type"]

  @type_.setter
  def type_(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["type"] = value

  @builtins.property
  def sym_name(self):
    return self.operation.attributes["sym_name"]

  @sym_name.setter
  def sym_name(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sym_name"] = value

  @builtins.property
  def initializer(self):
    if "initializer" not in self.operation.attributes:
      return None
    return self.operation.attributes["initializer"]

  @initializer.setter
  def initializer(self, value):
    if value is not None:
      self.operation.attributes["initializer"] = value
    elif "initializer" in self.operation.attributes:
      del self.operation.attributes["initializer"]

  @initializer.deleter
  def initializer(self):
    del self.operation.attributes["initializer"]

  @builtins.property
  def location(self):
    if "location" not in self.operation.attributes:
      return None
    return self.operation.attributes["location"]

  @location.setter
  def location(self, value):
    if value is not None:
      self.operation.attributes["location"] = value
    elif "location" in self.operation.attributes:
      del self.operation.attributes["location"]

  @location.deleter
  def location(self):
    del self.operation.attributes["location"]

  @builtins.property
  def binding(self):
    if "binding" not in self.operation.attributes:
      return None
    return self.operation.attributes["binding"]

  @binding.setter
  def binding(self, value):
    if value is not None:
      self.operation.attributes["binding"] = value
    elif "binding" in self.operation.attributes:
      del self.operation.attributes["binding"]

  @binding.deleter
  def binding(self):
    del self.operation.attributes["binding"]

  @builtins.property
  def descriptor_set(self):
    if "descriptor_set" not in self.operation.attributes:
      return None
    return self.operation.attributes["descriptor_set"]

  @descriptor_set.setter
  def descriptor_set(self, value):
    if value is not None:
      self.operation.attributes["descriptor_set"] = value
    elif "descriptor_set" in self.operation.attributes:
      del self.operation.attributes["descriptor_set"]

  @descriptor_set.deleter
  def descriptor_set(self):
    del self.operation.attributes["descriptor_set"]

  @builtins.property
  def builtin(self):
    if "builtin" not in self.operation.attributes:
      return None
    return self.operation.attributes["builtin"]

  @builtin.setter
  def builtin(self, value):
    if value is not None:
      self.operation.attributes["builtin"] = value
    elif "builtin" in self.operation.attributes:
      del self.operation.attributes["builtin"]

  @builtin.deleter
  def builtin(self):
    del self.operation.attributes["builtin"]

  @builtins.property
  def linkage_attributes(self):
    if "linkage_attributes" not in self.operation.attributes:
      return None
    return self.operation.attributes["linkage_attributes"]

  @linkage_attributes.setter
  def linkage_attributes(self, value):
    if value is not None:
      self.operation.attributes["linkage_attributes"] = value
    elif "linkage_attributes" in self.operation.attributes:
      del self.operation.attributes["linkage_attributes"]

  @linkage_attributes.deleter
  def linkage_attributes(self):
    del self.operation.attributes["linkage_attributes"]

def GlobalVariable(type_, sym_name, *, initializer=None, location=None, binding=None, descriptor_set=None, builtin=None, linkage_attributes=None, loc=None, ip=None) -> _ods_ir.Operation:
  return GlobalVariableOp(type_=type_, sym_name=sym_name, initializer=initializer, location=location, binding=binding, descriptor_set=descriptor_set, builtin=builtin, linkage_attributes=linkage_attributes, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class GroupBroadcastOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.GroupBroadcast"

  _ODS_REGIONS = (0, True)

  def __init__(self, execution_scope, value, localid, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(value)
    operands.append(localid)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["execution_scope"] = (execution_scope if (
    isinstance(execution_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(execution_scope, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self):
    return self.operation.operands[0]

  @builtins.property
  def localid(self):
    return self.operation.operands[1]

  @builtins.property
  def execution_scope(self):
    return self.operation.attributes["execution_scope"]

  @execution_scope.setter
  def execution_scope(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["execution_scope"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def GroupBroadcast(execution_scope, value, localid, *, loc=None, ip=None) -> _ods_ir.Value:
  return GroupBroadcastOp(execution_scope=execution_scope, value=value, localid=localid, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GroupFAddOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.GroupFAdd"

  _ODS_REGIONS = (0, True)

  def __init__(self, execution_scope, group_operation, x, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(x)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["execution_scope"] = (execution_scope if (
    isinstance(execution_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(execution_scope, context=_ods_context))
    attributes["group_operation"] = (group_operation if (
    isinstance(group_operation, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_GroupOperationAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_GroupOperationAttr')(group_operation, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def x(self):
    return self.operation.operands[0]

  @builtins.property
  def execution_scope(self):
    return self.operation.attributes["execution_scope"]

  @execution_scope.setter
  def execution_scope(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["execution_scope"] = value

  @builtins.property
  def group_operation(self):
    return self.operation.attributes["group_operation"]

  @group_operation.setter
  def group_operation(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["group_operation"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def GroupFAdd(execution_scope, group_operation, x, *, loc=None, ip=None) -> _ods_ir.Value:
  return GroupFAddOp(execution_scope=execution_scope, group_operation=group_operation, x=x, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GroupFMaxOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.GroupFMax"

  _ODS_REGIONS = (0, True)

  def __init__(self, execution_scope, group_operation, x, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(x)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["execution_scope"] = (execution_scope if (
    isinstance(execution_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(execution_scope, context=_ods_context))
    attributes["group_operation"] = (group_operation if (
    isinstance(group_operation, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_GroupOperationAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_GroupOperationAttr')(group_operation, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def x(self):
    return self.operation.operands[0]

  @builtins.property
  def execution_scope(self):
    return self.operation.attributes["execution_scope"]

  @execution_scope.setter
  def execution_scope(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["execution_scope"] = value

  @builtins.property
  def group_operation(self):
    return self.operation.attributes["group_operation"]

  @group_operation.setter
  def group_operation(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["group_operation"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def GroupFMax(execution_scope, group_operation, x, *, loc=None, ip=None) -> _ods_ir.Value:
  return GroupFMaxOp(execution_scope=execution_scope, group_operation=group_operation, x=x, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GroupFMinOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.GroupFMin"

  _ODS_REGIONS = (0, True)

  def __init__(self, execution_scope, group_operation, x, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(x)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["execution_scope"] = (execution_scope if (
    isinstance(execution_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(execution_scope, context=_ods_context))
    attributes["group_operation"] = (group_operation if (
    isinstance(group_operation, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_GroupOperationAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_GroupOperationAttr')(group_operation, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def x(self):
    return self.operation.operands[0]

  @builtins.property
  def execution_scope(self):
    return self.operation.attributes["execution_scope"]

  @execution_scope.setter
  def execution_scope(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["execution_scope"] = value

  @builtins.property
  def group_operation(self):
    return self.operation.attributes["group_operation"]

  @group_operation.setter
  def group_operation(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["group_operation"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def GroupFMin(execution_scope, group_operation, x, *, loc=None, ip=None) -> _ods_ir.Value:
  return GroupFMinOp(execution_scope=execution_scope, group_operation=group_operation, x=x, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GroupFMulKHROp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.KHR.GroupFMul"

  _ODS_REGIONS = (0, True)

  def __init__(self, execution_scope, group_operation, x, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(x)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["execution_scope"] = (execution_scope if (
    isinstance(execution_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(execution_scope, context=_ods_context))
    attributes["group_operation"] = (group_operation if (
    isinstance(group_operation, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_GroupOperationAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_GroupOperationAttr')(group_operation, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def x(self):
    return self.operation.operands[0]

  @builtins.property
  def execution_scope(self):
    return self.operation.attributes["execution_scope"]

  @execution_scope.setter
  def execution_scope(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["execution_scope"] = value

  @builtins.property
  def group_operation(self):
    return self.operation.attributes["group_operation"]

  @group_operation.setter
  def group_operation(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["group_operation"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def KHR_GroupFMul(execution_scope, group_operation, x, *, loc=None, ip=None) -> _ods_ir.Value:
  return GroupFMulKHROp(execution_scope=execution_scope, group_operation=group_operation, x=x, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GroupIAddOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.GroupIAdd"

  _ODS_REGIONS = (0, True)

  def __init__(self, execution_scope, group_operation, x, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(x)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["execution_scope"] = (execution_scope if (
    isinstance(execution_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(execution_scope, context=_ods_context))
    attributes["group_operation"] = (group_operation if (
    isinstance(group_operation, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_GroupOperationAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_GroupOperationAttr')(group_operation, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def x(self):
    return self.operation.operands[0]

  @builtins.property
  def execution_scope(self):
    return self.operation.attributes["execution_scope"]

  @execution_scope.setter
  def execution_scope(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["execution_scope"] = value

  @builtins.property
  def group_operation(self):
    return self.operation.attributes["group_operation"]

  @group_operation.setter
  def group_operation(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["group_operation"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def GroupIAdd(execution_scope, group_operation, x, *, loc=None, ip=None) -> _ods_ir.Value:
  return GroupIAddOp(execution_scope=execution_scope, group_operation=group_operation, x=x, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GroupIMulKHROp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.KHR.GroupIMul"

  _ODS_REGIONS = (0, True)

  def __init__(self, execution_scope, group_operation, x, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(x)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["execution_scope"] = (execution_scope if (
    isinstance(execution_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(execution_scope, context=_ods_context))
    attributes["group_operation"] = (group_operation if (
    isinstance(group_operation, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_GroupOperationAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_GroupOperationAttr')(group_operation, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def x(self):
    return self.operation.operands[0]

  @builtins.property
  def execution_scope(self):
    return self.operation.attributes["execution_scope"]

  @execution_scope.setter
  def execution_scope(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["execution_scope"] = value

  @builtins.property
  def group_operation(self):
    return self.operation.attributes["group_operation"]

  @group_operation.setter
  def group_operation(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["group_operation"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def KHR_GroupIMul(execution_scope, group_operation, x, *, loc=None, ip=None) -> _ods_ir.Value:
  return GroupIMulKHROp(execution_scope=execution_scope, group_operation=group_operation, x=x, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GroupNonUniformBallotBitCountOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.GroupNonUniformBallotBitCount"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, execution_scope, group_operation, value, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["execution_scope"] = (execution_scope if (
    isinstance(execution_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(execution_scope, context=_ods_context))
    attributes["group_operation"] = (group_operation if (
    isinstance(group_operation, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_GroupOperationAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_GroupOperationAttr')(group_operation, context=_ods_context))
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self):
    return self.operation.operands[0]

  @builtins.property
  def execution_scope(self):
    return self.operation.attributes["execution_scope"]

  @execution_scope.setter
  def execution_scope(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["execution_scope"] = value

  @builtins.property
  def group_operation(self):
    return self.operation.attributes["group_operation"]

  @group_operation.setter
  def group_operation(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["group_operation"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def GroupNonUniformBallotBitCount(result, execution_scope, group_operation, value, *, loc=None, ip=None) -> _ods_ir.Value:
  return GroupNonUniformBallotBitCountOp(result=result, execution_scope=execution_scope, group_operation=group_operation, value=value, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GroupNonUniformBallotFindLSBOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.GroupNonUniformBallotFindLSB"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, execution_scope, value, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["execution_scope"] = (execution_scope if (
    isinstance(execution_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(execution_scope, context=_ods_context))
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self):
    return self.operation.operands[0]

  @builtins.property
  def execution_scope(self):
    return self.operation.attributes["execution_scope"]

  @execution_scope.setter
  def execution_scope(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["execution_scope"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def GroupNonUniformBallotFindLSB(result, execution_scope, value, *, loc=None, ip=None) -> _ods_ir.Value:
  return GroupNonUniformBallotFindLSBOp(result=result, execution_scope=execution_scope, value=value, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GroupNonUniformBallotFindMSBOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.GroupNonUniformBallotFindMSB"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, execution_scope, value, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["execution_scope"] = (execution_scope if (
    isinstance(execution_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(execution_scope, context=_ods_context))
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self):
    return self.operation.operands[0]

  @builtins.property
  def execution_scope(self):
    return self.operation.attributes["execution_scope"]

  @execution_scope.setter
  def execution_scope(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["execution_scope"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def GroupNonUniformBallotFindMSB(result, execution_scope, value, *, loc=None, ip=None) -> _ods_ir.Value:
  return GroupNonUniformBallotFindMSBOp(result=result, execution_scope=execution_scope, value=value, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GroupNonUniformBallotOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.GroupNonUniformBallot"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, execution_scope, predicate, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(predicate)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["execution_scope"] = (execution_scope if (
    isinstance(execution_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(execution_scope, context=_ods_context))
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def predicate(self):
    return self.operation.operands[0]

  @builtins.property
  def execution_scope(self):
    return self.operation.attributes["execution_scope"]

  @execution_scope.setter
  def execution_scope(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["execution_scope"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def GroupNonUniformBallot(result, execution_scope, predicate, *, loc=None, ip=None) -> _ods_ir.Value:
  return GroupNonUniformBallotOp(result=result, execution_scope=execution_scope, predicate=predicate, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GroupNonUniformBitwiseAndOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.GroupNonUniformBitwiseAnd"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, execution_scope, group_operation, value, *, cluster_size=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(value)
    if cluster_size is not None: operands.append(cluster_size)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["execution_scope"] = (execution_scope if (
    isinstance(execution_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(execution_scope, context=_ods_context))
    attributes["group_operation"] = (group_operation if (
    isinstance(group_operation, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_GroupOperationAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_GroupOperationAttr')(group_operation, context=_ods_context))
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self):
    return self.operation.operands[0]

  @builtins.property
  def cluster_size(self):
    return None if len(self.operation.operands) < 2 else self.operation.operands[1]

  @builtins.property
  def execution_scope(self):
    return self.operation.attributes["execution_scope"]

  @execution_scope.setter
  def execution_scope(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["execution_scope"] = value

  @builtins.property
  def group_operation(self):
    return self.operation.attributes["group_operation"]

  @group_operation.setter
  def group_operation(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["group_operation"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def GroupNonUniformBitwiseAnd(result, execution_scope, group_operation, value, *, cluster_size=None, loc=None, ip=None) -> _ods_ir.Value:
  return GroupNonUniformBitwiseAndOp(result=result, execution_scope=execution_scope, group_operation=group_operation, value=value, cluster_size=cluster_size, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GroupNonUniformBitwiseOrOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.GroupNonUniformBitwiseOr"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, execution_scope, group_operation, value, *, cluster_size=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(value)
    if cluster_size is not None: operands.append(cluster_size)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["execution_scope"] = (execution_scope if (
    isinstance(execution_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(execution_scope, context=_ods_context))
    attributes["group_operation"] = (group_operation if (
    isinstance(group_operation, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_GroupOperationAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_GroupOperationAttr')(group_operation, context=_ods_context))
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self):
    return self.operation.operands[0]

  @builtins.property
  def cluster_size(self):
    return None if len(self.operation.operands) < 2 else self.operation.operands[1]

  @builtins.property
  def execution_scope(self):
    return self.operation.attributes["execution_scope"]

  @execution_scope.setter
  def execution_scope(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["execution_scope"] = value

  @builtins.property
  def group_operation(self):
    return self.operation.attributes["group_operation"]

  @group_operation.setter
  def group_operation(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["group_operation"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def GroupNonUniformBitwiseOr(result, execution_scope, group_operation, value, *, cluster_size=None, loc=None, ip=None) -> _ods_ir.Value:
  return GroupNonUniformBitwiseOrOp(result=result, execution_scope=execution_scope, group_operation=group_operation, value=value, cluster_size=cluster_size, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GroupNonUniformBitwiseXorOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.GroupNonUniformBitwiseXor"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, execution_scope, group_operation, value, *, cluster_size=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(value)
    if cluster_size is not None: operands.append(cluster_size)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["execution_scope"] = (execution_scope if (
    isinstance(execution_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(execution_scope, context=_ods_context))
    attributes["group_operation"] = (group_operation if (
    isinstance(group_operation, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_GroupOperationAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_GroupOperationAttr')(group_operation, context=_ods_context))
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self):
    return self.operation.operands[0]

  @builtins.property
  def cluster_size(self):
    return None if len(self.operation.operands) < 2 else self.operation.operands[1]

  @builtins.property
  def execution_scope(self):
    return self.operation.attributes["execution_scope"]

  @execution_scope.setter
  def execution_scope(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["execution_scope"] = value

  @builtins.property
  def group_operation(self):
    return self.operation.attributes["group_operation"]

  @group_operation.setter
  def group_operation(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["group_operation"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def GroupNonUniformBitwiseXor(result, execution_scope, group_operation, value, *, cluster_size=None, loc=None, ip=None) -> _ods_ir.Value:
  return GroupNonUniformBitwiseXorOp(result=result, execution_scope=execution_scope, group_operation=group_operation, value=value, cluster_size=cluster_size, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GroupNonUniformBroadcastOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.GroupNonUniformBroadcast"

  _ODS_REGIONS = (0, True)

  def __init__(self, execution_scope, value, id, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(value)
    operands.append(id)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["execution_scope"] = (execution_scope if (
    isinstance(execution_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(execution_scope, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self):
    return self.operation.operands[0]

  @builtins.property
  def id(self):
    return self.operation.operands[1]

  @builtins.property
  def execution_scope(self):
    return self.operation.attributes["execution_scope"]

  @execution_scope.setter
  def execution_scope(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["execution_scope"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def GroupNonUniformBroadcast(execution_scope, value, id, *, loc=None, ip=None) -> _ods_ir.Value:
  return GroupNonUniformBroadcastOp(execution_scope=execution_scope, value=value, id=id, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GroupNonUniformElectOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.GroupNonUniformElect"

  _ODS_REGIONS = (0, True)

  def __init__(self, execution_scope, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["execution_scope"] = (execution_scope if (
    isinstance(execution_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(execution_scope, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def execution_scope(self):
    return self.operation.attributes["execution_scope"]

  @execution_scope.setter
  def execution_scope(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["execution_scope"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def GroupNonUniformElect(execution_scope, *, loc=None, ip=None) -> _ods_ir.Value:
  return GroupNonUniformElectOp(execution_scope=execution_scope, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GroupNonUniformFAddOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.GroupNonUniformFAdd"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, execution_scope, group_operation, value, *, cluster_size=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(value)
    if cluster_size is not None: operands.append(cluster_size)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["execution_scope"] = (execution_scope if (
    isinstance(execution_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(execution_scope, context=_ods_context))
    attributes["group_operation"] = (group_operation if (
    isinstance(group_operation, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_GroupOperationAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_GroupOperationAttr')(group_operation, context=_ods_context))
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self):
    return self.operation.operands[0]

  @builtins.property
  def cluster_size(self):
    return None if len(self.operation.operands) < 2 else self.operation.operands[1]

  @builtins.property
  def execution_scope(self):
    return self.operation.attributes["execution_scope"]

  @execution_scope.setter
  def execution_scope(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["execution_scope"] = value

  @builtins.property
  def group_operation(self):
    return self.operation.attributes["group_operation"]

  @group_operation.setter
  def group_operation(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["group_operation"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def GroupNonUniformFAdd(result, execution_scope, group_operation, value, *, cluster_size=None, loc=None, ip=None) -> _ods_ir.Value:
  return GroupNonUniformFAddOp(result=result, execution_scope=execution_scope, group_operation=group_operation, value=value, cluster_size=cluster_size, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GroupNonUniformFMaxOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.GroupNonUniformFMax"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, execution_scope, group_operation, value, *, cluster_size=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(value)
    if cluster_size is not None: operands.append(cluster_size)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["execution_scope"] = (execution_scope if (
    isinstance(execution_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(execution_scope, context=_ods_context))
    attributes["group_operation"] = (group_operation if (
    isinstance(group_operation, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_GroupOperationAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_GroupOperationAttr')(group_operation, context=_ods_context))
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self):
    return self.operation.operands[0]

  @builtins.property
  def cluster_size(self):
    return None if len(self.operation.operands) < 2 else self.operation.operands[1]

  @builtins.property
  def execution_scope(self):
    return self.operation.attributes["execution_scope"]

  @execution_scope.setter
  def execution_scope(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["execution_scope"] = value

  @builtins.property
  def group_operation(self):
    return self.operation.attributes["group_operation"]

  @group_operation.setter
  def group_operation(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["group_operation"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def GroupNonUniformFMax(result, execution_scope, group_operation, value, *, cluster_size=None, loc=None, ip=None) -> _ods_ir.Value:
  return GroupNonUniformFMaxOp(result=result, execution_scope=execution_scope, group_operation=group_operation, value=value, cluster_size=cluster_size, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GroupNonUniformFMinOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.GroupNonUniformFMin"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, execution_scope, group_operation, value, *, cluster_size=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(value)
    if cluster_size is not None: operands.append(cluster_size)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["execution_scope"] = (execution_scope if (
    isinstance(execution_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(execution_scope, context=_ods_context))
    attributes["group_operation"] = (group_operation if (
    isinstance(group_operation, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_GroupOperationAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_GroupOperationAttr')(group_operation, context=_ods_context))
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self):
    return self.operation.operands[0]

  @builtins.property
  def cluster_size(self):
    return None if len(self.operation.operands) < 2 else self.operation.operands[1]

  @builtins.property
  def execution_scope(self):
    return self.operation.attributes["execution_scope"]

  @execution_scope.setter
  def execution_scope(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["execution_scope"] = value

  @builtins.property
  def group_operation(self):
    return self.operation.attributes["group_operation"]

  @group_operation.setter
  def group_operation(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["group_operation"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def GroupNonUniformFMin(result, execution_scope, group_operation, value, *, cluster_size=None, loc=None, ip=None) -> _ods_ir.Value:
  return GroupNonUniformFMinOp(result=result, execution_scope=execution_scope, group_operation=group_operation, value=value, cluster_size=cluster_size, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GroupNonUniformFMulOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.GroupNonUniformFMul"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, execution_scope, group_operation, value, *, cluster_size=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(value)
    if cluster_size is not None: operands.append(cluster_size)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["execution_scope"] = (execution_scope if (
    isinstance(execution_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(execution_scope, context=_ods_context))
    attributes["group_operation"] = (group_operation if (
    isinstance(group_operation, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_GroupOperationAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_GroupOperationAttr')(group_operation, context=_ods_context))
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self):
    return self.operation.operands[0]

  @builtins.property
  def cluster_size(self):
    return None if len(self.operation.operands) < 2 else self.operation.operands[1]

  @builtins.property
  def execution_scope(self):
    return self.operation.attributes["execution_scope"]

  @execution_scope.setter
  def execution_scope(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["execution_scope"] = value

  @builtins.property
  def group_operation(self):
    return self.operation.attributes["group_operation"]

  @group_operation.setter
  def group_operation(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["group_operation"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def GroupNonUniformFMul(result, execution_scope, group_operation, value, *, cluster_size=None, loc=None, ip=None) -> _ods_ir.Value:
  return GroupNonUniformFMulOp(result=result, execution_scope=execution_scope, group_operation=group_operation, value=value, cluster_size=cluster_size, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GroupNonUniformIAddOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.GroupNonUniformIAdd"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, execution_scope, group_operation, value, *, cluster_size=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(value)
    if cluster_size is not None: operands.append(cluster_size)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["execution_scope"] = (execution_scope if (
    isinstance(execution_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(execution_scope, context=_ods_context))
    attributes["group_operation"] = (group_operation if (
    isinstance(group_operation, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_GroupOperationAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_GroupOperationAttr')(group_operation, context=_ods_context))
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self):
    return self.operation.operands[0]

  @builtins.property
  def cluster_size(self):
    return None if len(self.operation.operands) < 2 else self.operation.operands[1]

  @builtins.property
  def execution_scope(self):
    return self.operation.attributes["execution_scope"]

  @execution_scope.setter
  def execution_scope(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["execution_scope"] = value

  @builtins.property
  def group_operation(self):
    return self.operation.attributes["group_operation"]

  @group_operation.setter
  def group_operation(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["group_operation"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def GroupNonUniformIAdd(result, execution_scope, group_operation, value, *, cluster_size=None, loc=None, ip=None) -> _ods_ir.Value:
  return GroupNonUniformIAddOp(result=result, execution_scope=execution_scope, group_operation=group_operation, value=value, cluster_size=cluster_size, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GroupNonUniformIMulOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.GroupNonUniformIMul"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, execution_scope, group_operation, value, *, cluster_size=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(value)
    if cluster_size is not None: operands.append(cluster_size)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["execution_scope"] = (execution_scope if (
    isinstance(execution_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(execution_scope, context=_ods_context))
    attributes["group_operation"] = (group_operation if (
    isinstance(group_operation, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_GroupOperationAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_GroupOperationAttr')(group_operation, context=_ods_context))
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self):
    return self.operation.operands[0]

  @builtins.property
  def cluster_size(self):
    return None if len(self.operation.operands) < 2 else self.operation.operands[1]

  @builtins.property
  def execution_scope(self):
    return self.operation.attributes["execution_scope"]

  @execution_scope.setter
  def execution_scope(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["execution_scope"] = value

  @builtins.property
  def group_operation(self):
    return self.operation.attributes["group_operation"]

  @group_operation.setter
  def group_operation(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["group_operation"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def GroupNonUniformIMul(result, execution_scope, group_operation, value, *, cluster_size=None, loc=None, ip=None) -> _ods_ir.Value:
  return GroupNonUniformIMulOp(result=result, execution_scope=execution_scope, group_operation=group_operation, value=value, cluster_size=cluster_size, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GroupNonUniformLogicalAndOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.GroupNonUniformLogicalAnd"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, execution_scope, group_operation, value, *, cluster_size=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(value)
    if cluster_size is not None: operands.append(cluster_size)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["execution_scope"] = (execution_scope if (
    isinstance(execution_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(execution_scope, context=_ods_context))
    attributes["group_operation"] = (group_operation if (
    isinstance(group_operation, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_GroupOperationAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_GroupOperationAttr')(group_operation, context=_ods_context))
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self):
    return self.operation.operands[0]

  @builtins.property
  def cluster_size(self):
    return None if len(self.operation.operands) < 2 else self.operation.operands[1]

  @builtins.property
  def execution_scope(self):
    return self.operation.attributes["execution_scope"]

  @execution_scope.setter
  def execution_scope(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["execution_scope"] = value

  @builtins.property
  def group_operation(self):
    return self.operation.attributes["group_operation"]

  @group_operation.setter
  def group_operation(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["group_operation"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def GroupNonUniformLogicalAnd(result, execution_scope, group_operation, value, *, cluster_size=None, loc=None, ip=None) -> _ods_ir.Value:
  return GroupNonUniformLogicalAndOp(result=result, execution_scope=execution_scope, group_operation=group_operation, value=value, cluster_size=cluster_size, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GroupNonUniformLogicalOrOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.GroupNonUniformLogicalOr"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, execution_scope, group_operation, value, *, cluster_size=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(value)
    if cluster_size is not None: operands.append(cluster_size)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["execution_scope"] = (execution_scope if (
    isinstance(execution_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(execution_scope, context=_ods_context))
    attributes["group_operation"] = (group_operation if (
    isinstance(group_operation, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_GroupOperationAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_GroupOperationAttr')(group_operation, context=_ods_context))
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self):
    return self.operation.operands[0]

  @builtins.property
  def cluster_size(self):
    return None if len(self.operation.operands) < 2 else self.operation.operands[1]

  @builtins.property
  def execution_scope(self):
    return self.operation.attributes["execution_scope"]

  @execution_scope.setter
  def execution_scope(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["execution_scope"] = value

  @builtins.property
  def group_operation(self):
    return self.operation.attributes["group_operation"]

  @group_operation.setter
  def group_operation(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["group_operation"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def GroupNonUniformLogicalOr(result, execution_scope, group_operation, value, *, cluster_size=None, loc=None, ip=None) -> _ods_ir.Value:
  return GroupNonUniformLogicalOrOp(result=result, execution_scope=execution_scope, group_operation=group_operation, value=value, cluster_size=cluster_size, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GroupNonUniformLogicalXorOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.GroupNonUniformLogicalXor"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, execution_scope, group_operation, value, *, cluster_size=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(value)
    if cluster_size is not None: operands.append(cluster_size)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["execution_scope"] = (execution_scope if (
    isinstance(execution_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(execution_scope, context=_ods_context))
    attributes["group_operation"] = (group_operation if (
    isinstance(group_operation, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_GroupOperationAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_GroupOperationAttr')(group_operation, context=_ods_context))
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self):
    return self.operation.operands[0]

  @builtins.property
  def cluster_size(self):
    return None if len(self.operation.operands) < 2 else self.operation.operands[1]

  @builtins.property
  def execution_scope(self):
    return self.operation.attributes["execution_scope"]

  @execution_scope.setter
  def execution_scope(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["execution_scope"] = value

  @builtins.property
  def group_operation(self):
    return self.operation.attributes["group_operation"]

  @group_operation.setter
  def group_operation(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["group_operation"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def GroupNonUniformLogicalXor(result, execution_scope, group_operation, value, *, cluster_size=None, loc=None, ip=None) -> _ods_ir.Value:
  return GroupNonUniformLogicalXorOp(result=result, execution_scope=execution_scope, group_operation=group_operation, value=value, cluster_size=cluster_size, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GroupNonUniformRotateKHROp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.GroupNonUniformRotateKHR"

  _ODS_REGIONS = (0, True)

  def __init__(self, execution_scope, value, delta, *, cluster_size=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(value)
    operands.append(delta)
    if cluster_size is not None: operands.append(cluster_size)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["execution_scope"] = (execution_scope if (
    isinstance(execution_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(execution_scope, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self):
    return self.operation.operands[0]

  @builtins.property
  def delta(self):
    return self.operation.operands[1]

  @builtins.property
  def cluster_size(self):
    return None if len(self.operation.operands) < 3 else self.operation.operands[2]

  @builtins.property
  def execution_scope(self):
    return self.operation.attributes["execution_scope"]

  @execution_scope.setter
  def execution_scope(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["execution_scope"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def GroupNonUniformRotateKHR(execution_scope, value, delta, *, cluster_size=None, loc=None, ip=None) -> _ods_ir.Value:
  return GroupNonUniformRotateKHROp(execution_scope=execution_scope, value=value, delta=delta, cluster_size=cluster_size, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GroupNonUniformSMaxOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.GroupNonUniformSMax"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, execution_scope, group_operation, value, *, cluster_size=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(value)
    if cluster_size is not None: operands.append(cluster_size)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["execution_scope"] = (execution_scope if (
    isinstance(execution_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(execution_scope, context=_ods_context))
    attributes["group_operation"] = (group_operation if (
    isinstance(group_operation, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_GroupOperationAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_GroupOperationAttr')(group_operation, context=_ods_context))
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self):
    return self.operation.operands[0]

  @builtins.property
  def cluster_size(self):
    return None if len(self.operation.operands) < 2 else self.operation.operands[1]

  @builtins.property
  def execution_scope(self):
    return self.operation.attributes["execution_scope"]

  @execution_scope.setter
  def execution_scope(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["execution_scope"] = value

  @builtins.property
  def group_operation(self):
    return self.operation.attributes["group_operation"]

  @group_operation.setter
  def group_operation(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["group_operation"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def GroupNonUniformSMax(result, execution_scope, group_operation, value, *, cluster_size=None, loc=None, ip=None) -> _ods_ir.Value:
  return GroupNonUniformSMaxOp(result=result, execution_scope=execution_scope, group_operation=group_operation, value=value, cluster_size=cluster_size, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GroupNonUniformSMinOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.GroupNonUniformSMin"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, execution_scope, group_operation, value, *, cluster_size=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(value)
    if cluster_size is not None: operands.append(cluster_size)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["execution_scope"] = (execution_scope if (
    isinstance(execution_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(execution_scope, context=_ods_context))
    attributes["group_operation"] = (group_operation if (
    isinstance(group_operation, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_GroupOperationAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_GroupOperationAttr')(group_operation, context=_ods_context))
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self):
    return self.operation.operands[0]

  @builtins.property
  def cluster_size(self):
    return None if len(self.operation.operands) < 2 else self.operation.operands[1]

  @builtins.property
  def execution_scope(self):
    return self.operation.attributes["execution_scope"]

  @execution_scope.setter
  def execution_scope(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["execution_scope"] = value

  @builtins.property
  def group_operation(self):
    return self.operation.attributes["group_operation"]

  @group_operation.setter
  def group_operation(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["group_operation"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def GroupNonUniformSMin(result, execution_scope, group_operation, value, *, cluster_size=None, loc=None, ip=None) -> _ods_ir.Value:
  return GroupNonUniformSMinOp(result=result, execution_scope=execution_scope, group_operation=group_operation, value=value, cluster_size=cluster_size, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GroupNonUniformShuffleDownOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.GroupNonUniformShuffleDown"

  _ODS_REGIONS = (0, True)

  def __init__(self, execution_scope, value, delta, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(value)
    operands.append(delta)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["execution_scope"] = (execution_scope if (
    isinstance(execution_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(execution_scope, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self):
    return self.operation.operands[0]

  @builtins.property
  def delta(self):
    return self.operation.operands[1]

  @builtins.property
  def execution_scope(self):
    return self.operation.attributes["execution_scope"]

  @execution_scope.setter
  def execution_scope(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["execution_scope"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def GroupNonUniformShuffleDown(execution_scope, value, delta, *, loc=None, ip=None) -> _ods_ir.Value:
  return GroupNonUniformShuffleDownOp(execution_scope=execution_scope, value=value, delta=delta, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GroupNonUniformShuffleOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.GroupNonUniformShuffle"

  _ODS_REGIONS = (0, True)

  def __init__(self, execution_scope, value, id, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(value)
    operands.append(id)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["execution_scope"] = (execution_scope if (
    isinstance(execution_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(execution_scope, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self):
    return self.operation.operands[0]

  @builtins.property
  def id(self):
    return self.operation.operands[1]

  @builtins.property
  def execution_scope(self):
    return self.operation.attributes["execution_scope"]

  @execution_scope.setter
  def execution_scope(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["execution_scope"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def GroupNonUniformShuffle(execution_scope, value, id, *, loc=None, ip=None) -> _ods_ir.Value:
  return GroupNonUniformShuffleOp(execution_scope=execution_scope, value=value, id=id, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GroupNonUniformShuffleUpOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.GroupNonUniformShuffleUp"

  _ODS_REGIONS = (0, True)

  def __init__(self, execution_scope, value, delta, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(value)
    operands.append(delta)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["execution_scope"] = (execution_scope if (
    isinstance(execution_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(execution_scope, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self):
    return self.operation.operands[0]

  @builtins.property
  def delta(self):
    return self.operation.operands[1]

  @builtins.property
  def execution_scope(self):
    return self.operation.attributes["execution_scope"]

  @execution_scope.setter
  def execution_scope(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["execution_scope"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def GroupNonUniformShuffleUp(execution_scope, value, delta, *, loc=None, ip=None) -> _ods_ir.Value:
  return GroupNonUniformShuffleUpOp(execution_scope=execution_scope, value=value, delta=delta, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GroupNonUniformShuffleXorOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.GroupNonUniformShuffleXor"

  _ODS_REGIONS = (0, True)

  def __init__(self, execution_scope, value, mask, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(value)
    operands.append(mask)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["execution_scope"] = (execution_scope if (
    isinstance(execution_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(execution_scope, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self):
    return self.operation.operands[0]

  @builtins.property
  def mask(self):
    return self.operation.operands[1]

  @builtins.property
  def execution_scope(self):
    return self.operation.attributes["execution_scope"]

  @execution_scope.setter
  def execution_scope(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["execution_scope"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def GroupNonUniformShuffleXor(execution_scope, value, mask, *, loc=None, ip=None) -> _ods_ir.Value:
  return GroupNonUniformShuffleXorOp(execution_scope=execution_scope, value=value, mask=mask, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GroupNonUniformUMaxOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.GroupNonUniformUMax"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, execution_scope, group_operation, value, *, cluster_size=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(value)
    if cluster_size is not None: operands.append(cluster_size)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["execution_scope"] = (execution_scope if (
    isinstance(execution_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(execution_scope, context=_ods_context))
    attributes["group_operation"] = (group_operation if (
    isinstance(group_operation, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_GroupOperationAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_GroupOperationAttr')(group_operation, context=_ods_context))
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self):
    return self.operation.operands[0]

  @builtins.property
  def cluster_size(self):
    return None if len(self.operation.operands) < 2 else self.operation.operands[1]

  @builtins.property
  def execution_scope(self):
    return self.operation.attributes["execution_scope"]

  @execution_scope.setter
  def execution_scope(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["execution_scope"] = value

  @builtins.property
  def group_operation(self):
    return self.operation.attributes["group_operation"]

  @group_operation.setter
  def group_operation(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["group_operation"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def GroupNonUniformUMax(result, execution_scope, group_operation, value, *, cluster_size=None, loc=None, ip=None) -> _ods_ir.Value:
  return GroupNonUniformUMaxOp(result=result, execution_scope=execution_scope, group_operation=group_operation, value=value, cluster_size=cluster_size, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GroupNonUniformUMinOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.GroupNonUniformUMin"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, execution_scope, group_operation, value, *, cluster_size=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(value)
    if cluster_size is not None: operands.append(cluster_size)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["execution_scope"] = (execution_scope if (
    isinstance(execution_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(execution_scope, context=_ods_context))
    attributes["group_operation"] = (group_operation if (
    isinstance(group_operation, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_GroupOperationAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_GroupOperationAttr')(group_operation, context=_ods_context))
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self):
    return self.operation.operands[0]

  @builtins.property
  def cluster_size(self):
    return None if len(self.operation.operands) < 2 else self.operation.operands[1]

  @builtins.property
  def execution_scope(self):
    return self.operation.attributes["execution_scope"]

  @execution_scope.setter
  def execution_scope(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["execution_scope"] = value

  @builtins.property
  def group_operation(self):
    return self.operation.attributes["group_operation"]

  @group_operation.setter
  def group_operation(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["group_operation"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def GroupNonUniformUMin(result, execution_scope, group_operation, value, *, cluster_size=None, loc=None, ip=None) -> _ods_ir.Value:
  return GroupNonUniformUMinOp(result=result, execution_scope=execution_scope, group_operation=group_operation, value=value, cluster_size=cluster_size, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GroupSMaxOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.GroupSMax"

  _ODS_REGIONS = (0, True)

  def __init__(self, execution_scope, group_operation, x, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(x)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["execution_scope"] = (execution_scope if (
    isinstance(execution_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(execution_scope, context=_ods_context))
    attributes["group_operation"] = (group_operation if (
    isinstance(group_operation, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_GroupOperationAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_GroupOperationAttr')(group_operation, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def x(self):
    return self.operation.operands[0]

  @builtins.property
  def execution_scope(self):
    return self.operation.attributes["execution_scope"]

  @execution_scope.setter
  def execution_scope(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["execution_scope"] = value

  @builtins.property
  def group_operation(self):
    return self.operation.attributes["group_operation"]

  @group_operation.setter
  def group_operation(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["group_operation"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def GroupSMax(execution_scope, group_operation, x, *, loc=None, ip=None) -> _ods_ir.Value:
  return GroupSMaxOp(execution_scope=execution_scope, group_operation=group_operation, x=x, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GroupSMinOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.GroupSMin"

  _ODS_REGIONS = (0, True)

  def __init__(self, execution_scope, group_operation, x, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(x)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["execution_scope"] = (execution_scope if (
    isinstance(execution_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(execution_scope, context=_ods_context))
    attributes["group_operation"] = (group_operation if (
    isinstance(group_operation, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_GroupOperationAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_GroupOperationAttr')(group_operation, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def x(self):
    return self.operation.operands[0]

  @builtins.property
  def execution_scope(self):
    return self.operation.attributes["execution_scope"]

  @execution_scope.setter
  def execution_scope(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["execution_scope"] = value

  @builtins.property
  def group_operation(self):
    return self.operation.attributes["group_operation"]

  @group_operation.setter
  def group_operation(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["group_operation"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def GroupSMin(execution_scope, group_operation, x, *, loc=None, ip=None) -> _ods_ir.Value:
  return GroupSMinOp(execution_scope=execution_scope, group_operation=group_operation, x=x, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GroupUMaxOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.GroupUMax"

  _ODS_REGIONS = (0, True)

  def __init__(self, execution_scope, group_operation, x, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(x)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["execution_scope"] = (execution_scope if (
    isinstance(execution_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(execution_scope, context=_ods_context))
    attributes["group_operation"] = (group_operation if (
    isinstance(group_operation, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_GroupOperationAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_GroupOperationAttr')(group_operation, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def x(self):
    return self.operation.operands[0]

  @builtins.property
  def execution_scope(self):
    return self.operation.attributes["execution_scope"]

  @execution_scope.setter
  def execution_scope(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["execution_scope"] = value

  @builtins.property
  def group_operation(self):
    return self.operation.attributes["group_operation"]

  @group_operation.setter
  def group_operation(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["group_operation"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def GroupUMax(execution_scope, group_operation, x, *, loc=None, ip=None) -> _ods_ir.Value:
  return GroupUMaxOp(execution_scope=execution_scope, group_operation=group_operation, x=x, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GroupUMinOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.GroupUMin"

  _ODS_REGIONS = (0, True)

  def __init__(self, execution_scope, group_operation, x, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(x)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["execution_scope"] = (execution_scope if (
    isinstance(execution_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(execution_scope, context=_ods_context))
    attributes["group_operation"] = (group_operation if (
    isinstance(group_operation, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_GroupOperationAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_GroupOperationAttr')(group_operation, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def x(self):
    return self.operation.operands[0]

  @builtins.property
  def execution_scope(self):
    return self.operation.attributes["execution_scope"]

  @execution_scope.setter
  def execution_scope(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["execution_scope"] = value

  @builtins.property
  def group_operation(self):
    return self.operation.attributes["group_operation"]

  @group_operation.setter
  def group_operation(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["group_operation"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def GroupUMin(execution_scope, group_operation, x, *, loc=None, ip=None) -> _ods_ir.Value:
  return GroupUMinOp(execution_scope=execution_scope, group_operation=group_operation, x=x, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class IAddCarryOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.IAddCarry"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand1, operand2, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand1)
    operands.append(operand2)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand1(self):
    return self.operation.operands[0]

  @builtins.property
  def operand2(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def IAddCarry(result, operand1, operand2, *, loc=None, ip=None) -> _ods_ir.Value:
  return IAddCarryOp(result=result, operand1=operand1, operand2=operand2, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class IAddOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.IAdd"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand1, operand2, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand1)
    operands.append(operand2)
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand1(self):
    return self.operation.operands[0]

  @builtins.property
  def operand2(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def IAdd(operand1, operand2, *, loc=None, ip=None) -> _ods_ir.Value:
  return IAddOp(operand1=operand1, operand2=operand2, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class IEqualOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.IEqual"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand1, operand2, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand1)
    operands.append(operand2)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand1(self):
    return self.operation.operands[0]

  @builtins.property
  def operand2(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def IEqual(operand1, operand2, *, loc=None, ip=None) -> _ods_ir.Value:
  return IEqualOp(operand1=operand1, operand2=operand2, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class IMulOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.IMul"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand1, operand2, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand1)
    operands.append(operand2)
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand1(self):
    return self.operation.operands[0]

  @builtins.property
  def operand2(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def IMul(operand1, operand2, *, loc=None, ip=None) -> _ods_ir.Value:
  return IMulOp(operand1=operand1, operand2=operand2, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class INTELControlBarrierArriveOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.INTEL.ControlBarrierArrive"

  _ODS_REGIONS = (0, True)

  def __init__(self, execution_scope, memory_scope, memory_semantics, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["execution_scope"] = (execution_scope if (
    isinstance(execution_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(execution_scope, context=_ods_context))
    attributes["memory_scope"] = (memory_scope if (
    isinstance(memory_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(memory_scope, context=_ods_context))
    attributes["memory_semantics"] = (memory_semantics if (
    isinstance(memory_semantics, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_MemorySemanticsAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_MemorySemanticsAttr')(memory_semantics, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def execution_scope(self):
    return self.operation.attributes["execution_scope"]

  @execution_scope.setter
  def execution_scope(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["execution_scope"] = value

  @builtins.property
  def memory_scope(self):
    return self.operation.attributes["memory_scope"]

  @memory_scope.setter
  def memory_scope(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["memory_scope"] = value

  @builtins.property
  def memory_semantics(self):
    return self.operation.attributes["memory_semantics"]

  @memory_semantics.setter
  def memory_semantics(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["memory_semantics"] = value

def INTEL_ControlBarrierArrive(execution_scope, memory_scope, memory_semantics, *, loc=None, ip=None) -> _ods_ir.Operation:
  return INTELControlBarrierArriveOp(execution_scope=execution_scope, memory_scope=memory_scope, memory_semantics=memory_semantics, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class INTELControlBarrierWaitOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.INTEL.ControlBarrierWait"

  _ODS_REGIONS = (0, True)

  def __init__(self, execution_scope, memory_scope, memory_semantics, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["execution_scope"] = (execution_scope if (
    isinstance(execution_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(execution_scope, context=_ods_context))
    attributes["memory_scope"] = (memory_scope if (
    isinstance(memory_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(memory_scope, context=_ods_context))
    attributes["memory_semantics"] = (memory_semantics if (
    isinstance(memory_semantics, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_MemorySemanticsAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_MemorySemanticsAttr')(memory_semantics, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def execution_scope(self):
    return self.operation.attributes["execution_scope"]

  @execution_scope.setter
  def execution_scope(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["execution_scope"] = value

  @builtins.property
  def memory_scope(self):
    return self.operation.attributes["memory_scope"]

  @memory_scope.setter
  def memory_scope(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["memory_scope"] = value

  @builtins.property
  def memory_semantics(self):
    return self.operation.attributes["memory_semantics"]

  @memory_semantics.setter
  def memory_semantics(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["memory_semantics"] = value

def INTEL_ControlBarrierWait(execution_scope, memory_scope, memory_semantics, *, loc=None, ip=None) -> _ods_ir.Operation:
  return INTELControlBarrierWaitOp(execution_scope=execution_scope, memory_scope=memory_scope, memory_semantics=memory_semantics, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class INTELConvertBF16ToFOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.INTEL.ConvertBF16ToF"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def INTEL_ConvertBF16ToF(result, operand, *, loc=None, ip=None) -> _ods_ir.Value:
  return INTELConvertBF16ToFOp(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class INTELConvertFToBF16Op(_ods_ir.OpView):
  OPERATION_NAME = "spirv.INTEL.ConvertFToBF16"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def INTEL_ConvertFToBF16(result, operand, *, loc=None, ip=None) -> _ods_ir.Value:
  return INTELConvertFToBF16Op(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class INTELSubgroupBlockReadOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.INTEL.SubgroupBlockRead"

  _ODS_REGIONS = (0, True)

  def __init__(self, value, ptr, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(ptr)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(value)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def ptr(self):
    return self.operation.operands[0]

  @builtins.property
  def value(self):
    return self.operation.results[0]

def INTEL_SubgroupBlockRead(value, ptr, *, loc=None, ip=None) -> _ods_ir.Value:
  return INTELSubgroupBlockReadOp(value=value, ptr=ptr, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class INTELSubgroupBlockWriteOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.INTEL.SubgroupBlockWrite"

  _ODS_REGIONS = (0, True)

  def __init__(self, ptr, value, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(ptr)
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def ptr(self):
    return self.operation.operands[0]

  @builtins.property
  def value(self):
    return self.operation.operands[1]

def INTEL_SubgroupBlockWrite(ptr, value, *, loc=None, ip=None) -> _ods_ir.Operation:
  return INTELSubgroupBlockWriteOp(ptr=ptr, value=value, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class INotEqualOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.INotEqual"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand1, operand2, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand1)
    operands.append(operand2)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand1(self):
    return self.operation.operands[0]

  @builtins.property
  def operand2(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def INotEqual(operand1, operand2, *, loc=None, ip=None) -> _ods_ir.Value:
  return INotEqualOp(operand1=operand1, operand2=operand2, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ISubBorrowOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.ISubBorrow"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand1, operand2, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand1)
    operands.append(operand2)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand1(self):
    return self.operation.operands[0]

  @builtins.property
  def operand2(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def ISubBorrow(result, operand1, operand2, *, loc=None, ip=None) -> _ods_ir.Value:
  return ISubBorrowOp(result=result, operand1=operand1, operand2=operand2, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ISubOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.ISub"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand1, operand2, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand1)
    operands.append(operand2)
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand1(self):
    return self.operation.operands[0]

  @builtins.property
  def operand2(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def ISub(operand1, operand2, *, loc=None, ip=None) -> _ods_ir.Value:
  return ISubOp(operand1=operand1, operand2=operand2, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ImageDrefGatherOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.ImageDrefGather"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, sampled_image, coordinate, dref, operand_arguments, *, image_operands=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(sampled_image)
    operands.append(coordinate)
    operands.append(dref)
    operands.extend(_get_op_results_or_values(operand_arguments))
    _ods_context = _ods_get_default_loc_context(loc)
    if image_operands is not None: attributes["image_operands"] = (image_operands if (
        isinstance(image_operands, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('SPIRV_ImageOperandsAttr')) else
          _ods_ir.AttrBuilder.get('SPIRV_ImageOperandsAttr')(image_operands, context=_ods_context))
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sampled_image(self):
    return self.operation.operands[0]

  @builtins.property
  def coordinate(self):
    return self.operation.operands[1]

  @builtins.property
  def dref(self):
    return self.operation.operands[2]

  @builtins.property
  def operand_arguments(self):
    _ods_variadic_group_length = len(self.operation.operands) - 4 + 1
    return self.operation.operands[3:3 + _ods_variadic_group_length]

  @builtins.property
  def image_operands(self):
    if "image_operands" not in self.operation.attributes:
      return None
    return self.operation.attributes["image_operands"]

  @image_operands.setter
  def image_operands(self, value):
    if value is not None:
      self.operation.attributes["image_operands"] = value
    elif "image_operands" in self.operation.attributes:
      del self.operation.attributes["image_operands"]

  @image_operands.deleter
  def image_operands(self):
    del self.operation.attributes["image_operands"]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def ImageDrefGather(result, sampled_image, coordinate, dref, operand_arguments, *, image_operands=None, loc=None, ip=None) -> _ods_ir.Value:
  return ImageDrefGatherOp(result=result, sampled_image=sampled_image, coordinate=coordinate, dref=dref, operand_arguments=operand_arguments, image_operands=image_operands, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ImageOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.Image"

  _ODS_REGIONS = (0, True)

  def __init__(self, sampled_image, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(sampled_image)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sampled_image(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def Image(sampled_image, *, loc=None, ip=None) -> _ods_ir.Value:
  return ImageOp(sampled_image=sampled_image, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ImageQuerySizeOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.ImageQuerySize"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, image, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(image)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def image(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def ImageQuerySize(result, image, *, loc=None, ip=None) -> _ods_ir.Value:
  return ImageQuerySizeOp(result=result, image=image, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ImageSampleExplicitLodOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.ImageSampleExplicitLod"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, sampled_image, coordinate, image_operands, operand_arguments, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(sampled_image)
    operands.append(coordinate)
    operands.extend(_get_op_results_or_values(operand_arguments))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["image_operands"] = (image_operands if (
    isinstance(image_operands, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ImageOperandsAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ImageOperandsAttr')(image_operands, context=_ods_context))
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sampled_image(self):
    return self.operation.operands[0]

  @builtins.property
  def coordinate(self):
    return self.operation.operands[1]

  @builtins.property
  def operand_arguments(self):
    _ods_variadic_group_length = len(self.operation.operands) - 3 + 1
    return self.operation.operands[2:2 + _ods_variadic_group_length]

  @builtins.property
  def image_operands(self):
    return self.operation.attributes["image_operands"]

  @image_operands.setter
  def image_operands(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["image_operands"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def ImageSampleExplicitLod(result, sampled_image, coordinate, image_operands, operand_arguments, *, loc=None, ip=None) -> _ods_ir.Value:
  return ImageSampleExplicitLodOp(result=result, sampled_image=sampled_image, coordinate=coordinate, image_operands=image_operands, operand_arguments=operand_arguments, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ImageSampleImplicitLodOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.ImageSampleImplicitLod"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, sampled_image, coordinate, operand_arguments, *, image_operands=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(sampled_image)
    operands.append(coordinate)
    operands.extend(_get_op_results_or_values(operand_arguments))
    _ods_context = _ods_get_default_loc_context(loc)
    if image_operands is not None: attributes["image_operands"] = (image_operands if (
        isinstance(image_operands, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('SPIRV_ImageOperandsAttr')) else
          _ods_ir.AttrBuilder.get('SPIRV_ImageOperandsAttr')(image_operands, context=_ods_context))
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sampled_image(self):
    return self.operation.operands[0]

  @builtins.property
  def coordinate(self):
    return self.operation.operands[1]

  @builtins.property
  def operand_arguments(self):
    _ods_variadic_group_length = len(self.operation.operands) - 3 + 1
    return self.operation.operands[2:2 + _ods_variadic_group_length]

  @builtins.property
  def image_operands(self):
    if "image_operands" not in self.operation.attributes:
      return None
    return self.operation.attributes["image_operands"]

  @image_operands.setter
  def image_operands(self, value):
    if value is not None:
      self.operation.attributes["image_operands"] = value
    elif "image_operands" in self.operation.attributes:
      del self.operation.attributes["image_operands"]

  @image_operands.deleter
  def image_operands(self):
    del self.operation.attributes["image_operands"]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def ImageSampleImplicitLod(result, sampled_image, coordinate, operand_arguments, *, image_operands=None, loc=None, ip=None) -> _ods_ir.Value:
  return ImageSampleImplicitLodOp(result=result, sampled_image=sampled_image, coordinate=coordinate, operand_arguments=operand_arguments, image_operands=image_operands, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ImageSampleProjDrefImplicitLodOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.ImageSampleProjDrefImplicitLod"

  _ODS_REGIONS = (0, True)

  def __init__(self, sampled_image, coordinate, dref, operand_arguments, *, image_operands=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(sampled_image)
    operands.append(coordinate)
    operands.append(dref)
    operands.extend(_get_op_results_or_values(operand_arguments))
    _ods_context = _ods_get_default_loc_context(loc)
    if image_operands is not None: attributes["image_operands"] = (image_operands if (
        isinstance(image_operands, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('SPIRV_ImageOperandsAttr')) else
          _ods_ir.AttrBuilder.get('SPIRV_ImageOperandsAttr')(image_operands, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sampled_image(self):
    return self.operation.operands[0]

  @builtins.property
  def coordinate(self):
    return self.operation.operands[1]

  @builtins.property
  def dref(self):
    return self.operation.operands[2]

  @builtins.property
  def operand_arguments(self):
    _ods_variadic_group_length = len(self.operation.operands) - 4 + 1
    return self.operation.operands[3:3 + _ods_variadic_group_length]

  @builtins.property
  def image_operands(self):
    if "image_operands" not in self.operation.attributes:
      return None
    return self.operation.attributes["image_operands"]

  @image_operands.setter
  def image_operands(self, value):
    if value is not None:
      self.operation.attributes["image_operands"] = value
    elif "image_operands" in self.operation.attributes:
      del self.operation.attributes["image_operands"]

  @image_operands.deleter
  def image_operands(self):
    del self.operation.attributes["image_operands"]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def ImageSampleProjDrefImplicitLod(sampled_image, coordinate, dref, operand_arguments, *, image_operands=None, loc=None, ip=None) -> _ods_ir.Value:
  return ImageSampleProjDrefImplicitLodOp(sampled_image=sampled_image, coordinate=coordinate, dref=dref, operand_arguments=operand_arguments, image_operands=image_operands, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ImageWriteOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.ImageWrite"

  _ODS_REGIONS = (0, True)

  def __init__(self, image, coordinate, texel, operand_arguments, *, image_operands=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(image)
    operands.append(coordinate)
    operands.append(texel)
    operands.extend(_get_op_results_or_values(operand_arguments))
    _ods_context = _ods_get_default_loc_context(loc)
    if image_operands is not None: attributes["image_operands"] = (image_operands if (
        isinstance(image_operands, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('SPIRV_ImageOperandsAttr')) else
          _ods_ir.AttrBuilder.get('SPIRV_ImageOperandsAttr')(image_operands, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def image(self):
    return self.operation.operands[0]

  @builtins.property
  def coordinate(self):
    return self.operation.operands[1]

  @builtins.property
  def texel(self):
    return self.operation.operands[2]

  @builtins.property
  def operand_arguments(self):
    _ods_variadic_group_length = len(self.operation.operands) - 4 + 1
    return self.operation.operands[3:3 + _ods_variadic_group_length]

  @builtins.property
  def image_operands(self):
    if "image_operands" not in self.operation.attributes:
      return None
    return self.operation.attributes["image_operands"]

  @image_operands.setter
  def image_operands(self, value):
    if value is not None:
      self.operation.attributes["image_operands"] = value
    elif "image_operands" in self.operation.attributes:
      del self.operation.attributes["image_operands"]

  @image_operands.deleter
  def image_operands(self):
    del self.operation.attributes["image_operands"]

def ImageWrite(image, coordinate, texel, operand_arguments, *, image_operands=None, loc=None, ip=None) -> _ods_ir.Operation:
  return ImageWriteOp(image=image, coordinate=coordinate, texel=texel, operand_arguments=operand_arguments, image_operands=image_operands, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class InBoundsPtrAccessChainOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.InBoundsPtrAccessChain"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, base_ptr, element, indices, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(base_ptr)
    operands.append(element)
    operands.extend(_get_op_results_or_values(indices))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def base_ptr(self):
    return self.operation.operands[0]

  @builtins.property
  def element(self):
    return self.operation.operands[1]

  @builtins.property
  def indices(self):
    _ods_variadic_group_length = len(self.operation.operands) - 3 + 1
    return self.operation.operands[2:2 + _ods_variadic_group_length]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def InBoundsPtrAccessChain(result, base_ptr, element, indices, *, loc=None, ip=None) -> _ods_ir.Value:
  return InBoundsPtrAccessChainOp(result=result, base_ptr=base_ptr, element=element, indices=indices, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class IsInfOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.IsInf"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def IsInf(operand, *, loc=None, ip=None) -> _ods_ir.Value:
  return IsInfOp(operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class IsNanOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.IsNan"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def IsNan(operand, *, loc=None, ip=None) -> _ods_ir.Value:
  return IsNanOp(operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class KHRAssumeTrueOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.KHR.AssumeTrue"

  _ODS_REGIONS = (0, True)

  def __init__(self, condition, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(condition)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def condition(self):
    return self.operation.operands[0]

def KHR_AssumeTrue(condition, *, loc=None, ip=None) -> _ods_ir.Operation:
  return KHRAssumeTrueOp(condition=condition, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class KHRCooperativeMatrixLengthOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.KHR.CooperativeMatrixLength"

  _ODS_REGIONS = (0, True)

  def __init__(self, cooperative_matrix_type, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["cooperative_matrix_type"] = (cooperative_matrix_type if (
    isinstance(cooperative_matrix_type, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('anonymous_1619')) else
      _ods_ir.AttrBuilder.get('anonymous_1619')(cooperative_matrix_type, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def cooperative_matrix_type(self):
    return self.operation.attributes["cooperative_matrix_type"]

  @cooperative_matrix_type.setter
  def cooperative_matrix_type(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["cooperative_matrix_type"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def KHR_CooperativeMatrixLength(cooperative_matrix_type, *, loc=None, ip=None) -> _ods_ir.Value:
  return KHRCooperativeMatrixLengthOp(cooperative_matrix_type=cooperative_matrix_type, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class KHRCooperativeMatrixLoadOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.KHR.CooperativeMatrixLoad"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, pointer, matrix_layout, stride, *, memory_operand=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(pointer)
    operands.append(stride)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["matrix_layout"] = (matrix_layout if (
    isinstance(matrix_layout, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_KHR_CooperativeMatrixLayoutAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_KHR_CooperativeMatrixLayoutAttr')(matrix_layout, context=_ods_context))
    if memory_operand is not None: attributes["memory_operand"] = (memory_operand if (
        isinstance(memory_operand, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('SPIRV_MemoryAccessAttr')) else
          _ods_ir.AttrBuilder.get('SPIRV_MemoryAccessAttr')(memory_operand, context=_ods_context))
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def pointer(self):
    return self.operation.operands[0]

  @builtins.property
  def stride(self):
    return self.operation.operands[1]

  @builtins.property
  def matrix_layout(self):
    return self.operation.attributes["matrix_layout"]

  @matrix_layout.setter
  def matrix_layout(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["matrix_layout"] = value

  @builtins.property
  def memory_operand(self):
    if "memory_operand" not in self.operation.attributes:
      return None
    return self.operation.attributes["memory_operand"]

  @memory_operand.setter
  def memory_operand(self, value):
    if value is not None:
      self.operation.attributes["memory_operand"] = value
    elif "memory_operand" in self.operation.attributes:
      del self.operation.attributes["memory_operand"]

  @memory_operand.deleter
  def memory_operand(self):
    del self.operation.attributes["memory_operand"]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def KHR_CooperativeMatrixLoad(result, pointer, matrix_layout, stride, *, memory_operand=None, loc=None, ip=None) -> _ods_ir.Value:
  return KHRCooperativeMatrixLoadOp(result=result, pointer=pointer, matrix_layout=matrix_layout, stride=stride, memory_operand=memory_operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class KHRCooperativeMatrixMulAddOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.KHR.CooperativeMatrixMulAdd"

  _ODS_REGIONS = (0, True)

  def __init__(self, a, b, c, *, matrix_operands=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(a)
    operands.append(b)
    operands.append(c)
    _ods_context = _ods_get_default_loc_context(loc)
    if matrix_operands is not None: attributes["matrix_operands"] = (matrix_operands if (
        isinstance(matrix_operands, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('SPIRV_KHR_CooperativeMatrixOperandsAttr')) else
          _ods_ir.AttrBuilder.get('SPIRV_KHR_CooperativeMatrixOperandsAttr')(matrix_operands, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self):
    return self.operation.operands[0]

  @builtins.property
  def b(self):
    return self.operation.operands[1]

  @builtins.property
  def c(self):
    return self.operation.operands[2]

  @builtins.property
  def matrix_operands(self):
    if "matrix_operands" not in self.operation.attributes:
      return None
    return self.operation.attributes["matrix_operands"]

  @matrix_operands.setter
  def matrix_operands(self, value):
    if value is not None:
      self.operation.attributes["matrix_operands"] = value
    elif "matrix_operands" in self.operation.attributes:
      del self.operation.attributes["matrix_operands"]

  @matrix_operands.deleter
  def matrix_operands(self):
    del self.operation.attributes["matrix_operands"]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def KHR_CooperativeMatrixMulAdd(a, b, c, *, matrix_operands=None, loc=None, ip=None) -> _ods_ir.Value:
  return KHRCooperativeMatrixMulAddOp(a=a, b=b, c=c, matrix_operands=matrix_operands, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class KHRCooperativeMatrixStoreOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.KHR.CooperativeMatrixStore"

  _ODS_REGIONS = (0, True)

  def __init__(self, pointer, object, matrix_layout, stride, *, memory_operand=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(pointer)
    operands.append(object)
    operands.append(stride)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["matrix_layout"] = (matrix_layout if (
    isinstance(matrix_layout, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_KHR_CooperativeMatrixLayoutAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_KHR_CooperativeMatrixLayoutAttr')(matrix_layout, context=_ods_context))
    if memory_operand is not None: attributes["memory_operand"] = (memory_operand if (
        isinstance(memory_operand, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('SPIRV_MemoryAccessAttr')) else
          _ods_ir.AttrBuilder.get('SPIRV_MemoryAccessAttr')(memory_operand, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def pointer(self):
    return self.operation.operands[0]

  @builtins.property
  def object(self):
    return self.operation.operands[1]

  @builtins.property
  def stride(self):
    return self.operation.operands[2]

  @builtins.property
  def matrix_layout(self):
    return self.operation.attributes["matrix_layout"]

  @matrix_layout.setter
  def matrix_layout(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["matrix_layout"] = value

  @builtins.property
  def memory_operand(self):
    if "memory_operand" not in self.operation.attributes:
      return None
    return self.operation.attributes["memory_operand"]

  @memory_operand.setter
  def memory_operand(self, value):
    if value is not None:
      self.operation.attributes["memory_operand"] = value
    elif "memory_operand" in self.operation.attributes:
      del self.operation.attributes["memory_operand"]

  @memory_operand.deleter
  def memory_operand(self):
    del self.operation.attributes["memory_operand"]

def KHR_CooperativeMatrixStore(pointer, object, matrix_layout, stride, *, memory_operand=None, loc=None, ip=None) -> _ods_ir.Operation:
  return KHRCooperativeMatrixStoreOp(pointer=pointer, object=object, matrix_layout=matrix_layout, stride=stride, memory_operand=memory_operand, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class KHRSubgroupBallotOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.KHR.SubgroupBallot"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, predicate, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(predicate)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def predicate(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def KHR_SubgroupBallot(result, predicate, *, loc=None, ip=None) -> _ods_ir.Value:
  return KHRSubgroupBallotOp(result=result, predicate=predicate, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class KillOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.Kill"

  _ODS_REGIONS = (0, True)

  def __init__(self, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

def Kill(*, loc=None, ip=None) -> _ods_ir.Operation:
  return KillOp(loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class LoadOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.Load"

  _ODS_REGIONS = (0, True)

  def __init__(self, value, ptr, *, memory_access=None, alignment=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(ptr)
    _ods_context = _ods_get_default_loc_context(loc)
    if memory_access is not None: attributes["memory_access"] = (memory_access if (
        isinstance(memory_access, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('SPIRV_MemoryAccessAttr')) else
          _ods_ir.AttrBuilder.get('SPIRV_MemoryAccessAttr')(memory_access, context=_ods_context))
    if alignment is not None: attributes["alignment"] = (alignment if (
        isinstance(alignment, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I32Attr')) else
          _ods_ir.AttrBuilder.get('I32Attr')(alignment, context=_ods_context))
    results.append(value)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def ptr(self):
    return self.operation.operands[0]

  @builtins.property
  def memory_access(self):
    if "memory_access" not in self.operation.attributes:
      return None
    return self.operation.attributes["memory_access"]

  @memory_access.setter
  def memory_access(self, value):
    if value is not None:
      self.operation.attributes["memory_access"] = value
    elif "memory_access" in self.operation.attributes:
      del self.operation.attributes["memory_access"]

  @memory_access.deleter
  def memory_access(self):
    del self.operation.attributes["memory_access"]

  @builtins.property
  def alignment(self):
    if "alignment" not in self.operation.attributes:
      return None
    return self.operation.attributes["alignment"]

  @alignment.setter
  def alignment(self, value):
    if value is not None:
      self.operation.attributes["alignment"] = value
    elif "alignment" in self.operation.attributes:
      del self.operation.attributes["alignment"]

  @alignment.deleter
  def alignment(self):
    del self.operation.attributes["alignment"]

  @builtins.property
  def value(self):
    return self.operation.results[0]

def Load(value, ptr, *, memory_access=None, alignment=None, loc=None, ip=None) -> _ods_ir.Value:
  return LoadOp(value=value, ptr=ptr, memory_access=memory_access, alignment=alignment, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class LogicalAndOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.LogicalAnd"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand1, operand2, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand1)
    operands.append(operand2)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand1(self):
    return self.operation.operands[0]

  @builtins.property
  def operand2(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def LogicalAnd(operand1, operand2, *, loc=None, ip=None) -> _ods_ir.Value:
  return LogicalAndOp(operand1=operand1, operand2=operand2, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class LogicalEqualOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.LogicalEqual"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand1, operand2, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand1)
    operands.append(operand2)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand1(self):
    return self.operation.operands[0]

  @builtins.property
  def operand2(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def LogicalEqual(operand1, operand2, *, loc=None, ip=None) -> _ods_ir.Value:
  return LogicalEqualOp(operand1=operand1, operand2=operand2, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class LogicalNotEqualOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.LogicalNotEqual"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand1, operand2, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand1)
    operands.append(operand2)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand1(self):
    return self.operation.operands[0]

  @builtins.property
  def operand2(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def LogicalNotEqual(operand1, operand2, *, loc=None, ip=None) -> _ods_ir.Value:
  return LogicalNotEqualOp(operand1=operand1, operand2=operand2, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class LogicalNotOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.LogicalNot"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def LogicalNot(operand, *, loc=None, ip=None) -> _ods_ir.Value:
  return LogicalNotOp(operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class LogicalOrOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.LogicalOr"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand1, operand2, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand1)
    operands.append(operand2)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand1(self):
    return self.operation.operands[0]

  @builtins.property
  def operand2(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def LogicalOr(operand1, operand2, *, loc=None, ip=None) -> _ods_ir.Value:
  return LogicalOrOp(operand1=operand1, operand2=operand2, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class LoopOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.mlir.loop"

  _ODS_REGIONS = (1, True)

  def __init__(self, loop_control, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["loop_control"] = (loop_control if (
    isinstance(loop_control, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_LoopControlAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_LoopControlAttr')(loop_control, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def loop_control(self):
    return self.operation.attributes["loop_control"]

  @loop_control.setter
  def loop_control(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["loop_control"] = value

  @builtins.property
  def body(self):
    return self.regions[0]

def mlir_loop(loop_control, *, loc=None, ip=None) -> _ods_ir.Operation:
  return LoopOp(loop_control=loop_control, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class MatrixTimesMatrixOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.MatrixTimesMatrix"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, leftmatrix, rightmatrix, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(leftmatrix)
    operands.append(rightmatrix)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def leftmatrix(self):
    return self.operation.operands[0]

  @builtins.property
  def rightmatrix(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def MatrixTimesMatrix(result, leftmatrix, rightmatrix, *, loc=None, ip=None) -> _ods_ir.Value:
  return MatrixTimesMatrixOp(result=result, leftmatrix=leftmatrix, rightmatrix=rightmatrix, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MatrixTimesScalarOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.MatrixTimesScalar"

  _ODS_REGIONS = (0, True)

  def __init__(self, matrix, scalar, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(matrix)
    operands.append(scalar)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def matrix(self):
    return self.operation.operands[0]

  @builtins.property
  def scalar(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def MatrixTimesScalar(matrix, scalar, *, loc=None, ip=None) -> _ods_ir.Value:
  return MatrixTimesScalarOp(matrix=matrix, scalar=scalar, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MatrixTimesVectorOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.MatrixTimesVector"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, matrix, vector, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(matrix)
    operands.append(vector)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def matrix(self):
    return self.operation.operands[0]

  @builtins.property
  def vector(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def MatrixTimesVector(result, matrix, vector, *, loc=None, ip=None) -> _ods_ir.Value:
  return MatrixTimesVectorOp(result=result, matrix=matrix, vector=vector, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MemoryBarrierOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.MemoryBarrier"

  _ODS_REGIONS = (0, True)

  def __init__(self, memory_scope, memory_semantics, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["memory_scope"] = (memory_scope if (
    isinstance(memory_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(memory_scope, context=_ods_context))
    attributes["memory_semantics"] = (memory_semantics if (
    isinstance(memory_semantics, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_MemorySemanticsAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_MemorySemanticsAttr')(memory_semantics, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def memory_scope(self):
    return self.operation.attributes["memory_scope"]

  @memory_scope.setter
  def memory_scope(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["memory_scope"] = value

  @builtins.property
  def memory_semantics(self):
    return self.operation.attributes["memory_semantics"]

  @memory_semantics.setter
  def memory_semantics(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["memory_semantics"] = value

def MemoryBarrier(memory_scope, memory_semantics, *, loc=None, ip=None) -> _ods_ir.Operation:
  return MemoryBarrierOp(memory_scope=memory_scope, memory_semantics=memory_semantics, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class MergeOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.mlir.merge"

  _ODS_REGIONS = (0, True)

  def __init__(self, operands_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(operands_))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operands_(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

def mlir_merge(operands_, *, loc=None, ip=None) -> _ods_ir.Operation:
  return MergeOp(operands_=operands_, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ModuleOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.module"

  _ODS_REGIONS = (1, True)

  def __init__(self, addressing_model, memory_model, *, vce_triple=None, sym_name=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["addressing_model"] = (addressing_model if (
    isinstance(addressing_model, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_AddressingModelAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_AddressingModelAttr')(addressing_model, context=_ods_context))
    attributes["memory_model"] = (memory_model if (
    isinstance(memory_model, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_MemoryModelAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_MemoryModelAttr')(memory_model, context=_ods_context))
    if vce_triple is not None: attributes["vce_triple"] = (vce_triple if (
        isinstance(vce_triple, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('SPIRV_VerCapExtAttr')) else
          _ods_ir.AttrBuilder.get('SPIRV_VerCapExtAttr')(vce_triple, context=_ods_context))
    if sym_name is not None: attributes["sym_name"] = (sym_name if (
        isinstance(sym_name, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(sym_name, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def addressing_model(self):
    return self.operation.attributes["addressing_model"]

  @addressing_model.setter
  def addressing_model(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["addressing_model"] = value

  @builtins.property
  def memory_model(self):
    return self.operation.attributes["memory_model"]

  @memory_model.setter
  def memory_model(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["memory_model"] = value

  @builtins.property
  def vce_triple(self):
    if "vce_triple" not in self.operation.attributes:
      return None
    return self.operation.attributes["vce_triple"]

  @vce_triple.setter
  def vce_triple(self, value):
    if value is not None:
      self.operation.attributes["vce_triple"] = value
    elif "vce_triple" in self.operation.attributes:
      del self.operation.attributes["vce_triple"]

  @vce_triple.deleter
  def vce_triple(self):
    del self.operation.attributes["vce_triple"]

  @builtins.property
  def sym_name(self):
    if "sym_name" not in self.operation.attributes:
      return None
    return self.operation.attributes["sym_name"]

  @sym_name.setter
  def sym_name(self, value):
    if value is not None:
      self.operation.attributes["sym_name"] = value
    elif "sym_name" in self.operation.attributes:
      del self.operation.attributes["sym_name"]

  @sym_name.deleter
  def sym_name(self):
    del self.operation.attributes["sym_name"]

def module(addressing_model, memory_model, *, vce_triple=None, sym_name=None, loc=None, ip=None) -> _ods_ir.Operation:
  return ModuleOp(addressing_model=addressing_model, memory_model=memory_model, vce_triple=vce_triple, sym_name=sym_name, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class NotOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.Not"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def Not(operand, *, loc=None, ip=None) -> _ods_ir.Value:
  return NotOp(operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class OrderedOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.Ordered"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand1, operand2, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand1)
    operands.append(operand2)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand1(self):
    return self.operation.operands[0]

  @builtins.property
  def operand2(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def Ordered(operand1, operand2, *, loc=None, ip=None) -> _ods_ir.Value:
  return OrderedOp(operand1=operand1, operand2=operand2, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class PtrAccessChainOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.PtrAccessChain"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, base_ptr, element, indices, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(base_ptr)
    operands.append(element)
    operands.extend(_get_op_results_or_values(indices))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def base_ptr(self):
    return self.operation.operands[0]

  @builtins.property
  def element(self):
    return self.operation.operands[1]

  @builtins.property
  def indices(self):
    _ods_variadic_group_length = len(self.operation.operands) - 3 + 1
    return self.operation.operands[2:2 + _ods_variadic_group_length]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def PtrAccessChain(result, base_ptr, element, indices, *, loc=None, ip=None) -> _ods_ir.Value:
  return PtrAccessChainOp(result=result, base_ptr=base_ptr, element=element, indices=indices, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class PtrCastToGenericOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.PtrCastToGeneric"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, pointer, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(pointer)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def pointer(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def PtrCastToGeneric(result, pointer, *, loc=None, ip=None) -> _ods_ir.Value:
  return PtrCastToGenericOp(result=result, pointer=pointer, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ReferenceOfOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.mlir.referenceof"

  _ODS_REGIONS = (0, True)

  def __init__(self, reference, spec_const, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["spec_const"] = (spec_const if (
    isinstance(spec_const, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('FlatSymbolRefAttr')) else
      _ods_ir.AttrBuilder.get('FlatSymbolRefAttr')(spec_const, context=_ods_context))
    results.append(reference)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def spec_const(self):
    return self.operation.attributes["spec_const"]

  @spec_const.setter
  def spec_const(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["spec_const"] = value

  @builtins.property
  def reference(self):
    return self.operation.results[0]

def mlir_referenceof(reference, spec_const, *, loc=None, ip=None) -> _ods_ir.Value:
  return ReferenceOfOp(reference=reference, spec_const=spec_const, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ReturnOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.Return"

  _ODS_REGIONS = (0, True)

  def __init__(self, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

def Return(*, loc=None, ip=None) -> _ods_ir.Operation:
  return ReturnOp(loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ReturnValueOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.ReturnValue"

  _ODS_REGIONS = (0, True)

  def __init__(self, value, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self):
    return self.operation.operands[0]

def ReturnValue(value, *, loc=None, ip=None) -> _ods_ir.Operation:
  return ReturnValueOp(value=value, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class SConvertOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.SConvert"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def SConvert(result, operand, *, loc=None, ip=None) -> _ods_ir.Value:
  return SConvertOp(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SDivOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.SDiv"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand1, operand2, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand1)
    operands.append(operand2)
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand1(self):
    return self.operation.operands[0]

  @builtins.property
  def operand2(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def SDiv(operand1, operand2, *, loc=None, ip=None) -> _ods_ir.Value:
  return SDivOp(operand1=operand1, operand2=operand2, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SDotAccSatOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.SDotAccSat"

  _ODS_REGIONS = (0, True)

  def __init__(self, vector1, vector2, accumulator, *, format=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(vector1)
    operands.append(vector2)
    operands.append(accumulator)
    _ods_context = _ods_get_default_loc_context(loc)
    if format is not None: attributes["format"] = (format if (
        isinstance(format, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('SPIRV_PackedVectorFormatAttr')) else
          _ods_ir.AttrBuilder.get('SPIRV_PackedVectorFormatAttr')(format, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def vector1(self):
    return self.operation.operands[0]

  @builtins.property
  def vector2(self):
    return self.operation.operands[1]

  @builtins.property
  def accumulator(self):
    return self.operation.operands[2]

  @builtins.property
  def format(self):
    if "format" not in self.operation.attributes:
      return None
    return self.operation.attributes["format"]

  @format.setter
  def format(self, value):
    if value is not None:
      self.operation.attributes["format"] = value
    elif "format" in self.operation.attributes:
      del self.operation.attributes["format"]

  @format.deleter
  def format(self):
    del self.operation.attributes["format"]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def SDotAccSat(vector1, vector2, accumulator, *, format=None, loc=None, ip=None) -> _ods_ir.Value:
  return SDotAccSatOp(vector1=vector1, vector2=vector2, accumulator=accumulator, format=format, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SDotOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.SDot"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, vector1, vector2, *, format=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(vector1)
    operands.append(vector2)
    _ods_context = _ods_get_default_loc_context(loc)
    if format is not None: attributes["format"] = (format if (
        isinstance(format, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('SPIRV_PackedVectorFormatAttr')) else
          _ods_ir.AttrBuilder.get('SPIRV_PackedVectorFormatAttr')(format, context=_ods_context))
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def vector1(self):
    return self.operation.operands[0]

  @builtins.property
  def vector2(self):
    return self.operation.operands[1]

  @builtins.property
  def format(self):
    if "format" not in self.operation.attributes:
      return None
    return self.operation.attributes["format"]

  @format.setter
  def format(self, value):
    if value is not None:
      self.operation.attributes["format"] = value
    elif "format" in self.operation.attributes:
      del self.operation.attributes["format"]

  @format.deleter
  def format(self):
    del self.operation.attributes["format"]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def SDot(result, vector1, vector2, *, format=None, loc=None, ip=None) -> _ods_ir.Value:
  return SDotOp(result=result, vector1=vector1, vector2=vector2, format=format, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SGreaterThanEqualOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.SGreaterThanEqual"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand1, operand2, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand1)
    operands.append(operand2)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand1(self):
    return self.operation.operands[0]

  @builtins.property
  def operand2(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def SGreaterThanEqual(operand1, operand2, *, loc=None, ip=None) -> _ods_ir.Value:
  return SGreaterThanEqualOp(operand1=operand1, operand2=operand2, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SGreaterThanOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.SGreaterThan"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand1, operand2, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand1)
    operands.append(operand2)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand1(self):
    return self.operation.operands[0]

  @builtins.property
  def operand2(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def SGreaterThan(operand1, operand2, *, loc=None, ip=None) -> _ods_ir.Value:
  return SGreaterThanOp(operand1=operand1, operand2=operand2, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SLessThanEqualOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.SLessThanEqual"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand1, operand2, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand1)
    operands.append(operand2)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand1(self):
    return self.operation.operands[0]

  @builtins.property
  def operand2(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def SLessThanEqual(operand1, operand2, *, loc=None, ip=None) -> _ods_ir.Value:
  return SLessThanEqualOp(operand1=operand1, operand2=operand2, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SLessThanOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.SLessThan"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand1, operand2, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand1)
    operands.append(operand2)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand1(self):
    return self.operation.operands[0]

  @builtins.property
  def operand2(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def SLessThan(operand1, operand2, *, loc=None, ip=None) -> _ods_ir.Value:
  return SLessThanOp(operand1=operand1, operand2=operand2, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SModOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.SMod"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand1, operand2, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand1)
    operands.append(operand2)
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand1(self):
    return self.operation.operands[0]

  @builtins.property
  def operand2(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def SMod(operand1, operand2, *, loc=None, ip=None) -> _ods_ir.Value:
  return SModOp(operand1=operand1, operand2=operand2, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SMulExtendedOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.SMulExtended"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand1, operand2, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand1)
    operands.append(operand2)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand1(self):
    return self.operation.operands[0]

  @builtins.property
  def operand2(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def SMulExtended(result, operand1, operand2, *, loc=None, ip=None) -> _ods_ir.Value:
  return SMulExtendedOp(result=result, operand1=operand1, operand2=operand2, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SNegateOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.SNegate"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def SNegate(operand, *, loc=None, ip=None) -> _ods_ir.Value:
  return SNegateOp(operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SRemOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.SRem"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand1, operand2, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand1)
    operands.append(operand2)
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand1(self):
    return self.operation.operands[0]

  @builtins.property
  def operand2(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def SRem(operand1, operand2, *, loc=None, ip=None) -> _ods_ir.Value:
  return SRemOp(operand1=operand1, operand2=operand2, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SUDotAccSatOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.SUDotAccSat"

  _ODS_REGIONS = (0, True)

  def __init__(self, vector1, vector2, accumulator, *, format=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(vector1)
    operands.append(vector2)
    operands.append(accumulator)
    _ods_context = _ods_get_default_loc_context(loc)
    if format is not None: attributes["format"] = (format if (
        isinstance(format, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('SPIRV_PackedVectorFormatAttr')) else
          _ods_ir.AttrBuilder.get('SPIRV_PackedVectorFormatAttr')(format, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def vector1(self):
    return self.operation.operands[0]

  @builtins.property
  def vector2(self):
    return self.operation.operands[1]

  @builtins.property
  def accumulator(self):
    return self.operation.operands[2]

  @builtins.property
  def format(self):
    if "format" not in self.operation.attributes:
      return None
    return self.operation.attributes["format"]

  @format.setter
  def format(self, value):
    if value is not None:
      self.operation.attributes["format"] = value
    elif "format" in self.operation.attributes:
      del self.operation.attributes["format"]

  @format.deleter
  def format(self):
    del self.operation.attributes["format"]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def SUDotAccSat(vector1, vector2, accumulator, *, format=None, loc=None, ip=None) -> _ods_ir.Value:
  return SUDotAccSatOp(vector1=vector1, vector2=vector2, accumulator=accumulator, format=format, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SUDotOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.SUDot"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, vector1, vector2, *, format=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(vector1)
    operands.append(vector2)
    _ods_context = _ods_get_default_loc_context(loc)
    if format is not None: attributes["format"] = (format if (
        isinstance(format, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('SPIRV_PackedVectorFormatAttr')) else
          _ods_ir.AttrBuilder.get('SPIRV_PackedVectorFormatAttr')(format, context=_ods_context))
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def vector1(self):
    return self.operation.operands[0]

  @builtins.property
  def vector2(self):
    return self.operation.operands[1]

  @builtins.property
  def format(self):
    if "format" not in self.operation.attributes:
      return None
    return self.operation.attributes["format"]

  @format.setter
  def format(self, value):
    if value is not None:
      self.operation.attributes["format"] = value
    elif "format" in self.operation.attributes:
      del self.operation.attributes["format"]

  @format.deleter
  def format(self):
    del self.operation.attributes["format"]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def SUDot(result, vector1, vector2, *, format=None, loc=None, ip=None) -> _ods_ir.Value:
  return SUDotOp(result=result, vector1=vector1, vector2=vector2, format=format, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SelectOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.Select"

  _ODS_REGIONS = (0, True)

  def __init__(self, condition, true_value, false_value, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(condition)
    operands.append(true_value)
    operands.append(false_value)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def condition(self):
    return self.operation.operands[0]

  @builtins.property
  def true_value(self):
    return self.operation.operands[1]

  @builtins.property
  def false_value(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def Select(condition, true_value, false_value, *, loc=None, ip=None) -> _ods_ir.Value:
  return SelectOp(condition=condition, true_value=true_value, false_value=false_value, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SelectionOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.mlir.selection"

  _ODS_REGIONS = (1, True)

  def __init__(self, results_, selection_control, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["selection_control"] = (selection_control if (
    isinstance(selection_control, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_SelectionControlAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_SelectionControlAttr')(selection_control, context=_ods_context))
    results.extend(results_)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def selection_control(self):
    return self.operation.attributes["selection_control"]

  @selection_control.setter
  def selection_control(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["selection_control"] = value

  @builtins.property
  def results_(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def body(self):
    return self.regions[0]

def mlir_selection(results_, selection_control, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(SelectionOp(results_=results_, selection_control=selection_control, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class ShiftLeftLogicalOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.ShiftLeftLogical"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand1, operand2, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand1)
    operands.append(operand2)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand1(self):
    return self.operation.operands[0]

  @builtins.property
  def operand2(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def ShiftLeftLogical(operand1, operand2, *, loc=None, ip=None) -> _ods_ir.Value:
  return ShiftLeftLogicalOp(operand1=operand1, operand2=operand2, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ShiftRightArithmeticOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.ShiftRightArithmetic"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand1, operand2, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand1)
    operands.append(operand2)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand1(self):
    return self.operation.operands[0]

  @builtins.property
  def operand2(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def ShiftRightArithmetic(operand1, operand2, *, loc=None, ip=None) -> _ods_ir.Value:
  return ShiftRightArithmeticOp(operand1=operand1, operand2=operand2, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ShiftRightLogicalOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.ShiftRightLogical"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand1, operand2, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand1)
    operands.append(operand2)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand1(self):
    return self.operation.operands[0]

  @builtins.property
  def operand2(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def ShiftRightLogical(operand1, operand2, *, loc=None, ip=None) -> _ods_ir.Value:
  return ShiftRightLogicalOp(operand1=operand1, operand2=operand2, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SpecConstantCompositeOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.SpecConstantComposite"

  _ODS_REGIONS = (0, True)

  def __init__(self, type_, sym_name, constituents, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["type"] = (type_ if (
    isinstance(type_, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypeAttr')) else
      _ods_ir.AttrBuilder.get('TypeAttr')(type_, context=_ods_context))
    attributes["sym_name"] = (sym_name if (
    isinstance(sym_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(sym_name, context=_ods_context))
    attributes["constituents"] = (constituents if (
    isinstance(constituents, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolRefArrayAttr')) else
      _ods_ir.AttrBuilder.get('SymbolRefArrayAttr')(constituents, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def type_(self):
    return self.operation.attributes["type"]

  @type_.setter
  def type_(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["type"] = value

  @builtins.property
  def sym_name(self):
    return self.operation.attributes["sym_name"]

  @sym_name.setter
  def sym_name(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sym_name"] = value

  @builtins.property
  def constituents(self):
    return self.operation.attributes["constituents"]

  @constituents.setter
  def constituents(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["constituents"] = value

def SpecConstantComposite(type_, sym_name, constituents, *, loc=None, ip=None) -> _ods_ir.Operation:
  return SpecConstantCompositeOp(type_=type_, sym_name=sym_name, constituents=constituents, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class SpecConstantOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.SpecConstant"

  _ODS_REGIONS = (0, True)

  def __init__(self, sym_name, default_value, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["sym_name"] = (sym_name if (
    isinstance(sym_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(sym_name, context=_ods_context))
    attributes["default_value"] = (default_value if (
    isinstance(default_value, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypedAttrInterface')) else
      _ods_ir.AttrBuilder.get('TypedAttrInterface')(default_value, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sym_name(self):
    return self.operation.attributes["sym_name"]

  @sym_name.setter
  def sym_name(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sym_name"] = value

  @builtins.property
  def default_value(self):
    return self.operation.attributes["default_value"]

  @default_value.setter
  def default_value(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["default_value"] = value

def SpecConstant(sym_name, default_value, *, loc=None, ip=None) -> _ods_ir.Operation:
  return SpecConstantOp(sym_name=sym_name, default_value=default_value, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class SpecConstantOperationOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.SpecConstantOperation"

  _ODS_REGIONS = (1, True)

  def __init__(self, result, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def result(self):
    return self.operation.results[0]

  @builtins.property
  def body(self):
    return self.regions[0]

def SpecConstantOperation(result, *, loc=None, ip=None) -> _ods_ir.Value:
  return SpecConstantOperationOp(result=result, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class StoreOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.Store"

  _ODS_REGIONS = (0, True)

  def __init__(self, ptr, value, *, memory_access=None, alignment=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(ptr)
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    if memory_access is not None: attributes["memory_access"] = (memory_access if (
        isinstance(memory_access, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('SPIRV_MemoryAccessAttr')) else
          _ods_ir.AttrBuilder.get('SPIRV_MemoryAccessAttr')(memory_access, context=_ods_context))
    if alignment is not None: attributes["alignment"] = (alignment if (
        isinstance(alignment, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I32Attr')) else
          _ods_ir.AttrBuilder.get('I32Attr')(alignment, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def ptr(self):
    return self.operation.operands[0]

  @builtins.property
  def value(self):
    return self.operation.operands[1]

  @builtins.property
  def memory_access(self):
    if "memory_access" not in self.operation.attributes:
      return None
    return self.operation.attributes["memory_access"]

  @memory_access.setter
  def memory_access(self, value):
    if value is not None:
      self.operation.attributes["memory_access"] = value
    elif "memory_access" in self.operation.attributes:
      del self.operation.attributes["memory_access"]

  @memory_access.deleter
  def memory_access(self):
    del self.operation.attributes["memory_access"]

  @builtins.property
  def alignment(self):
    if "alignment" not in self.operation.attributes:
      return None
    return self.operation.attributes["alignment"]

  @alignment.setter
  def alignment(self, value):
    if value is not None:
      self.operation.attributes["alignment"] = value
    elif "alignment" in self.operation.attributes:
      del self.operation.attributes["alignment"]

  @alignment.deleter
  def alignment(self):
    del self.operation.attributes["alignment"]

def Store(ptr, value, *, memory_access=None, alignment=None, loc=None, ip=None) -> _ods_ir.Operation:
  return StoreOp(ptr=ptr, value=value, memory_access=memory_access, alignment=alignment, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class TransposeOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.Transpose"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, matrix, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(matrix)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def matrix(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def Transpose(result, matrix, *, loc=None, ip=None) -> _ods_ir.Value:
  return TransposeOp(result=result, matrix=matrix, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class UConvertOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.UConvert"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def UConvert(result, operand, *, loc=None, ip=None) -> _ods_ir.Value:
  return UConvertOp(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class UDivOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.UDiv"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand1, operand2, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand1)
    operands.append(operand2)
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand1(self):
    return self.operation.operands[0]

  @builtins.property
  def operand2(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def UDiv(operand1, operand2, *, loc=None, ip=None) -> _ods_ir.Value:
  return UDivOp(operand1=operand1, operand2=operand2, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class UDotAccSatOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.UDotAccSat"

  _ODS_REGIONS = (0, True)

  def __init__(self, vector1, vector2, accumulator, *, format=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(vector1)
    operands.append(vector2)
    operands.append(accumulator)
    _ods_context = _ods_get_default_loc_context(loc)
    if format is not None: attributes["format"] = (format if (
        isinstance(format, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('SPIRV_PackedVectorFormatAttr')) else
          _ods_ir.AttrBuilder.get('SPIRV_PackedVectorFormatAttr')(format, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def vector1(self):
    return self.operation.operands[0]

  @builtins.property
  def vector2(self):
    return self.operation.operands[1]

  @builtins.property
  def accumulator(self):
    return self.operation.operands[2]

  @builtins.property
  def format(self):
    if "format" not in self.operation.attributes:
      return None
    return self.operation.attributes["format"]

  @format.setter
  def format(self, value):
    if value is not None:
      self.operation.attributes["format"] = value
    elif "format" in self.operation.attributes:
      del self.operation.attributes["format"]

  @format.deleter
  def format(self):
    del self.operation.attributes["format"]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def UDotAccSat(vector1, vector2, accumulator, *, format=None, loc=None, ip=None) -> _ods_ir.Value:
  return UDotAccSatOp(vector1=vector1, vector2=vector2, accumulator=accumulator, format=format, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class UDotOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.UDot"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, vector1, vector2, *, format=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(vector1)
    operands.append(vector2)
    _ods_context = _ods_get_default_loc_context(loc)
    if format is not None: attributes["format"] = (format if (
        isinstance(format, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('SPIRV_PackedVectorFormatAttr')) else
          _ods_ir.AttrBuilder.get('SPIRV_PackedVectorFormatAttr')(format, context=_ods_context))
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def vector1(self):
    return self.operation.operands[0]

  @builtins.property
  def vector2(self):
    return self.operation.operands[1]

  @builtins.property
  def format(self):
    if "format" not in self.operation.attributes:
      return None
    return self.operation.attributes["format"]

  @format.setter
  def format(self, value):
    if value is not None:
      self.operation.attributes["format"] = value
    elif "format" in self.operation.attributes:
      del self.operation.attributes["format"]

  @format.deleter
  def format(self):
    del self.operation.attributes["format"]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def UDot(result, vector1, vector2, *, format=None, loc=None, ip=None) -> _ods_ir.Value:
  return UDotOp(result=result, vector1=vector1, vector2=vector2, format=format, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class UGreaterThanEqualOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.UGreaterThanEqual"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand1, operand2, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand1)
    operands.append(operand2)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand1(self):
    return self.operation.operands[0]

  @builtins.property
  def operand2(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def UGreaterThanEqual(operand1, operand2, *, loc=None, ip=None) -> _ods_ir.Value:
  return UGreaterThanEqualOp(operand1=operand1, operand2=operand2, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class UGreaterThanOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.UGreaterThan"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand1, operand2, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand1)
    operands.append(operand2)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand1(self):
    return self.operation.operands[0]

  @builtins.property
  def operand2(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def UGreaterThan(operand1, operand2, *, loc=None, ip=None) -> _ods_ir.Value:
  return UGreaterThanOp(operand1=operand1, operand2=operand2, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ULessThanEqualOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.ULessThanEqual"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand1, operand2, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand1)
    operands.append(operand2)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand1(self):
    return self.operation.operands[0]

  @builtins.property
  def operand2(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def ULessThanEqual(operand1, operand2, *, loc=None, ip=None) -> _ods_ir.Value:
  return ULessThanEqualOp(operand1=operand1, operand2=operand2, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ULessThanOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.ULessThan"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand1, operand2, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand1)
    operands.append(operand2)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand1(self):
    return self.operation.operands[0]

  @builtins.property
  def operand2(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def ULessThan(operand1, operand2, *, loc=None, ip=None) -> _ods_ir.Value:
  return ULessThanOp(operand1=operand1, operand2=operand2, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class UModOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.UMod"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand1, operand2, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand1)
    operands.append(operand2)
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand1(self):
    return self.operation.operands[0]

  @builtins.property
  def operand2(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def UMod(operand1, operand2, *, loc=None, ip=None) -> _ods_ir.Value:
  return UModOp(operand1=operand1, operand2=operand2, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class UMulExtendedOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.UMulExtended"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand1, operand2, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand1)
    operands.append(operand2)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand1(self):
    return self.operation.operands[0]

  @builtins.property
  def operand2(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def UMulExtended(result, operand1, operand2, *, loc=None, ip=None) -> _ods_ir.Value:
  return UMulExtendedOp(result=result, operand1=operand1, operand2=operand2, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class UndefOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.Undef"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def result(self):
    return self.operation.results[0]

def Undef(result, *, loc=None, ip=None) -> _ods_ir.Value:
  return UndefOp(result=result, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class UnorderedOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.Unordered"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand1, operand2, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand1)
    operands.append(operand2)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand1(self):
    return self.operation.operands[0]

  @builtins.property
  def operand2(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def Unordered(operand1, operand2, *, loc=None, ip=None) -> _ods_ir.Value:
  return UnorderedOp(operand1=operand1, operand2=operand2, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class UnreachableOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.Unreachable"

  _ODS_REGIONS = (0, True)

  def __init__(self, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

def Unreachable(*, loc=None, ip=None) -> _ods_ir.Operation:
  return UnreachableOp(loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class VariableOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.Variable"

  _ODS_REGIONS = (0, True)

  def __init__(self, pointer, storage_class, *, initializer=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    if initializer is not None: operands.append(initializer)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["storage_class"] = (storage_class if (
    isinstance(storage_class, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_StorageClassAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_StorageClassAttr')(storage_class, context=_ods_context))
    results.append(pointer)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def initializer(self):
    return None if len(self.operation.operands) < 1 else self.operation.operands[0]

  @builtins.property
  def storage_class(self):
    return self.operation.attributes["storage_class"]

  @storage_class.setter
  def storage_class(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["storage_class"] = value

  @builtins.property
  def pointer(self):
    return self.operation.results[0]

def Variable(pointer, storage_class, *, initializer=None, loc=None, ip=None) -> _ods_ir.Value:
  return VariableOp(pointer=pointer, storage_class=storage_class, initializer=initializer, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class VectorExtractDynamicOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.VectorExtractDynamic"

  _ODS_REGIONS = (0, True)

  def __init__(self, vector, index, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(vector)
    operands.append(index)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def vector(self):
    return self.operation.operands[0]

  @builtins.property
  def index(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def VectorExtractDynamic(vector, index, *, loc=None, ip=None) -> _ods_ir.Value:
  return VectorExtractDynamicOp(vector=vector, index=index, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class VectorInsertDynamicOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.VectorInsertDynamic"

  _ODS_REGIONS = (0, True)

  def __init__(self, vector, component, index, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(vector)
    operands.append(component)
    operands.append(index)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def vector(self):
    return self.operation.operands[0]

  @builtins.property
  def component(self):
    return self.operation.operands[1]

  @builtins.property
  def index(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def VectorInsertDynamic(vector, component, index, *, loc=None, ip=None) -> _ods_ir.Value:
  return VectorInsertDynamicOp(vector=vector, component=component, index=index, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class VectorShuffleOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.VectorShuffle"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, vector1, vector2, components, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(vector1)
    operands.append(vector2)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["components"] = (components if (
    isinstance(components, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I32ArrayAttr')(components, context=_ods_context))
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def vector1(self):
    return self.operation.operands[0]

  @builtins.property
  def vector2(self):
    return self.operation.operands[1]

  @builtins.property
  def components(self):
    return self.operation.attributes["components"]

  @components.setter
  def components(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["components"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def VectorShuffle(result, vector1, vector2, components, *, loc=None, ip=None) -> _ods_ir.Value:
  return VectorShuffleOp(result=result, vector1=vector1, vector2=vector2, components=components, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class VectorTimesMatrixOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.VectorTimesMatrix"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, vector, matrix, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(vector)
    operands.append(matrix)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def vector(self):
    return self.operation.operands[0]

  @builtins.property
  def matrix(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def VectorTimesMatrix(result, vector, matrix, *, loc=None, ip=None) -> _ods_ir.Value:
  return VectorTimesMatrixOp(result=result, vector=vector, matrix=matrix, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class VectorTimesScalarOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.VectorTimesScalar"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, vector, scalar, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(vector)
    operands.append(scalar)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def vector(self):
    return self.operation.operands[0]

  @builtins.property
  def scalar(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def VectorTimesScalar(result, vector, scalar, *, loc=None, ip=None) -> _ods_ir.Value:
  return VectorTimesScalarOp(result=result, vector=vector, scalar=scalar, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class YieldOp(_ods_ir.OpView):
  OPERATION_NAME = "spirv.mlir.yield"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

def mlir_yield(operand, *, loc=None, ip=None) -> _ods_ir.Operation:
  return YieldOp(operand=operand, loc=loc, ip=ip)
