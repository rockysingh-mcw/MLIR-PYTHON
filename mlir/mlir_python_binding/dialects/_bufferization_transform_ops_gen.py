
# Autogenerated by mlir-tblgen; don't manually edit.

from ._ods_common import _cext as _ods_cext
from ._ods_common import (
    equally_sized_accessor as _ods_equally_sized_accessor,
    get_default_loc_context as _ods_get_default_loc_context,
    get_op_result_or_op_results as _get_op_result_or_op_results,
    get_op_results_or_values as _get_op_results_or_values,
    segmented_accessor as _ods_segmented_accessor,
)
_ods_ir = _ods_cext.ir

import builtins
from typing import Sequence as _Sequence, Union as _Union


from ._transform_ops_gen import _Dialect

@_ods_cext.register_operation(_Dialect)
class BufferLoopHoistingOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.bufferization.buffer_loop_hoisting"

  _ODS_REGIONS = (0, True)

  def __init__(self, target, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(target)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self):
    return self.operation.operands[0]

def bufferization_buffer_loop_hoisting(target, *, loc=None, ip=None) -> _ods_ir.Operation:
  return BufferLoopHoistingOp(target=target, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class EliminateEmptyTensorsOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.bufferization.eliminate_empty_tensors"

  _ODS_REGIONS = (0, True)

  def __init__(self, target, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(target)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self):
    return self.operation.operands[0]

def bufferization_eliminate_empty_tensors(target, *, loc=None, ip=None) -> _ods_ir.Operation:
  return EliminateEmptyTensorsOp(target=target, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class EmptyTensorToAllocTensorOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.bufferization.empty_tensor_to_alloc_tensor"

  _ODS_REGIONS = (0, True)

  def __init__(self, transformed, target, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(target)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(transformed)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def transformed(self):
    return self.operation.results[0]

def bufferization_empty_tensor_to_alloc_tensor(transformed, target, *, loc=None, ip=None) -> _ods_ir.Value:
  return EmptyTensorToAllocTensorOp(transformed=transformed, target=target, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class OneShotBufferizeOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.bufferization.one_shot_bufferize"

  _ODS_REGIONS = (0, True)

  def __init__(self, transformed, target, *, function_boundary_type_conversion=None, allow_return_allocs_from_loops=None, allow_unknown_ops=None, bufferize_function_boundaries=None, dump_alias_sets=None, test_analysis_only=None, print_conflicts=None, check_parallel_regions=None, memcpy_op=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(target)
    _ods_context = _ods_get_default_loc_context(loc)
    if function_boundary_type_conversion is not None: attributes["function_boundary_type_conversion"] = (function_boundary_type_conversion if (
        isinstance(function_boundary_type_conversion, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LayoutMapOption')) else
          _ods_ir.AttrBuilder.get('LayoutMapOption')(function_boundary_type_conversion, context=_ods_context))
    if allow_return_allocs_from_loops is not None: attributes["allow_return_allocs_from_loops"] = (allow_return_allocs_from_loops if (
        isinstance(allow_return_allocs_from_loops, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(allow_return_allocs_from_loops, context=_ods_context))
    if allow_unknown_ops is not None: attributes["allow_unknown_ops"] = (allow_unknown_ops if (
        isinstance(allow_unknown_ops, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(allow_unknown_ops, context=_ods_context))
    if bufferize_function_boundaries is not None: attributes["bufferize_function_boundaries"] = (bufferize_function_boundaries if (
        isinstance(bufferize_function_boundaries, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(bufferize_function_boundaries, context=_ods_context))
    if dump_alias_sets is not None: attributes["dump_alias_sets"] = (dump_alias_sets if (
        isinstance(dump_alias_sets, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(dump_alias_sets, context=_ods_context))
    if test_analysis_only is not None: attributes["test_analysis_only"] = (test_analysis_only if (
        isinstance(test_analysis_only, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(test_analysis_only, context=_ods_context))
    if print_conflicts is not None: attributes["print_conflicts"] = (print_conflicts if (
        isinstance(print_conflicts, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(print_conflicts, context=_ods_context))
    if check_parallel_regions is not None: attributes["check_parallel_regions"] = (check_parallel_regions if (
        isinstance(check_parallel_regions, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(check_parallel_regions, context=_ods_context))
    if memcpy_op is not None: attributes["memcpy_op"] = (memcpy_op if (
        isinstance(memcpy_op, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(memcpy_op, context=_ods_context))
    results.append(transformed)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def function_boundary_type_conversion(self):
    if "function_boundary_type_conversion" not in self.operation.attributes:
      return None
    return self.operation.attributes["function_boundary_type_conversion"]

  @function_boundary_type_conversion.setter
  def function_boundary_type_conversion(self, value):
    if value is not None:
      self.operation.attributes["function_boundary_type_conversion"] = value
    elif "function_boundary_type_conversion" in self.operation.attributes:
      del self.operation.attributes["function_boundary_type_conversion"]

  @function_boundary_type_conversion.deleter
  def function_boundary_type_conversion(self):
    del self.operation.attributes["function_boundary_type_conversion"]

  @builtins.property
  def allow_return_allocs_from_loops(self):
    return self.operation.attributes["allow_return_allocs_from_loops"]

  @allow_return_allocs_from_loops.setter
  def allow_return_allocs_from_loops(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["allow_return_allocs_from_loops"] = value

  @builtins.property
  def allow_unknown_ops(self):
    return self.operation.attributes["allow_unknown_ops"]

  @allow_unknown_ops.setter
  def allow_unknown_ops(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["allow_unknown_ops"] = value

  @builtins.property
  def bufferize_function_boundaries(self):
    return self.operation.attributes["bufferize_function_boundaries"]

  @bufferize_function_boundaries.setter
  def bufferize_function_boundaries(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["bufferize_function_boundaries"] = value

  @builtins.property
  def dump_alias_sets(self):
    return self.operation.attributes["dump_alias_sets"]

  @dump_alias_sets.setter
  def dump_alias_sets(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dump_alias_sets"] = value

  @builtins.property
  def test_analysis_only(self):
    return self.operation.attributes["test_analysis_only"]

  @test_analysis_only.setter
  def test_analysis_only(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["test_analysis_only"] = value

  @builtins.property
  def print_conflicts(self):
    return self.operation.attributes["print_conflicts"]

  @print_conflicts.setter
  def print_conflicts(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["print_conflicts"] = value

  @builtins.property
  def check_parallel_regions(self):
    return self.operation.attributes["check_parallel_regions"]

  @check_parallel_regions.setter
  def check_parallel_regions(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["check_parallel_regions"] = value

  @builtins.property
  def memcpy_op(self):
    return self.operation.attributes["memcpy_op"]

  @memcpy_op.setter
  def memcpy_op(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["memcpy_op"] = value

  @builtins.property
  def transformed(self):
    return self.operation.results[0]

def bufferization_one_shot_bufferize(transformed, target, *, function_boundary_type_conversion=None, allow_return_allocs_from_loops=None, allow_unknown_ops=None, bufferize_function_boundaries=None, dump_alias_sets=None, test_analysis_only=None, print_conflicts=None, check_parallel_regions=None, memcpy_op=None, loc=None, ip=None) -> _ods_ir.Value:
  return OneShotBufferizeOp(transformed=transformed, target=target, function_boundary_type_conversion=function_boundary_type_conversion, allow_return_allocs_from_loops=allow_return_allocs_from_loops, allow_unknown_ops=allow_unknown_ops, bufferize_function_boundaries=bufferize_function_boundaries, dump_alias_sets=dump_alias_sets, test_analysis_only=test_analysis_only, print_conflicts=print_conflicts, check_parallel_regions=check_parallel_regions, memcpy_op=memcpy_op, loc=loc, ip=ip).result
