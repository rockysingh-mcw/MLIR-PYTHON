
# Autogenerated by mlir-tblgen; don't manually edit.

from ._ods_common import _cext as _ods_cext
from ._ods_common import (
    equally_sized_accessor as _ods_equally_sized_accessor,
    get_default_loc_context as _ods_get_default_loc_context,
    get_op_result_or_op_results as _get_op_result_or_op_results,
    get_op_results_or_values as _get_op_results_or_values,
    segmented_accessor as _ods_segmented_accessor,
)
_ods_ir = _ods_cext.ir

import builtins
from typing import Sequence as _Sequence, Union as _Union


@_ods_cext.register_dialect
class _Dialect(_ods_ir.Dialect):
  DIALECT_NAMESPACE = "transform"

@_ods_cext.register_operation(_Dialect)
class AlternativesOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.alternatives"

  _ODS_REGIONS = (0, False)

  def __init__(self, results_, num_alternatives, *, scope=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    if scope is not None: operands.append(scope)
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend(results_)
    _ods_successors = None
    regions = 0 + num_alternatives
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def scope(self):
    return None if len(self.operation.operands) < 1 else self.operation.operands[0]

  @builtins.property
  def results_(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def alternatives(self):
    return self.regions[0:]

def alternatives(results_, num_alternatives, *, scope=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(AlternativesOp(results_=results_, num_alternatives=num_alternatives, scope=scope, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class AnnotateOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.annotate"

  _ODS_REGIONS = (0, True)

  def __init__(self, target, name, *, param=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(target)
    if param is not None: operands.append(param)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["name"] = (name if (
    isinstance(name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(name, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def param(self):
    return None if len(self.operation.operands) < 2 else self.operation.operands[1]

  @builtins.property
  def name(self):
    return self.operation.attributes["name"]

  @name.setter
  def name(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["name"] = value

def annotate(target, name, *, param=None, loc=None, ip=None) -> _ods_ir.Operation:
  return AnnotateOp(target=target, name=name, param=param, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ApplyCanonicalizationPatternsOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.apply_patterns.canonicalization"

  _ODS_REGIONS = (0, True)

  def __init__(self, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

def apply_patterns_canonicalization(*, loc=None, ip=None) -> _ods_ir.Operation:
  return ApplyCanonicalizationPatternsOp(loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ApplyCommonSubexpressionEliminationOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.apply_cse"

  _ODS_REGIONS = (0, True)

  def __init__(self, target, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(target)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self):
    return self.operation.operands[0]

def apply_cse(target, *, loc=None, ip=None) -> _ods_ir.Operation:
  return ApplyCommonSubexpressionEliminationOp(target=target, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ApplyConversionPatternsOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.apply_conversion_patterns"

  _ODS_REGIONS = (1, False)

  def __init__(self, target, num_default_type_converter_region, *, legal_ops=None, illegal_ops=None, legal_dialects=None, illegal_dialects=None, partial_conversion=None, preserve_handles=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(target)
    _ods_context = _ods_get_default_loc_context(loc)
    if legal_ops is not None: attributes["legal_ops"] = (legal_ops if (
        isinstance(legal_ops, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrArrayAttr')) else
          _ods_ir.AttrBuilder.get('StrArrayAttr')(legal_ops, context=_ods_context))
    if illegal_ops is not None: attributes["illegal_ops"] = (illegal_ops if (
        isinstance(illegal_ops, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrArrayAttr')) else
          _ods_ir.AttrBuilder.get('StrArrayAttr')(illegal_ops, context=_ods_context))
    if legal_dialects is not None: attributes["legal_dialects"] = (legal_dialects if (
        isinstance(legal_dialects, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrArrayAttr')) else
          _ods_ir.AttrBuilder.get('StrArrayAttr')(legal_dialects, context=_ods_context))
    if illegal_dialects is not None: attributes["illegal_dialects"] = (illegal_dialects if (
        isinstance(illegal_dialects, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrArrayAttr')) else
          _ods_ir.AttrBuilder.get('StrArrayAttr')(illegal_dialects, context=_ods_context))
    if bool(partial_conversion): attributes["partial_conversion"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    if bool(preserve_handles): attributes["preserve_handles"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    _ods_successors = None
    regions = 1 + num_default_type_converter_region
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def legal_ops(self):
    if "legal_ops" not in self.operation.attributes:
      return None
    return self.operation.attributes["legal_ops"]

  @legal_ops.setter
  def legal_ops(self, value):
    if value is not None:
      self.operation.attributes["legal_ops"] = value
    elif "legal_ops" in self.operation.attributes:
      del self.operation.attributes["legal_ops"]

  @legal_ops.deleter
  def legal_ops(self):
    del self.operation.attributes["legal_ops"]

  @builtins.property
  def illegal_ops(self):
    if "illegal_ops" not in self.operation.attributes:
      return None
    return self.operation.attributes["illegal_ops"]

  @illegal_ops.setter
  def illegal_ops(self, value):
    if value is not None:
      self.operation.attributes["illegal_ops"] = value
    elif "illegal_ops" in self.operation.attributes:
      del self.operation.attributes["illegal_ops"]

  @illegal_ops.deleter
  def illegal_ops(self):
    del self.operation.attributes["illegal_ops"]

  @builtins.property
  def legal_dialects(self):
    if "legal_dialects" not in self.operation.attributes:
      return None
    return self.operation.attributes["legal_dialects"]

  @legal_dialects.setter
  def legal_dialects(self, value):
    if value is not None:
      self.operation.attributes["legal_dialects"] = value
    elif "legal_dialects" in self.operation.attributes:
      del self.operation.attributes["legal_dialects"]

  @legal_dialects.deleter
  def legal_dialects(self):
    del self.operation.attributes["legal_dialects"]

  @builtins.property
  def illegal_dialects(self):
    if "illegal_dialects" not in self.operation.attributes:
      return None
    return self.operation.attributes["illegal_dialects"]

  @illegal_dialects.setter
  def illegal_dialects(self, value):
    if value is not None:
      self.operation.attributes["illegal_dialects"] = value
    elif "illegal_dialects" in self.operation.attributes:
      del self.operation.attributes["illegal_dialects"]

  @illegal_dialects.deleter
  def illegal_dialects(self):
    del self.operation.attributes["illegal_dialects"]

  @builtins.property
  def partial_conversion(self):
    return "partial_conversion" in self.operation.attributes

  @partial_conversion.setter
  def partial_conversion(self, value):
    if bool(value):
      self.operation.attributes["partial_conversion"] = _ods_ir.UnitAttr.get()
    elif "partial_conversion" in self.operation.attributes:
      del self.operation.attributes["partial_conversion"]

  @partial_conversion.deleter
  def partial_conversion(self):
    del self.operation.attributes["partial_conversion"]

  @builtins.property
  def preserve_handles(self):
    return "preserve_handles" in self.operation.attributes

  @preserve_handles.setter
  def preserve_handles(self, value):
    if bool(value):
      self.operation.attributes["preserve_handles"] = _ods_ir.UnitAttr.get()
    elif "preserve_handles" in self.operation.attributes:
      del self.operation.attributes["preserve_handles"]

  @preserve_handles.deleter
  def preserve_handles(self):
    del self.operation.attributes["preserve_handles"]

  @builtins.property
  def patterns(self):
    return self.regions[0]

  @builtins.property
  def default_type_converter_region(self):
    return self.regions[1:]

def apply_conversion_patterns(target, num_default_type_converter_region, *, legal_ops=None, illegal_ops=None, legal_dialects=None, illegal_dialects=None, partial_conversion=None, preserve_handles=None, loc=None, ip=None) -> _ods_ir.Operation:
  return ApplyConversionPatternsOp(target=target, num_default_type_converter_region=num_default_type_converter_region, legal_ops=legal_ops, illegal_ops=illegal_ops, legal_dialects=legal_dialects, illegal_dialects=illegal_dialects, partial_conversion=partial_conversion, preserve_handles=preserve_handles, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ApplyDeadCodeEliminationOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.apply_dce"

  _ODS_REGIONS = (0, True)

  def __init__(self, target, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(target)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self):
    return self.operation.operands[0]

def apply_dce(target, *, loc=None, ip=None) -> _ods_ir.Operation:
  return ApplyDeadCodeEliminationOp(target=target, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ApplyLoopInvariantCodeMotionOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.apply_licm"

  _ODS_REGIONS = (0, True)

  def __init__(self, target, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(target)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self):
    return self.operation.operands[0]

def apply_licm(target, *, loc=None, ip=None) -> _ods_ir.Operation:
  return ApplyLoopInvariantCodeMotionOp(target=target, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ApplyPatternsOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.apply_patterns"

  _ODS_REGIONS = (1, True)

  def __init__(self, target, *, apply_cse=None, max_iterations=None, max_num_rewrites=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(target)
    _ods_context = _ods_get_default_loc_context(loc)
    if bool(apply_cse): attributes["apply_cse"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    if max_iterations is not None: attributes["max_iterations"] = (max_iterations if (
        isinstance(max_iterations, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(max_iterations, context=_ods_context))
    if max_num_rewrites is not None: attributes["max_num_rewrites"] = (max_num_rewrites if (
        isinstance(max_num_rewrites, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(max_num_rewrites, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def apply_cse(self):
    return "apply_cse" in self.operation.attributes

  @apply_cse.setter
  def apply_cse(self, value):
    if bool(value):
      self.operation.attributes["apply_cse"] = _ods_ir.UnitAttr.get()
    elif "apply_cse" in self.operation.attributes:
      del self.operation.attributes["apply_cse"]

  @apply_cse.deleter
  def apply_cse(self):
    del self.operation.attributes["apply_cse"]

  @builtins.property
  def max_iterations(self):
    return self.operation.attributes["max_iterations"]

  @max_iterations.setter
  def max_iterations(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["max_iterations"] = value

  @builtins.property
  def max_num_rewrites(self):
    return self.operation.attributes["max_num_rewrites"]

  @max_num_rewrites.setter
  def max_num_rewrites(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["max_num_rewrites"] = value

  @builtins.property
  def patterns(self):
    return self.regions[0]

def apply_patterns(target, *, apply_cse=None, max_iterations=None, max_num_rewrites=None, loc=None, ip=None) -> _ods_ir.Operation:
  return ApplyPatternsOp(target=target, apply_cse=apply_cse, max_iterations=max_iterations, max_num_rewrites=max_num_rewrites, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ApplyRegisteredPassOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.apply_registered_pass"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, target, pass_name, *, options=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(target)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["pass_name"] = (pass_name if (
    isinstance(pass_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(pass_name, context=_ods_context))
    if options is not None: attributes["options"] = (options if (
        isinstance(options, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(options, context=_ods_context))
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def pass_name(self):
    return self.operation.attributes["pass_name"]

  @pass_name.setter
  def pass_name(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["pass_name"] = value

  @builtins.property
  def options(self):
    return self.operation.attributes["options"]

  @options.setter
  def options(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["options"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def apply_registered_pass(result, target, pass_name, *, options=None, loc=None, ip=None) -> _ods_ir.Value:
  return ApplyRegisteredPassOp(result=result, target=target, pass_name=pass_name, options=options, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ApplyToLLVMConversionPatternsOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.apply_conversion_patterns.dialect_to_llvm"

  _ODS_REGIONS = (0, True)

  def __init__(self, dialect_name, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dialect_name"] = (dialect_name if (
    isinstance(dialect_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(dialect_name, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def dialect_name(self):
    return self.operation.attributes["dialect_name"]

  @dialect_name.setter
  def dialect_name(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dialect_name"] = value

def apply_conversion_patterns_dialect_to_llvm(dialect_name, *, loc=None, ip=None) -> _ods_ir.Operation:
  return ApplyToLLVMConversionPatternsOp(dialect_name=dialect_name, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class CastOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.cast"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def cast(output, input, *, loc=None, ip=None) -> _ods_ir.Value:
  return CastOp(output=output, input=input, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CollectMatchingOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.collect_matching"

  _ODS_REGIONS = (0, True)

  def __init__(self, results_, root, matcher, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(root)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["matcher"] = (matcher if (
    isinstance(matcher, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolRefAttr')) else
      _ods_ir.AttrBuilder.get('SymbolRefAttr')(matcher, context=_ods_context))
    results.extend(results_)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def root(self):
    return self.operation.operands[0]

  @builtins.property
  def matcher(self):
    return self.operation.attributes["matcher"]

  @matcher.setter
  def matcher(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["matcher"] = value

  @builtins.property
  def results_(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

def collect_matching(results_, root, matcher, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(CollectMatchingOp(results_=results_, root=root, matcher=matcher, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class ForeachMatchOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.foreach_match"

  _ODS_REGIONS = (0, True)

  def __init__(self, updated, forwarded_outputs, root, forwarded_inputs, matchers, actions, *, restrict_root=None, flatten_results=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(root)
    operands.extend(_get_op_results_or_values(forwarded_inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    if bool(restrict_root): attributes["restrict_root"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    if bool(flatten_results): attributes["flatten_results"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    attributes["matchers"] = (matchers if (
    isinstance(matchers, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolRefArrayAttr')) else
      _ods_ir.AttrBuilder.get('SymbolRefArrayAttr')(matchers, context=_ods_context))
    attributes["actions"] = (actions if (
    isinstance(actions, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolRefArrayAttr')) else
      _ods_ir.AttrBuilder.get('SymbolRefArrayAttr')(actions, context=_ods_context))
    results.append(updated)
    results.extend(forwarded_outputs)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def root(self):
    return self.operation.operands[0]

  @builtins.property
  def forwarded_inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[1:1 + _ods_variadic_group_length]

  @builtins.property
  def restrict_root(self):
    return "restrict_root" in self.operation.attributes

  @restrict_root.setter
  def restrict_root(self, value):
    if bool(value):
      self.operation.attributes["restrict_root"] = _ods_ir.UnitAttr.get()
    elif "restrict_root" in self.operation.attributes:
      del self.operation.attributes["restrict_root"]

  @restrict_root.deleter
  def restrict_root(self):
    del self.operation.attributes["restrict_root"]

  @builtins.property
  def flatten_results(self):
    return "flatten_results" in self.operation.attributes

  @flatten_results.setter
  def flatten_results(self, value):
    if bool(value):
      self.operation.attributes["flatten_results"] = _ods_ir.UnitAttr.get()
    elif "flatten_results" in self.operation.attributes:
      del self.operation.attributes["flatten_results"]

  @flatten_results.deleter
  def flatten_results(self):
    del self.operation.attributes["flatten_results"]

  @builtins.property
  def matchers(self):
    return self.operation.attributes["matchers"]

  @matchers.setter
  def matchers(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["matchers"] = value

  @builtins.property
  def actions(self):
    return self.operation.attributes["actions"]

  @actions.setter
  def actions(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["actions"] = value

  @builtins.property
  def updated(self):
    return self.operation.results[0]

  @builtins.property
  def forwarded_outputs(self):
    _ods_variadic_group_length = len(self.operation.results) - 2 + 1
    return self.operation.results[1:1 + _ods_variadic_group_length]

def foreach_match(updated, forwarded_outputs, root, forwarded_inputs, matchers, actions, *, restrict_root=None, flatten_results=None, loc=None, ip=None) -> _Sequence[_ods_ir.Value]:
  return _get_op_result_or_op_results(ForeachMatchOp(updated=updated, forwarded_outputs=forwarded_outputs, root=root, forwarded_inputs=forwarded_inputs, matchers=matchers, actions=actions, restrict_root=restrict_root, flatten_results=flatten_results, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class ForeachOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.foreach"

  _ODS_REGIONS = (1, True)

  def __init__(self, results_, targets, *, with_zip_shortest=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(targets))
    _ods_context = _ods_get_default_loc_context(loc)
    if bool(with_zip_shortest): attributes["with_zip_shortest"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    results.extend(results_)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def targets(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def with_zip_shortest(self):
    return "with_zip_shortest" in self.operation.attributes

  @with_zip_shortest.setter
  def with_zip_shortest(self, value):
    if bool(value):
      self.operation.attributes["with_zip_shortest"] = _ods_ir.UnitAttr.get()
    elif "with_zip_shortest" in self.operation.attributes:
      del self.operation.attributes["with_zip_shortest"]

  @with_zip_shortest.deleter
  def with_zip_shortest(self):
    del self.operation.attributes["with_zip_shortest"]

  @builtins.property
  def results_(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def body(self):
    return self.regions[0]

def foreach(results_, targets, *, with_zip_shortest=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(ForeachOp(results_=results_, targets=targets, with_zip_shortest=with_zip_shortest, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class GetConsumersOfResult(_ods_ir.OpView):
  OPERATION_NAME = "transform.get_consumers_of_result"

  _ODS_REGIONS = (0, True)

  def __init__(self, consumers, target, result_number, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(target)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["result_number"] = (result_number if (
    isinstance(result_number, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(result_number, context=_ods_context))
    results.append(consumers)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def result_number(self):
    return self.operation.attributes["result_number"]

  @result_number.setter
  def result_number(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["result_number"] = value

  @builtins.property
  def consumers(self):
    return self.operation.results[0]

def get_consumers_of_result(consumers, target, result_number, *, loc=None, ip=None) -> _ods_ir.Value:
  return GetConsumersOfResult(consumers=consumers, target=target, result_number=result_number, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GetDefiningOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.get_defining_op"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, target, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(target)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def get_defining_op(result, target, *, loc=None, ip=None) -> _ods_ir.Value:
  return GetDefiningOp(result=result, target=target, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GetOperandOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.get_operand"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, target, raw_position_list, *, is_inverted=None, is_all=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(target)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["raw_position_list"] = (raw_position_list if (
    isinstance(raw_position_list, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('DenseI64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('DenseI64ArrayAttr')(raw_position_list, context=_ods_context))
    if bool(is_inverted): attributes["is_inverted"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    if bool(is_all): attributes["is_all"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def raw_position_list(self):
    return self.operation.attributes["raw_position_list"]

  @raw_position_list.setter
  def raw_position_list(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["raw_position_list"] = value

  @builtins.property
  def is_inverted(self):
    return "is_inverted" in self.operation.attributes

  @is_inverted.setter
  def is_inverted(self, value):
    if bool(value):
      self.operation.attributes["is_inverted"] = _ods_ir.UnitAttr.get()
    elif "is_inverted" in self.operation.attributes:
      del self.operation.attributes["is_inverted"]

  @is_inverted.deleter
  def is_inverted(self):
    del self.operation.attributes["is_inverted"]

  @builtins.property
  def is_all(self):
    return "is_all" in self.operation.attributes

  @is_all.setter
  def is_all(self, value):
    if bool(value):
      self.operation.attributes["is_all"] = _ods_ir.UnitAttr.get()
    elif "is_all" in self.operation.attributes:
      del self.operation.attributes["is_all"]

  @is_all.deleter
  def is_all(self):
    del self.operation.attributes["is_all"]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def get_operand(result, target, raw_position_list, *, is_inverted=None, is_all=None, loc=None, ip=None) -> _ods_ir.Value:
  return GetOperandOp(result=result, target=target, raw_position_list=raw_position_list, is_inverted=is_inverted, is_all=is_all, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GetParentOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.get_parent_op"

  _ODS_REGIONS = (0, True)

  def __init__(self, parent, target, *, isolated_from_above=None, allow_empty_results=None, op_name=None, deduplicate=None, nth_parent=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(target)
    _ods_context = _ods_get_default_loc_context(loc)
    if bool(isolated_from_above): attributes["isolated_from_above"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    if bool(allow_empty_results): attributes["allow_empty_results"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    if op_name is not None: attributes["op_name"] = (op_name if (
        isinstance(op_name, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(op_name, context=_ods_context))
    if bool(deduplicate): attributes["deduplicate"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    if nth_parent is not None: attributes["nth_parent"] = (nth_parent if (
        isinstance(nth_parent, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(nth_parent, context=_ods_context))
    results.append(parent)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def isolated_from_above(self):
    return "isolated_from_above" in self.operation.attributes

  @isolated_from_above.setter
  def isolated_from_above(self, value):
    if bool(value):
      self.operation.attributes["isolated_from_above"] = _ods_ir.UnitAttr.get()
    elif "isolated_from_above" in self.operation.attributes:
      del self.operation.attributes["isolated_from_above"]

  @isolated_from_above.deleter
  def isolated_from_above(self):
    del self.operation.attributes["isolated_from_above"]

  @builtins.property
  def allow_empty_results(self):
    return "allow_empty_results" in self.operation.attributes

  @allow_empty_results.setter
  def allow_empty_results(self, value):
    if bool(value):
      self.operation.attributes["allow_empty_results"] = _ods_ir.UnitAttr.get()
    elif "allow_empty_results" in self.operation.attributes:
      del self.operation.attributes["allow_empty_results"]

  @allow_empty_results.deleter
  def allow_empty_results(self):
    del self.operation.attributes["allow_empty_results"]

  @builtins.property
  def op_name(self):
    if "op_name" not in self.operation.attributes:
      return None
    return self.operation.attributes["op_name"]

  @op_name.setter
  def op_name(self, value):
    if value is not None:
      self.operation.attributes["op_name"] = value
    elif "op_name" in self.operation.attributes:
      del self.operation.attributes["op_name"]

  @op_name.deleter
  def op_name(self):
    del self.operation.attributes["op_name"]

  @builtins.property
  def deduplicate(self):
    return "deduplicate" in self.operation.attributes

  @deduplicate.setter
  def deduplicate(self, value):
    if bool(value):
      self.operation.attributes["deduplicate"] = _ods_ir.UnitAttr.get()
    elif "deduplicate" in self.operation.attributes:
      del self.operation.attributes["deduplicate"]

  @deduplicate.deleter
  def deduplicate(self):
    del self.operation.attributes["deduplicate"]

  @builtins.property
  def nth_parent(self):
    return self.operation.attributes["nth_parent"]

  @nth_parent.setter
  def nth_parent(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["nth_parent"] = value

  @builtins.property
  def parent(self):
    return self.operation.results[0]

def get_parent_op(parent, target, *, isolated_from_above=None, allow_empty_results=None, op_name=None, deduplicate=None, nth_parent=None, loc=None, ip=None) -> _ods_ir.Value:
  return GetParentOp(parent=parent, target=target, isolated_from_above=isolated_from_above, allow_empty_results=allow_empty_results, op_name=op_name, deduplicate=deduplicate, nth_parent=nth_parent, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GetProducerOfOperand(_ods_ir.OpView):
  OPERATION_NAME = "transform.get_producer_of_operand"

  _ODS_REGIONS = (0, True)

  def __init__(self, producer, target, operand_number, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(target)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["operand_number"] = (operand_number if (
    isinstance(operand_number, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(operand_number, context=_ods_context))
    results.append(producer)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def operand_number(self):
    return self.operation.attributes["operand_number"]

  @operand_number.setter
  def operand_number(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["operand_number"] = value

  @builtins.property
  def producer(self):
    return self.operation.results[0]

def get_producer_of_operand(producer, target, operand_number, *, loc=None, ip=None) -> _ods_ir.Value:
  return GetProducerOfOperand(producer=producer, target=target, operand_number=operand_number, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GetResultOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.get_result"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, target, raw_position_list, *, is_inverted=None, is_all=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(target)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["raw_position_list"] = (raw_position_list if (
    isinstance(raw_position_list, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('DenseI64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('DenseI64ArrayAttr')(raw_position_list, context=_ods_context))
    if bool(is_inverted): attributes["is_inverted"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    if bool(is_all): attributes["is_all"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def raw_position_list(self):
    return self.operation.attributes["raw_position_list"]

  @raw_position_list.setter
  def raw_position_list(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["raw_position_list"] = value

  @builtins.property
  def is_inverted(self):
    return "is_inverted" in self.operation.attributes

  @is_inverted.setter
  def is_inverted(self, value):
    if bool(value):
      self.operation.attributes["is_inverted"] = _ods_ir.UnitAttr.get()
    elif "is_inverted" in self.operation.attributes:
      del self.operation.attributes["is_inverted"]

  @is_inverted.deleter
  def is_inverted(self):
    del self.operation.attributes["is_inverted"]

  @builtins.property
  def is_all(self):
    return "is_all" in self.operation.attributes

  @is_all.setter
  def is_all(self, value):
    if bool(value):
      self.operation.attributes["is_all"] = _ods_ir.UnitAttr.get()
    elif "is_all" in self.operation.attributes:
      del self.operation.attributes["is_all"]

  @is_all.deleter
  def is_all(self):
    del self.operation.attributes["is_all"]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def get_result(result, target, raw_position_list, *, is_inverted=None, is_all=None, loc=None, ip=None) -> _ods_ir.Value:
  return GetResultOp(result=result, target=target, raw_position_list=raw_position_list, is_inverted=is_inverted, is_all=is_all, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GetTypeOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.get_type"

  _ODS_REGIONS = (0, True)

  def __init__(self, type_param, value, *, elemental=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    if bool(elemental): attributes["elemental"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    results.append(type_param)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self):
    return self.operation.operands[0]

  @builtins.property
  def elemental(self):
    return "elemental" in self.operation.attributes

  @elemental.setter
  def elemental(self, value):
    if bool(value):
      self.operation.attributes["elemental"] = _ods_ir.UnitAttr.get()
    elif "elemental" in self.operation.attributes:
      del self.operation.attributes["elemental"]

  @elemental.deleter
  def elemental(self):
    del self.operation.attributes["elemental"]

  @builtins.property
  def type_param(self):
    return self.operation.results[0]

def get_type(type_param, value, *, elemental=None, loc=None, ip=None) -> _ods_ir.Value:
  return GetTypeOp(type_param=type_param, value=value, elemental=elemental, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class IncludeOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.include"

  _ODS_REGIONS = (0, True)

  def __init__(self, results_, target, failure_propagation_mode, operands_, *, arg_attrs=None, res_attrs=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(operands_))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["target"] = (target if (
    isinstance(target, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolRefAttr')) else
      _ods_ir.AttrBuilder.get('SymbolRefAttr')(target, context=_ods_context))
    attributes["failure_propagation_mode"] = (failure_propagation_mode if (
    isinstance(failure_propagation_mode, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('FailurePropagationMode')) else
      _ods_ir.AttrBuilder.get('FailurePropagationMode')(failure_propagation_mode, context=_ods_context))
    if arg_attrs is not None: attributes["arg_attrs"] = (arg_attrs if (
        isinstance(arg_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(arg_attrs, context=_ods_context))
    if res_attrs is not None: attributes["res_attrs"] = (res_attrs if (
        isinstance(res_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(res_attrs, context=_ods_context))
    results.extend(results_)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operands_(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def target(self):
    return self.operation.attributes["target"]

  @target.setter
  def target(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["target"] = value

  @builtins.property
  def failure_propagation_mode(self):
    return self.operation.attributes["failure_propagation_mode"]

  @failure_propagation_mode.setter
  def failure_propagation_mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["failure_propagation_mode"] = value

  @builtins.property
  def arg_attrs(self):
    if "arg_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["arg_attrs"]

  @arg_attrs.setter
  def arg_attrs(self, value):
    if value is not None:
      self.operation.attributes["arg_attrs"] = value
    elif "arg_attrs" in self.operation.attributes:
      del self.operation.attributes["arg_attrs"]

  @arg_attrs.deleter
  def arg_attrs(self):
    del self.operation.attributes["arg_attrs"]

  @builtins.property
  def res_attrs(self):
    if "res_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["res_attrs"]

  @res_attrs.setter
  def res_attrs(self, value):
    if value is not None:
      self.operation.attributes["res_attrs"] = value
    elif "res_attrs" in self.operation.attributes:
      del self.operation.attributes["res_attrs"]

  @res_attrs.deleter
  def res_attrs(self):
    del self.operation.attributes["res_attrs"]

  @builtins.property
  def results_(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

def include(results_, target, failure_propagation_mode, operands_, *, arg_attrs=None, res_attrs=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(IncludeOp(results_=results_, target=target, failure_propagation_mode=failure_propagation_mode, operands_=operands_, arg_attrs=arg_attrs, res_attrs=res_attrs, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class MatchOperationEmptyOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.match.operation_empty"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand_handle, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand_handle)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand_handle(self):
    return self.operation.operands[0]

def match_operation_empty(operand_handle, *, loc=None, ip=None) -> _ods_ir.Operation:
  return MatchOperationEmptyOp(operand_handle=operand_handle, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class MatchOperationNameOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.match.operation_name"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand_handle, op_names, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand_handle)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["op_names"] = (op_names if (
    isinstance(op_names, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrArrayAttr')) else
      _ods_ir.AttrBuilder.get('StrArrayAttr')(op_names, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand_handle(self):
    return self.operation.operands[0]

  @builtins.property
  def op_names(self):
    return self.operation.attributes["op_names"]

  @op_names.setter
  def op_names(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["op_names"] = value

def match_operation_name(operand_handle, op_names, *, loc=None, ip=None) -> _ods_ir.Operation:
  return MatchOperationNameOp(operand_handle=operand_handle, op_names=op_names, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class MatchParamCmpIOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.match.param.cmpi"

  _ODS_REGIONS = (0, True)

  def __init__(self, param, reference, predicate, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(param)
    operands.append(reference)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["predicate"] = (predicate if (
    isinstance(predicate, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('MatchCmpIPredicateAttr')) else
      _ods_ir.AttrBuilder.get('MatchCmpIPredicateAttr')(predicate, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def param(self):
    return self.operation.operands[0]

  @builtins.property
  def reference(self):
    return self.operation.operands[1]

  @builtins.property
  def predicate(self):
    return self.operation.attributes["predicate"]

  @predicate.setter
  def predicate(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["predicate"] = value

def match_param_cmpi(param, reference, predicate, *, loc=None, ip=None) -> _ods_ir.Operation:
  return MatchParamCmpIOp(param=param, reference=reference, predicate=predicate, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class MergeHandlesOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.merge_handles"

  _ODS_REGIONS = (0, True)

  def __init__(self, handles, *, deduplicate=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(handles))
    _ods_context = _ods_get_default_loc_context(loc)
    if bool(deduplicate): attributes["deduplicate"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def handles(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def deduplicate(self):
    return "deduplicate" in self.operation.attributes

  @deduplicate.setter
  def deduplicate(self, value):
    if bool(value):
      self.operation.attributes["deduplicate"] = _ods_ir.UnitAttr.get()
    elif "deduplicate" in self.operation.attributes:
      del self.operation.attributes["deduplicate"]

  @deduplicate.deleter
  def deduplicate(self):
    del self.operation.attributes["deduplicate"]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def merge_handles(handles, *, deduplicate=None, loc=None, ip=None) -> _ods_ir.Value:
  return MergeHandlesOp(handles=handles, deduplicate=deduplicate, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class NamedSequenceOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.named_sequence"

  _ODS_REGIONS = (1, True)

  def __init__(self, sym_name, function_type, *, sym_visibility=None, arg_attrs=None, res_attrs=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["sym_name"] = (sym_name if (
    isinstance(sym_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolNameAttr')) else
      _ods_ir.AttrBuilder.get('SymbolNameAttr')(sym_name, context=_ods_context))
    attributes["function_type"] = (function_type if (
    isinstance(function_type, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('anonymous_491')) else
      _ods_ir.AttrBuilder.get('anonymous_491')(function_type, context=_ods_context))
    if sym_visibility is not None: attributes["sym_visibility"] = (sym_visibility if (
        isinstance(sym_visibility, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(sym_visibility, context=_ods_context))
    if arg_attrs is not None: attributes["arg_attrs"] = (arg_attrs if (
        isinstance(arg_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(arg_attrs, context=_ods_context))
    if res_attrs is not None: attributes["res_attrs"] = (res_attrs if (
        isinstance(res_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(res_attrs, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sym_name(self):
    return self.operation.attributes["sym_name"]

  @sym_name.setter
  def sym_name(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sym_name"] = value

  @builtins.property
  def function_type(self):
    return self.operation.attributes["function_type"]

  @function_type.setter
  def function_type(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["function_type"] = value

  @builtins.property
  def sym_visibility(self):
    if "sym_visibility" not in self.operation.attributes:
      return None
    return self.operation.attributes["sym_visibility"]

  @sym_visibility.setter
  def sym_visibility(self, value):
    if value is not None:
      self.operation.attributes["sym_visibility"] = value
    elif "sym_visibility" in self.operation.attributes:
      del self.operation.attributes["sym_visibility"]

  @sym_visibility.deleter
  def sym_visibility(self):
    del self.operation.attributes["sym_visibility"]

  @builtins.property
  def arg_attrs(self):
    if "arg_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["arg_attrs"]

  @arg_attrs.setter
  def arg_attrs(self, value):
    if value is not None:
      self.operation.attributes["arg_attrs"] = value
    elif "arg_attrs" in self.operation.attributes:
      del self.operation.attributes["arg_attrs"]

  @arg_attrs.deleter
  def arg_attrs(self):
    del self.operation.attributes["arg_attrs"]

  @builtins.property
  def res_attrs(self):
    if "res_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["res_attrs"]

  @res_attrs.setter
  def res_attrs(self, value):
    if value is not None:
      self.operation.attributes["res_attrs"] = value
    elif "res_attrs" in self.operation.attributes:
      del self.operation.attributes["res_attrs"]

  @res_attrs.deleter
  def res_attrs(self):
    del self.operation.attributes["res_attrs"]

  @builtins.property
  def body(self):
    return self.regions[0]

def named_sequence(sym_name, function_type, *, sym_visibility=None, arg_attrs=None, res_attrs=None, loc=None, ip=None) -> _ods_ir.Operation:
  return NamedSequenceOp(sym_name=sym_name, function_type=function_type, sym_visibility=sym_visibility, arg_attrs=arg_attrs, res_attrs=res_attrs, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class NumAssociationsOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.num_associations"

  _ODS_REGIONS = (0, True)

  def __init__(self, num, handle, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(handle)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(num)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def handle(self):
    return self.operation.operands[0]

  @builtins.property
  def num(self):
    return self.operation.results[0]

def num_associations(num, handle, *, loc=None, ip=None) -> _ods_ir.Value:
  return NumAssociationsOp(num=num, handle=handle, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ParamConstantOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.param.constant"

  _ODS_REGIONS = (0, True)

  def __init__(self, param, value, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["value"] = (value if (
    isinstance(value, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('AnyAttr')) else
      _ods_ir.AttrBuilder.get('AnyAttr')(value, context=_ods_context))
    results.append(param)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self):
    return self.operation.attributes["value"]

  @value.setter
  def value(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["value"] = value

  @builtins.property
  def param(self):
    return self.operation.results[0]

def param_constant(param, value, *, loc=None, ip=None) -> _ods_ir.Value:
  return ParamConstantOp(param=param, value=value, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class PrintOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.print"

  _ODS_REGIONS = (0, True)

  def __init__(self, *, target=None, name=None, assume_verified=None, use_local_scope=None, skip_regions=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    if target is not None: operands.append(target)
    _ods_context = _ods_get_default_loc_context(loc)
    if name is not None: attributes["name"] = (name if (
        isinstance(name, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(name, context=_ods_context))
    if bool(assume_verified): attributes["assume_verified"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    if bool(use_local_scope): attributes["use_local_scope"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    if bool(skip_regions): attributes["skip_regions"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self):
    return None if len(self.operation.operands) < 1 else self.operation.operands[0]

  @builtins.property
  def name(self):
    if "name" not in self.operation.attributes:
      return None
    return self.operation.attributes["name"]

  @name.setter
  def name(self, value):
    if value is not None:
      self.operation.attributes["name"] = value
    elif "name" in self.operation.attributes:
      del self.operation.attributes["name"]

  @name.deleter
  def name(self):
    del self.operation.attributes["name"]

  @builtins.property
  def assume_verified(self):
    return "assume_verified" in self.operation.attributes

  @assume_verified.setter
  def assume_verified(self, value):
    if bool(value):
      self.operation.attributes["assume_verified"] = _ods_ir.UnitAttr.get()
    elif "assume_verified" in self.operation.attributes:
      del self.operation.attributes["assume_verified"]

  @assume_verified.deleter
  def assume_verified(self):
    del self.operation.attributes["assume_verified"]

  @builtins.property
  def use_local_scope(self):
    return "use_local_scope" in self.operation.attributes

  @use_local_scope.setter
  def use_local_scope(self, value):
    if bool(value):
      self.operation.attributes["use_local_scope"] = _ods_ir.UnitAttr.get()
    elif "use_local_scope" in self.operation.attributes:
      del self.operation.attributes["use_local_scope"]

  @use_local_scope.deleter
  def use_local_scope(self):
    del self.operation.attributes["use_local_scope"]

  @builtins.property
  def skip_regions(self):
    return "skip_regions" in self.operation.attributes

  @skip_regions.setter
  def skip_regions(self, value):
    if bool(value):
      self.operation.attributes["skip_regions"] = _ods_ir.UnitAttr.get()
    elif "skip_regions" in self.operation.attributes:
      del self.operation.attributes["skip_regions"]

  @skip_regions.deleter
  def skip_regions(self):
    del self.operation.attributes["skip_regions"]

def print_(*, target=None, name=None, assume_verified=None, use_local_scope=None, skip_regions=None, loc=None, ip=None) -> _ods_ir.Operation:
  return PrintOp(target=target, name=name, assume_verified=assume_verified, use_local_scope=use_local_scope, skip_regions=skip_regions, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ReplicateOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.replicate"

  _ODS_REGIONS = (0, True)

  def __init__(self, replicated, pattern, handles, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(pattern)
    operands.extend(_get_op_results_or_values(handles))
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend(replicated)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def pattern(self):
    return self.operation.operands[0]

  @builtins.property
  def handles(self):
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[1:1 + _ods_variadic_group_length]

  @builtins.property
  def replicated(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

def replicate(replicated, pattern, handles, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(ReplicateOp(replicated=replicated, pattern=pattern, handles=handles, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class SelectOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.select"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, target, op_name, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(target)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["op_name"] = (op_name if (
    isinstance(op_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(op_name, context=_ods_context))
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def op_name(self):
    return self.operation.attributes["op_name"]

  @op_name.setter
  def op_name(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["op_name"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def select(result, target, op_name, *, loc=None, ip=None) -> _ods_ir.Value:
  return SelectOp(result=result, target=target, op_name=op_name, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SequenceOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.sequence"

  _ODS_OPERAND_SEGMENTS = [0,-1,]

  _ODS_REGIONS = (1, True)

  def __init__(self, results_, failure_propagation_mode, extra_bindings, *, root=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(root)
    operands.append(_get_op_results_or_values(extra_bindings))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["failure_propagation_mode"] = (failure_propagation_mode if (
    isinstance(failure_propagation_mode, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('FailurePropagationMode')) else
      _ods_ir.AttrBuilder.get('FailurePropagationMode')(failure_propagation_mode, context=_ods_context))
    results.extend(results_)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def root(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def extra_bindings(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def failure_propagation_mode(self):
    return self.operation.attributes["failure_propagation_mode"]

  @failure_propagation_mode.setter
  def failure_propagation_mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["failure_propagation_mode"] = value

  @builtins.property
  def results_(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def body(self):
    return self.regions[0]

def sequence(results_, failure_propagation_mode, extra_bindings, *, root=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(SequenceOp(results_=results_, failure_propagation_mode=failure_propagation_mode, extra_bindings=extra_bindings, root=root, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class SplitHandleOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.split_handle"

  _ODS_REGIONS = (0, True)

  def __init__(self, results_, handle, *, pass_through_empty_handle=None, fail_on_payload_too_small=None, overflow_result=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(handle)
    _ods_context = _ods_get_default_loc_context(loc)
    if pass_through_empty_handle is not None: attributes["pass_through_empty_handle"] = (pass_through_empty_handle if (
        isinstance(pass_through_empty_handle, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(pass_through_empty_handle, context=_ods_context))
    if fail_on_payload_too_small is not None: attributes["fail_on_payload_too_small"] = (fail_on_payload_too_small if (
        isinstance(fail_on_payload_too_small, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(fail_on_payload_too_small, context=_ods_context))
    if overflow_result is not None: attributes["overflow_result"] = (overflow_result if (
        isinstance(overflow_result, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(overflow_result, context=_ods_context))
    results.extend(results_)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def handle(self):
    return self.operation.operands[0]

  @builtins.property
  def pass_through_empty_handle(self):
    return self.operation.attributes["pass_through_empty_handle"]

  @pass_through_empty_handle.setter
  def pass_through_empty_handle(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["pass_through_empty_handle"] = value

  @builtins.property
  def fail_on_payload_too_small(self):
    return self.operation.attributes["fail_on_payload_too_small"]

  @fail_on_payload_too_small.setter
  def fail_on_payload_too_small(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fail_on_payload_too_small"] = value

  @builtins.property
  def overflow_result(self):
    if "overflow_result" not in self.operation.attributes:
      return None
    return self.operation.attributes["overflow_result"]

  @overflow_result.setter
  def overflow_result(self, value):
    if value is not None:
      self.operation.attributes["overflow_result"] = value
    elif "overflow_result" in self.operation.attributes:
      del self.operation.attributes["overflow_result"]

  @overflow_result.deleter
  def overflow_result(self):
    del self.operation.attributes["overflow_result"]

  @builtins.property
  def results_(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

def split_handle(results_, handle, *, pass_through_empty_handle=None, fail_on_payload_too_small=None, overflow_result=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(SplitHandleOp(results_=results_, handle=handle, pass_through_empty_handle=pass_through_empty_handle, fail_on_payload_too_small=fail_on_payload_too_small, overflow_result=overflow_result, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class VerifyOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.verify"

  _ODS_REGIONS = (0, True)

  def __init__(self, target, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(target)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self):
    return self.operation.operands[0]

def verify_(target, *, loc=None, ip=None) -> _ods_ir.Operation:
  return VerifyOp(target=target, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class YieldOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.yield"

  _ODS_REGIONS = (0, True)

  def __init__(self, operands_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(operands_))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operands_(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

def yield_(operands_, *, loc=None, ip=None) -> _ods_ir.Operation:
  return YieldOp(operands_=operands_, loc=loc, ip=ip)
