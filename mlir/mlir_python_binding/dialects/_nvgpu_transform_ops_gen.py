
# Autogenerated by mlir-tblgen; don't manually edit.

from ._ods_common import _cext as _ods_cext
from ._ods_common import (
    equally_sized_accessor as _ods_equally_sized_accessor,
    get_default_loc_context as _ods_get_default_loc_context,
    get_op_result_or_op_results as _get_op_result_or_op_results,
    get_op_results_or_values as _get_op_results_or_values,
    segmented_accessor as _ods_segmented_accessor,
)
_ods_ir = _ods_cext.ir

import builtins
from typing import Sequence as _Sequence, Union as _Union


from ._transform_ops_gen import _Dialect

@_ods_cext.register_operation(_Dialect)
class ApplyNVGPUToNVVMConversionPatternsOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.apply_conversion_patterns.nvgpu.nvgpu_to_nvvm"

  _ODS_REGIONS = (0, True)

  def __init__(self, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

def apply_conversion_patterns_nvgpu_nvgpu_to_nvvm(*, loc=None, ip=None) -> _ods_ir.Operation:
  return ApplyNVGPUToNVVMConversionPatternsOp(loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class CreateAsyncGroupsOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.nvgpu.create_async_groups"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, target, *, bypass_l1=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(target)
    _ods_context = _ods_get_default_loc_context(loc)
    if bool(bypass_l1): attributes["bypass_l1"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def bypass_l1(self):
    return "bypass_l1" in self.operation.attributes

  @bypass_l1.setter
  def bypass_l1(self, value):
    if bool(value):
      self.operation.attributes["bypass_l1"] = _ods_ir.UnitAttr.get()
    elif "bypass_l1" in self.operation.attributes:
      del self.operation.attributes["bypass_l1"]

  @bypass_l1.deleter
  def bypass_l1(self):
    del self.operation.attributes["bypass_l1"]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def nvgpu_create_async_groups(result, target, *, bypass_l1=None, loc=None, ip=None) -> _ods_ir.Value:
  return CreateAsyncGroupsOp(result=result, target=target, bypass_l1=bypass_l1, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class PipelineSharedMemoryCopiesOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.nvgpu.pipeline_shared_memory_copies"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, for_op, depth, *, peel_epilogue=None, failure_propagation_mode=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(for_op)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["depth"] = (depth if (
    isinstance(depth, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(depth, context=_ods_context))
    if bool(peel_epilogue): attributes["peel_epilogue"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    if failure_propagation_mode is not None: attributes["failure_propagation_mode"] = (failure_propagation_mode if (
        isinstance(failure_propagation_mode, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('FailurePropagationMode')) else
          _ods_ir.AttrBuilder.get('FailurePropagationMode')(failure_propagation_mode, context=_ods_context))
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def for_op(self):
    return self.operation.operands[0]

  @builtins.property
  def depth(self):
    return self.operation.attributes["depth"]

  @depth.setter
  def depth(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["depth"] = value

  @builtins.property
  def peel_epilogue(self):
    return "peel_epilogue" in self.operation.attributes

  @peel_epilogue.setter
  def peel_epilogue(self, value):
    if bool(value):
      self.operation.attributes["peel_epilogue"] = _ods_ir.UnitAttr.get()
    elif "peel_epilogue" in self.operation.attributes:
      del self.operation.attributes["peel_epilogue"]

  @peel_epilogue.deleter
  def peel_epilogue(self):
    del self.operation.attributes["peel_epilogue"]

  @builtins.property
  def failure_propagation_mode(self):
    return self.operation.attributes["failure_propagation_mode"]

  @failure_propagation_mode.setter
  def failure_propagation_mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["failure_propagation_mode"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def nvgpu_pipeline_shared_memory_copies(result, for_op, depth, *, peel_epilogue=None, failure_propagation_mode=None, loc=None, ip=None) -> _ods_ir.Value:
  return PipelineSharedMemoryCopiesOp(result=result, for_op=for_op, depth=depth, peel_epilogue=peel_epilogue, failure_propagation_mode=failure_propagation_mode, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class RewriteCopyAsTmaOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.nvgpu.rewrite_copy_as_tma"

  _ODS_REGIONS = (0, True)

  def __init__(self, target, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(target)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self):
    return self.operation.operands[0]

def nvgpu_rewrite_copy_as_tma(target, *, loc=None, ip=None) -> _ods_ir.Operation:
  return RewriteCopyAsTmaOp(target=target, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class RewriteMatmulAsMmaSyncOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.nvgpu.rewrite_matmul_as_mma_sync"

  _ODS_REGIONS = (0, True)

  def __init__(self, target, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(target)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self):
    return self.operation.operands[0]

def nvgpu_rewrite_matmul_as_mma_sync(target, *, loc=None, ip=None) -> _ods_ir.Operation:
  return RewriteMatmulAsMmaSyncOp(target=target, loc=loc, ip=ip)
