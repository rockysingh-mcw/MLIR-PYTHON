
# Autogenerated by mlir-tblgen; don't manually edit.

from ._ods_common import _cext as _ods_cext
from ._ods_common import (
    equally_sized_accessor as _ods_equally_sized_accessor,
    get_default_loc_context as _ods_get_default_loc_context,
    get_op_result_or_op_results as _get_op_result_or_op_results,
    get_op_results_or_values as _get_op_results_or_values,
    segmented_accessor as _ods_segmented_accessor,
)
_ods_ir = _ods_cext.ir

import builtins
from typing import Sequence as _Sequence, Union as _Union


from ._transform_ops_gen import _Dialect

@_ods_cext.register_operation(_Dialect)
class ApplyGPURewritePatternsOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.apply_patterns.gpu.gpu_rewrite_patterns"

  _ODS_REGIONS = (0, True)

  def __init__(self, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

def apply_patterns_gpu_gpu_rewrite_patterns(*, loc=None, ip=None) -> _ods_ir.Operation:
  return ApplyGPURewritePatternsOp(loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ApplyGPUSubgroupReduceToNVVMConversionPatternsOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.apply_conversion_patterns.gpu.gpu_subgroup_reduce_to_nvvm"

  _ODS_REGIONS = (0, True)

  def __init__(self, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

def apply_conversion_patterns_gpu_gpu_subgroup_reduce_to_nvvm(*, loc=None, ip=None) -> _ods_ir.Operation:
  return ApplyGPUSubgroupReduceToNVVMConversionPatternsOp(loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ApplyGPUToNVVMConversionPatternsOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.apply_conversion_patterns.gpu.gpu_to_nvvm"

  _ODS_REGIONS = (0, True)

  def __init__(self, *, benefit=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    if benefit is not None: attributes["benefit"] = (benefit if (
        isinstance(benefit, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I16Attr')) else
          _ods_ir.AttrBuilder.get('I16Attr')(benefit, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def benefit(self):
    return self.operation.attributes["benefit"]

  @benefit.setter
  def benefit(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["benefit"] = value

def apply_conversion_patterns_gpu_gpu_to_nvvm(*, benefit=None, loc=None, ip=None) -> _ods_ir.Operation:
  return ApplyGPUToNVVMConversionPatternsOp(benefit=benefit, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ApplyGPUWwmaToNVVMConversionPatternsOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.apply_conversion_patterns.gpu.gpu_wmma_to_nvvm"

  _ODS_REGIONS = (0, True)

  def __init__(self, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

def apply_conversion_patterns_gpu_gpu_wmma_to_nvvm(*, loc=None, ip=None) -> _ods_ir.Operation:
  return ApplyGPUWwmaToNVVMConversionPatternsOp(loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ApplyUnrollVectorsSubgroupMmaOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.apply_patterns.gpu.unroll_vectors_subgroup_mma"

  _ODS_REGIONS = (0, True)

  def __init__(self, m, n, k, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["m"] = (m if (
    isinstance(m, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(m, context=_ods_context))
    attributes["n"] = (n if (
    isinstance(n, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(n, context=_ods_context))
    attributes["k"] = (k if (
    isinstance(k, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(k, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def m(self):
    return self.operation.attributes["m"]

  @m.setter
  def m(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["m"] = value

  @builtins.property
  def n(self):
    return self.operation.attributes["n"]

  @n.setter
  def n(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["n"] = value

  @builtins.property
  def k(self):
    return self.operation.attributes["k"]

  @k.setter
  def k(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["k"] = value

def apply_patterns_gpu_unroll_vectors_subgroup_mma(m, n, k, *, loc=None, ip=None) -> _ods_ir.Operation:
  return ApplyUnrollVectorsSubgroupMmaOp(m=m, n=n, k=k, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class EliminateBarriersOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.apply_patterns.gpu.eliminate_barriers"

  _ODS_REGIONS = (0, True)

  def __init__(self, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

def apply_patterns_gpu_eliminate_barriers(*, loc=None, ip=None) -> _ods_ir.Operation:
  return EliminateBarriersOp(loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class MapForallToBlocks(_ods_ir.OpView):
  OPERATION_NAME = "transform.gpu.map_forall_to_blocks"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, target, *, grid_dims=None, generate_gpu_launch=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(target)
    _ods_context = _ods_get_default_loc_context(loc)
    if grid_dims is not None: attributes["grid_dims"] = (grid_dims if (
        isinstance(grid_dims, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DenseI64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('DenseI64ArrayAttr')(grid_dims, context=_ods_context))
    if bool(generate_gpu_launch): attributes["generate_gpu_launch"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def grid_dims(self):
    if "grid_dims" not in self.operation.attributes:
      return None
    return self.operation.attributes["grid_dims"]

  @grid_dims.setter
  def grid_dims(self, value):
    if value is not None:
      self.operation.attributes["grid_dims"] = value
    elif "grid_dims" in self.operation.attributes:
      del self.operation.attributes["grid_dims"]

  @grid_dims.deleter
  def grid_dims(self):
    del self.operation.attributes["grid_dims"]

  @builtins.property
  def generate_gpu_launch(self):
    return "generate_gpu_launch" in self.operation.attributes

  @generate_gpu_launch.setter
  def generate_gpu_launch(self, value):
    if bool(value):
      self.operation.attributes["generate_gpu_launch"] = _ods_ir.UnitAttr.get()
    elif "generate_gpu_launch" in self.operation.attributes:
      del self.operation.attributes["generate_gpu_launch"]

  @generate_gpu_launch.deleter
  def generate_gpu_launch(self):
    del self.operation.attributes["generate_gpu_launch"]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def gpu_map_forall_to_blocks(result, target, *, grid_dims=None, generate_gpu_launch=None, loc=None, ip=None) -> _ods_ir.Value:
  return MapForallToBlocks(result=result, target=target, grid_dims=grid_dims, generate_gpu_launch=generate_gpu_launch, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MapNestedForallToThreads(_ods_ir.OpView):
  OPERATION_NAME = "transform.gpu.map_nested_forall_to_threads"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, target, *, block_dims=None, sync_after_distribute=None, warp_size=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(target)
    _ods_context = _ods_get_default_loc_context(loc)
    if block_dims is not None: attributes["block_dims"] = (block_dims if (
        isinstance(block_dims, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DenseI64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('DenseI64ArrayAttr')(block_dims, context=_ods_context))
    if sync_after_distribute is not None: attributes["sync_after_distribute"] = (sync_after_distribute if (
        isinstance(sync_after_distribute, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(sync_after_distribute, context=_ods_context))
    if warp_size is not None: attributes["warp_size"] = (warp_size if (
        isinstance(warp_size, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(warp_size, context=_ods_context))
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def block_dims(self):
    return self.operation.attributes["block_dims"]

  @block_dims.setter
  def block_dims(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["block_dims"] = value

  @builtins.property
  def sync_after_distribute(self):
    return self.operation.attributes["sync_after_distribute"]

  @sync_after_distribute.setter
  def sync_after_distribute(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sync_after_distribute"] = value

  @builtins.property
  def warp_size(self):
    return self.operation.attributes["warp_size"]

  @warp_size.setter
  def warp_size(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["warp_size"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def gpu_map_nested_forall_to_threads(result, target, *, block_dims=None, sync_after_distribute=None, warp_size=None, loc=None, ip=None) -> _ods_ir.Value:
  return MapNestedForallToThreads(result=result, target=target, block_dims=block_dims, sync_after_distribute=sync_after_distribute, warp_size=warp_size, loc=loc, ip=ip).result
