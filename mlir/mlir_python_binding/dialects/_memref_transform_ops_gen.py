
# Autogenerated by mlir-tblgen; don't manually edit.

from ._ods_common import _cext as _ods_cext
from ._ods_common import (
    equally_sized_accessor as _ods_equally_sized_accessor,
    get_default_loc_context as _ods_get_default_loc_context,
    get_op_result_or_op_results as _get_op_result_or_op_results,
    get_op_results_or_values as _get_op_results_or_values,
    segmented_accessor as _ods_segmented_accessor,
)
_ods_ir = _ods_cext.ir

import builtins
from typing import Sequence as _Sequence, Union as _Union


from ._transform_ops_gen import _Dialect

@_ods_cext.register_operation(_Dialect)
class ApplyAllocToAllocaOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.apply_patterns.memref.alloc_to_alloca"

  _ODS_REGIONS = (0, True)

  def __init__(self, *, size_limit=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    if size_limit is not None: attributes["size_limit"] = (size_limit if (
        isinstance(size_limit, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(size_limit, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def size_limit(self):
    if "size_limit" not in self.operation.attributes:
      return None
    return self.operation.attributes["size_limit"]

  @size_limit.setter
  def size_limit(self, value):
    if value is not None:
      self.operation.attributes["size_limit"] = value
    elif "size_limit" in self.operation.attributes:
      del self.operation.attributes["size_limit"]

  @size_limit.deleter
  def size_limit(self):
    del self.operation.attributes["size_limit"]

def apply_patterns_memref_alloc_to_alloca(*, size_limit=None, loc=None, ip=None) -> _ods_ir.Operation:
  return ApplyAllocToAllocaOp(size_limit=size_limit, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ApplyExpandOpsPatternsOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.apply_patterns.memref.expand_ops"

  _ODS_REGIONS = (0, True)

  def __init__(self, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

def apply_patterns_memref_expand_ops(*, loc=None, ip=None) -> _ods_ir.Operation:
  return ApplyExpandOpsPatternsOp(loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ApplyExpandStridedMetadataPatternsOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.apply_patterns.memref.expand_strided_metadata"

  _ODS_REGIONS = (0, True)

  def __init__(self, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

def apply_patterns_memref_expand_strided_metadata(*, loc=None, ip=None) -> _ods_ir.Operation:
  return ApplyExpandStridedMetadataPatternsOp(loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ApplyExtractAddressComputationsPatternsOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.apply_patterns.memref.extract_address_computations"

  _ODS_REGIONS = (0, True)

  def __init__(self, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

def apply_patterns_memref_extract_address_computations(*, loc=None, ip=None) -> _ods_ir.Operation:
  return ApplyExtractAddressComputationsPatternsOp(loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ApplyFoldMemrefAliasOpsPatternsOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.apply_patterns.memref.fold_memref_alias_ops"

  _ODS_REGIONS = (0, True)

  def __init__(self, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

def apply_patterns_memref_fold_memref_alias_ops(*, loc=None, ip=None) -> _ods_ir.Operation:
  return ApplyFoldMemrefAliasOpsPatternsOp(loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ApplyResolveRankedShapedTypeResultDimsPatternsOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.apply_patterns.memref.resolve_ranked_shaped_type_result_dims"

  _ODS_REGIONS = (0, True)

  def __init__(self, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

def apply_patterns_memref_resolve_ranked_shaped_type_result_dims(*, loc=None, ip=None) -> _ods_ir.Operation:
  return ApplyResolveRankedShapedTypeResultDimsPatternsOp(loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class MemRefAllocaToGlobalOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.memref.alloca_to_global"

  _ODS_REGIONS = (0, True)

  def __init__(self, getGlobal, global_, alloca, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(alloca)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(getGlobal)
    results.append(global_)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def alloca(self):
    return self.operation.operands[0]

  @builtins.property
  def getGlobal(self):
    return self.operation.results[0]

  @builtins.property
  def global_(self):
    return self.operation.results[1]

def memref_alloca_to_global(get_global, global_, alloca, *, loc=None, ip=None) -> _Sequence[_ods_ir.Value]:
  return MemRefAllocaToGlobalOp(getGlobal=get_global, global_=global_, alloca=alloca, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class MemRefEraseDeadAllocAndStoresOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.memref.erase_dead_alloc_and_stores"

  _ODS_REGIONS = (0, True)

  def __init__(self, target, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(target)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self):
    return self.operation.operands[0]

def memref_erase_dead_alloc_and_stores(target, *, loc=None, ip=None) -> _ods_ir.Operation:
  return MemRefEraseDeadAllocAndStoresOp(target=target, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class MemRefMakeLoopIndependentOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.memref.make_loop_independent"

  _ODS_REGIONS = (0, True)

  def __init__(self, transformed, target, num_loops, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(target)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["num_loops"] = (num_loops if (
    isinstance(num_loops, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(num_loops, context=_ods_context))
    results.append(transformed)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def num_loops(self):
    return self.operation.attributes["num_loops"]

  @num_loops.setter
  def num_loops(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["num_loops"] = value

  @builtins.property
  def transformed(self):
    return self.operation.results[0]

def memref_make_loop_independent(transformed, target, num_loops, *, loc=None, ip=None) -> _ods_ir.Value:
  return MemRefMakeLoopIndependentOp(transformed=transformed, target=target, num_loops=num_loops, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MemRefMultiBufferOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.memref.multibuffer"

  _ODS_REGIONS = (0, True)

  def __init__(self, transformed, target, factor, *, skip_analysis=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(target)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["factor"] = (factor if (
    isinstance(factor, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(factor, context=_ods_context))
    if bool(skip_analysis): attributes["skip_analysis"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    results.append(transformed)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def factor(self):
    return self.operation.attributes["factor"]

  @factor.setter
  def factor(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["factor"] = value

  @builtins.property
  def skip_analysis(self):
    return "skip_analysis" in self.operation.attributes

  @skip_analysis.setter
  def skip_analysis(self, value):
    if bool(value):
      self.operation.attributes["skip_analysis"] = _ods_ir.UnitAttr.get()
    elif "skip_analysis" in self.operation.attributes:
      del self.operation.attributes["skip_analysis"]

  @skip_analysis.deleter
  def skip_analysis(self):
    del self.operation.attributes["skip_analysis"]

  @builtins.property
  def transformed(self):
    return self.operation.results[0]

def memref_multibuffer(transformed, target, factor, *, skip_analysis=None, loc=None, ip=None) -> _ods_ir.Value:
  return MemRefMultiBufferOp(transformed=transformed, target=target, factor=factor, skip_analysis=skip_analysis, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MemrefToLLVMTypeConverterOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.apply_conversion_patterns.memref.memref_to_llvm_type_converter"

  _ODS_REGIONS = (0, True)

  def __init__(self, *, use_aligned_alloc=None, index_bitwidth=None, use_generic_functions=None, use_bare_ptr_call_conv=None, data_layout=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    if use_aligned_alloc is not None: attributes["use_aligned_alloc"] = (use_aligned_alloc if (
        isinstance(use_aligned_alloc, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(use_aligned_alloc, context=_ods_context))
    if index_bitwidth is not None: attributes["index_bitwidth"] = (index_bitwidth if (
        isinstance(index_bitwidth, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(index_bitwidth, context=_ods_context))
    if use_generic_functions is not None: attributes["use_generic_functions"] = (use_generic_functions if (
        isinstance(use_generic_functions, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(use_generic_functions, context=_ods_context))
    if use_bare_ptr_call_conv is not None: attributes["use_bare_ptr_call_conv"] = (use_bare_ptr_call_conv if (
        isinstance(use_bare_ptr_call_conv, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(use_bare_ptr_call_conv, context=_ods_context))
    if data_layout is not None: attributes["data_layout"] = (data_layout if (
        isinstance(data_layout, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(data_layout, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def use_aligned_alloc(self):
    if "use_aligned_alloc" not in self.operation.attributes:
      return None
    return self.operation.attributes["use_aligned_alloc"]

  @use_aligned_alloc.setter
  def use_aligned_alloc(self, value):
    if value is not None:
      self.operation.attributes["use_aligned_alloc"] = value
    elif "use_aligned_alloc" in self.operation.attributes:
      del self.operation.attributes["use_aligned_alloc"]

  @use_aligned_alloc.deleter
  def use_aligned_alloc(self):
    del self.operation.attributes["use_aligned_alloc"]

  @builtins.property
  def index_bitwidth(self):
    if "index_bitwidth" not in self.operation.attributes:
      return None
    return self.operation.attributes["index_bitwidth"]

  @index_bitwidth.setter
  def index_bitwidth(self, value):
    if value is not None:
      self.operation.attributes["index_bitwidth"] = value
    elif "index_bitwidth" in self.operation.attributes:
      del self.operation.attributes["index_bitwidth"]

  @index_bitwidth.deleter
  def index_bitwidth(self):
    del self.operation.attributes["index_bitwidth"]

  @builtins.property
  def use_generic_functions(self):
    if "use_generic_functions" not in self.operation.attributes:
      return None
    return self.operation.attributes["use_generic_functions"]

  @use_generic_functions.setter
  def use_generic_functions(self, value):
    if value is not None:
      self.operation.attributes["use_generic_functions"] = value
    elif "use_generic_functions" in self.operation.attributes:
      del self.operation.attributes["use_generic_functions"]

  @use_generic_functions.deleter
  def use_generic_functions(self):
    del self.operation.attributes["use_generic_functions"]

  @builtins.property
  def use_bare_ptr_call_conv(self):
    if "use_bare_ptr_call_conv" not in self.operation.attributes:
      return None
    return self.operation.attributes["use_bare_ptr_call_conv"]

  @use_bare_ptr_call_conv.setter
  def use_bare_ptr_call_conv(self, value):
    if value is not None:
      self.operation.attributes["use_bare_ptr_call_conv"] = value
    elif "use_bare_ptr_call_conv" in self.operation.attributes:
      del self.operation.attributes["use_bare_ptr_call_conv"]

  @use_bare_ptr_call_conv.deleter
  def use_bare_ptr_call_conv(self):
    del self.operation.attributes["use_bare_ptr_call_conv"]

  @builtins.property
  def data_layout(self):
    if "data_layout" not in self.operation.attributes:
      return None
    return self.operation.attributes["data_layout"]

  @data_layout.setter
  def data_layout(self, value):
    if value is not None:
      self.operation.attributes["data_layout"] = value
    elif "data_layout" in self.operation.attributes:
      del self.operation.attributes["data_layout"]

  @data_layout.deleter
  def data_layout(self):
    del self.operation.attributes["data_layout"]

def apply_conversion_patterns_memref_memref_to_llvm_type_converter(*, use_aligned_alloc=None, index_bitwidth=None, use_generic_functions=None, use_bare_ptr_call_conv=None, data_layout=None, loc=None, ip=None) -> _ods_ir.Operation:
  return MemrefToLLVMTypeConverterOp(use_aligned_alloc=use_aligned_alloc, index_bitwidth=index_bitwidth, use_generic_functions=use_generic_functions, use_bare_ptr_call_conv=use_bare_ptr_call_conv, data_layout=data_layout, loc=loc, ip=ip)
