
# Autogenerated by mlir-tblgen; don't manually edit.

from ._ods_common import _cext as _ods_cext
from ._ods_common import (
    equally_sized_accessor as _ods_equally_sized_accessor,
    get_default_loc_context as _ods_get_default_loc_context,
    get_op_result_or_op_results as _get_op_result_or_op_results,
    get_op_results_or_values as _get_op_results_or_values,
    segmented_accessor as _ods_segmented_accessor,
)
_ods_ir = _ods_cext.ir

import builtins
from typing import Sequence as _Sequence, Union as _Union


from ._transform_ops_gen import _Dialect

@_ods_cext.register_operation(_Dialect)
class ApplyForLoopCanonicalizationPatternsOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.apply_patterns.scf.for_loop_canonicalization"

  _ODS_REGIONS = (0, True)

  def __init__(self, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

def apply_patterns_scf_for_loop_canonicalization(*, loc=None, ip=None) -> _ods_ir.Operation:
  return ApplyForLoopCanonicalizationPatternsOp(loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ApplySCFStructuralConversionPatternsOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.apply_conversion_patterns.scf.structural_conversions"

  _ODS_REGIONS = (0, True)

  def __init__(self, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

def apply_conversion_patterns_scf_structural_conversions(*, loc=None, ip=None) -> _ods_ir.Operation:
  return ApplySCFStructuralConversionPatternsOp(loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ApplySCFToControlFlowPatternsOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.apply_conversion_patterns.scf.scf_to_control_flow"

  _ODS_REGIONS = (0, True)

  def __init__(self, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

def apply_conversion_patterns_scf_scf_to_control_flow(*, loc=None, ip=None) -> _ods_ir.Operation:
  return ApplySCFToControlFlowPatternsOp(loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ForallToForOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.loop.forall_to_for"

  _ODS_REGIONS = (0, True)

  def __init__(self, transformed, target, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(target)
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend(transformed)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def transformed(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

def loop_forall_to_for(transformed, target, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(ForallToForOp(transformed=transformed, target=target, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class ForallToParallelOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.loop.forall_to_parallel"

  _ODS_REGIONS = (0, True)

  def __init__(self, transformed, target, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(target)
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend(transformed)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def transformed(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

def loop_forall_to_parallel(transformed, target, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(ForallToParallelOp(transformed=transformed, target=target, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class HoistLoopInvariantSubsetsOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.loop.hoist_loop_invariant_subsets"

  _ODS_REGIONS = (0, True)

  def __init__(self, target, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(target)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self):
    return self.operation.operands[0]

def loop_hoist_loop_invariant_subsets(target, *, loc=None, ip=None) -> _ods_ir.Operation:
  return HoistLoopInvariantSubsetsOp(target=target, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class LoopCoalesceOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.loop.coalesce"

  _ODS_REGIONS = (0, True)

  def __init__(self, transformed, target, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(target)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(transformed)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def transformed(self):
    return self.operation.results[0]

def loop_coalesce(transformed, target, *, loc=None, ip=None) -> _ods_ir.Value:
  return LoopCoalesceOp(transformed=transformed, target=target, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class LoopFuseSiblingOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.loop.fuse_sibling"

  _ODS_REGIONS = (0, True)

  def __init__(self, fused_loop, target, source, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(target)
    operands.append(source)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(fused_loop)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def source(self):
    return self.operation.operands[1]

  @builtins.property
  def fused_loop(self):
    return self.operation.results[0]

def loop_fuse_sibling(fused_loop, target, source, *, loc=None, ip=None) -> _ods_ir.Value:
  return LoopFuseSiblingOp(fused_loop=fused_loop, target=target, source=source, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class LoopOutlineOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.loop.outline"

  _ODS_REGIONS = (0, True)

  def __init__(self, function, call, target, func_name, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(target)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["func_name"] = (func_name if (
    isinstance(func_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(func_name, context=_ods_context))
    results.append(function)
    results.append(call)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def func_name(self):
    return self.operation.attributes["func_name"]

  @func_name.setter
  def func_name(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["func_name"] = value

  @builtins.property
  def function(self):
    return self.operation.results[0]

  @builtins.property
  def call(self):
    return self.operation.results[1]

def loop_outline(function, call, target, func_name, *, loc=None, ip=None) -> _Sequence[_ods_ir.Value]:
  return LoopOutlineOp(function=function, call=call, target=target, func_name=func_name, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class LoopPeelOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.loop.peel"

  _ODS_REGIONS = (0, True)

  def __init__(self, peeled_loop, remainder_loop, target, *, peel_front=None, fail_if_already_divisible=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(target)
    _ods_context = _ods_get_default_loc_context(loc)
    if peel_front is not None: attributes["peel_front"] = (peel_front if (
        isinstance(peel_front, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(peel_front, context=_ods_context))
    if fail_if_already_divisible is not None: attributes["fail_if_already_divisible"] = (fail_if_already_divisible if (
        isinstance(fail_if_already_divisible, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(fail_if_already_divisible, context=_ods_context))
    results.append(peeled_loop)
    results.append(remainder_loop)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def peel_front(self):
    return self.operation.attributes["peel_front"]

  @peel_front.setter
  def peel_front(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["peel_front"] = value

  @builtins.property
  def fail_if_already_divisible(self):
    return self.operation.attributes["fail_if_already_divisible"]

  @fail_if_already_divisible.setter
  def fail_if_already_divisible(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fail_if_already_divisible"] = value

  @builtins.property
  def peeled_loop(self):
    return self.operation.results[0]

  @builtins.property
  def remainder_loop(self):
    return self.operation.results[1]

def loop_peel(peeled_loop, remainder_loop, target, *, peel_front=None, fail_if_already_divisible=None, loc=None, ip=None) -> _Sequence[_ods_ir.Value]:
  return LoopPeelOp(peeled_loop=peeled_loop, remainder_loop=remainder_loop, target=target, peel_front=peel_front, fail_if_already_divisible=fail_if_already_divisible, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class LoopPipelineOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.loop.pipeline"

  _ODS_REGIONS = (0, True)

  def __init__(self, transformed, target, *, iteration_interval=None, read_latency=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(target)
    _ods_context = _ods_get_default_loc_context(loc)
    if iteration_interval is not None: attributes["iteration_interval"] = (iteration_interval if (
        isinstance(iteration_interval, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(iteration_interval, context=_ods_context))
    if read_latency is not None: attributes["read_latency"] = (read_latency if (
        isinstance(read_latency, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(read_latency, context=_ods_context))
    results.append(transformed)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def iteration_interval(self):
    return self.operation.attributes["iteration_interval"]

  @iteration_interval.setter
  def iteration_interval(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["iteration_interval"] = value

  @builtins.property
  def read_latency(self):
    return self.operation.attributes["read_latency"]

  @read_latency.setter
  def read_latency(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["read_latency"] = value

  @builtins.property
  def transformed(self):
    return self.operation.results[0]

def loop_pipeline(transformed, target, *, iteration_interval=None, read_latency=None, loc=None, ip=None) -> _ods_ir.Value:
  return LoopPipelineOp(transformed=transformed, target=target, iteration_interval=iteration_interval, read_latency=read_latency, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class LoopPromoteIfOneIterationOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.loop.promote_if_one_iteration"

  _ODS_REGIONS = (0, True)

  def __init__(self, target, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(target)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self):
    return self.operation.operands[0]

def loop_promote_if_one_iteration(target, *, loc=None, ip=None) -> _ods_ir.Operation:
  return LoopPromoteIfOneIterationOp(target=target, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class LoopUnrollAndJamOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.loop.unroll_and_jam"

  _ODS_REGIONS = (0, True)

  def __init__(self, target, factor, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(target)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["factor"] = (factor if (
    isinstance(factor, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(factor, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def factor(self):
    return self.operation.attributes["factor"]

  @factor.setter
  def factor(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["factor"] = value

def loop_unroll_and_jam(target, factor, *, loc=None, ip=None) -> _ods_ir.Operation:
  return LoopUnrollAndJamOp(target=target, factor=factor, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class LoopUnrollOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.loop.unroll"

  _ODS_REGIONS = (0, True)

  def __init__(self, target, factor, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(target)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["factor"] = (factor if (
    isinstance(factor, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(factor, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def factor(self):
    return self.operation.attributes["factor"]

  @factor.setter
  def factor(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["factor"] = value

def loop_unroll(target, factor, *, loc=None, ip=None) -> _ods_ir.Operation:
  return LoopUnrollOp(target=target, factor=factor, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class TakeAssumedBranchOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.scf.take_assumed_branch"

  _ODS_REGIONS = (0, True)

  def __init__(self, target, *, take_else_branch=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(target)
    _ods_context = _ods_get_default_loc_context(loc)
    if bool(take_else_branch): attributes["take_else_branch"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def take_else_branch(self):
    return "take_else_branch" in self.operation.attributes

  @take_else_branch.setter
  def take_else_branch(self, value):
    if bool(value):
      self.operation.attributes["take_else_branch"] = _ods_ir.UnitAttr.get()
    elif "take_else_branch" in self.operation.attributes:
      del self.operation.attributes["take_else_branch"]

  @take_else_branch.deleter
  def take_else_branch(self):
    del self.operation.attributes["take_else_branch"]

def scf_take_assumed_branch(target, *, take_else_branch=None, loc=None, ip=None) -> _ods_ir.Operation:
  return TakeAssumedBranchOp(target=target, take_else_branch=take_else_branch, loc=loc, ip=ip)
