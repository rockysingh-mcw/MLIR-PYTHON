
# Autogenerated by mlir-tblgen; don't manually edit.

from ._ods_common import _cext as _ods_cext
from ._ods_common import (
    equally_sized_accessor as _ods_equally_sized_accessor,
    get_default_loc_context as _ods_get_default_loc_context,
    get_op_result_or_op_results as _get_op_result_or_op_results,
    get_op_results_or_values as _get_op_results_or_values,
    segmented_accessor as _ods_segmented_accessor,
)
_ods_ir = _ods_cext.ir

import builtins
from typing import Sequence as _Sequence, Union as _Union


from ._transform_ops_gen import _Dialect

@_ods_cext.register_operation(_Dialect)
class ApplyDecomposeTensorPackUnpackPatternsOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.apply_patterns.linalg.decompose_pack_unpack"

  _ODS_REGIONS = (0, True)

  def __init__(self, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

def apply_patterns_linalg_decompose_pack_unpack(*, loc=None, ip=None) -> _ods_ir.Operation:
  return ApplyDecomposeTensorPackUnpackPatternsOp(loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ApplyDecomposeTensorPadPatternsOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.apply_patterns.linalg.decompose_pad"

  _ODS_REGIONS = (0, True)

  def __init__(self, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

def apply_patterns_linalg_decompose_pad(*, loc=None, ip=None) -> _ods_ir.Operation:
  return ApplyDecomposeTensorPadPatternsOp(loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ApplyEraseUnnecessaryInputsPatternsOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.apply_patterns.linalg.erase_unnecessary_inputs"

  _ODS_REGIONS = (0, True)

  def __init__(self, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

def apply_patterns_linalg_erase_unnecessary_inputs(*, loc=None, ip=None) -> _ods_ir.Operation:
  return ApplyEraseUnnecessaryInputsPatternsOp(loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ApplyFoldAddIntoDestPatternsOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.apply_patterns.linalg.fold_add_into_dest"

  _ODS_REGIONS = (0, True)

  def __init__(self, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

def apply_patterns_linalg_fold_add_into_dest(*, loc=None, ip=None) -> _ods_ir.Operation:
  return ApplyFoldAddIntoDestPatternsOp(loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ApplyFoldIntoPackAndUnpackPatternsOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.apply_patterns.tensor.fold_into_pack_and_unpack"

  _ODS_REGIONS = (0, True)

  def __init__(self, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

def apply_patterns_tensor_fold_into_pack_and_unpack(*, loc=None, ip=None) -> _ods_ir.Operation:
  return ApplyFoldIntoPackAndUnpackPatternsOp(loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ApplyFoldPackUnpackIntoEmptyPatternsOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.apply_patterns.linalg.fold_pack_unpack_into_empty"

  _ODS_REGIONS = (0, True)

  def __init__(self, *, fold_single_use_only=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    if fold_single_use_only is not None: attributes["fold_single_use_only"] = (fold_single_use_only if (
        isinstance(fold_single_use_only, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(fold_single_use_only, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def fold_single_use_only(self):
    return self.operation.attributes["fold_single_use_only"]

  @fold_single_use_only.setter
  def fold_single_use_only(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fold_single_use_only"] = value

def apply_patterns_linalg_fold_pack_unpack_into_empty(*, fold_single_use_only=None, loc=None, ip=None) -> _ods_ir.Operation:
  return ApplyFoldPackUnpackIntoEmptyPatternsOp(fold_single_use_only=fold_single_use_only, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ApplyFoldUnitExtentDimsViaReshapesPatternsOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.apply_patterns.linalg.fold_unit_extent_dims_via_reshapes"

  _ODS_REGIONS = (0, True)

  def __init__(self, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

def apply_patterns_linalg_fold_unit_extent_dims_via_reshapes(*, loc=None, ip=None) -> _ods_ir.Operation:
  return ApplyFoldUnitExtentDimsViaReshapesPatternsOp(loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ApplyFoldUnitExtentDimsViaSlicesPatternsOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.apply_patterns.linalg.fold_unit_extent_dims_via_slices"

  _ODS_REGIONS = (0, True)

  def __init__(self, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

def apply_patterns_linalg_fold_unit_extent_dims_via_slices(*, loc=None, ip=None) -> _ods_ir.Operation:
  return ApplyFoldUnitExtentDimsViaSlicesPatternsOp(loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ApplyPadVectorizationPatternsOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.apply_patterns.linalg.pad_vectorization"

  _ODS_REGIONS = (0, True)

  def __init__(self, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

def apply_patterns_linalg_pad_vectorization(*, loc=None, ip=None) -> _ods_ir.Operation:
  return ApplyPadVectorizationPatternsOp(loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ApplyTilingCanonicalizationPatternsOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.apply_patterns.linalg.tiling_canonicalization"

  _ODS_REGIONS = (0, True)

  def __init__(self, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

def apply_patterns_linalg_tiling_canonicalization(*, loc=None, ip=None) -> _ods_ir.Operation:
  return ApplyTilingCanonicalizationPatternsOp(loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class BufferizeToAllocationOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.structured.bufferize_to_allocation"

  _ODS_REGIONS = (0, True)

  def __init__(self, allocated_buffer, new_ops, target, *, memory_space=None, memcpy_op=None, alloc_op=None, bufferize_destination_only=None, emit_dealloc=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(target)
    _ods_context = _ods_get_default_loc_context(loc)
    if memory_space is not None: attributes["memory_space"] = (memory_space if (
        isinstance(memory_space, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('AnyAttr')) else
          _ods_ir.AttrBuilder.get('AnyAttr')(memory_space, context=_ods_context))
    if memcpy_op is not None: attributes["memcpy_op"] = (memcpy_op if (
        isinstance(memcpy_op, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(memcpy_op, context=_ods_context))
    if alloc_op is not None: attributes["alloc_op"] = (alloc_op if (
        isinstance(alloc_op, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(alloc_op, context=_ods_context))
    if bool(bufferize_destination_only): attributes["bufferize_destination_only"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    if bool(emit_dealloc): attributes["emit_dealloc"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    results.append(allocated_buffer)
    results.append(new_ops)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def memory_space(self):
    if "memory_space" not in self.operation.attributes:
      return None
    return self.operation.attributes["memory_space"]

  @memory_space.setter
  def memory_space(self, value):
    if value is not None:
      self.operation.attributes["memory_space"] = value
    elif "memory_space" in self.operation.attributes:
      del self.operation.attributes["memory_space"]

  @memory_space.deleter
  def memory_space(self):
    del self.operation.attributes["memory_space"]

  @builtins.property
  def memcpy_op(self):
    return self.operation.attributes["memcpy_op"]

  @memcpy_op.setter
  def memcpy_op(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["memcpy_op"] = value

  @builtins.property
  def alloc_op(self):
    return self.operation.attributes["alloc_op"]

  @alloc_op.setter
  def alloc_op(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["alloc_op"] = value

  @builtins.property
  def bufferize_destination_only(self):
    return "bufferize_destination_only" in self.operation.attributes

  @bufferize_destination_only.setter
  def bufferize_destination_only(self, value):
    if bool(value):
      self.operation.attributes["bufferize_destination_only"] = _ods_ir.UnitAttr.get()
    elif "bufferize_destination_only" in self.operation.attributes:
      del self.operation.attributes["bufferize_destination_only"]

  @bufferize_destination_only.deleter
  def bufferize_destination_only(self):
    del self.operation.attributes["bufferize_destination_only"]

  @builtins.property
  def emit_dealloc(self):
    return "emit_dealloc" in self.operation.attributes

  @emit_dealloc.setter
  def emit_dealloc(self, value):
    if bool(value):
      self.operation.attributes["emit_dealloc"] = _ods_ir.UnitAttr.get()
    elif "emit_dealloc" in self.operation.attributes:
      del self.operation.attributes["emit_dealloc"]

  @emit_dealloc.deleter
  def emit_dealloc(self):
    del self.operation.attributes["emit_dealloc"]

  @builtins.property
  def allocated_buffer(self):
    return self.operation.results[0]

  @builtins.property
  def new_ops(self):
    return self.operation.results[1]

def structured_bufferize_to_allocation(allocated_buffer, new_ops, target, *, memory_space=None, memcpy_op=None, alloc_op=None, bufferize_destination_only=None, emit_dealloc=None, loc=None, ip=None) -> _Sequence[_ods_ir.Value]:
  return BufferizeToAllocationOp(allocated_buffer=allocated_buffer, new_ops=new_ops, target=target, memory_space=memory_space, memcpy_op=memcpy_op, alloc_op=alloc_op, bufferize_destination_only=bufferize_destination_only, emit_dealloc=emit_dealloc, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class ContinuousTileSizesOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.structured.continuous_tile_sizes"

  _ODS_REGIONS = (0, True)

  def __init__(self, tile_sizes, chunk_sizes, target, dimension, target_size, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(target)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dimension"] = (dimension if (
    isinstance(dimension, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(dimension, context=_ods_context))
    attributes["target_size"] = (target_size if (
    isinstance(target_size, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(target_size, context=_ods_context))
    results.append(tile_sizes)
    results.append(chunk_sizes)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def dimension(self):
    return self.operation.attributes["dimension"]

  @dimension.setter
  def dimension(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dimension"] = value

  @builtins.property
  def target_size(self):
    return self.operation.attributes["target_size"]

  @target_size.setter
  def target_size(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["target_size"] = value

  @builtins.property
  def tile_sizes(self):
    return self.operation.results[0]

  @builtins.property
  def chunk_sizes(self):
    return self.operation.results[1]

def structured_continuous_tile_sizes(tile_sizes, chunk_sizes, target, dimension, target_size, *, loc=None, ip=None) -> _Sequence[_ods_ir.Value]:
  return ContinuousTileSizesOp(tile_sizes=tile_sizes, chunk_sizes=chunk_sizes, target=target, dimension=dimension, target_size=target_size, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class ConvertConv2DToImg2ColOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.structured.convert_conv2d_to_img2col"

  _ODS_REGIONS = (0, True)

  def __init__(self, img2col_tensor, transformed, target, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(target)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(img2col_tensor)
    results.append(transformed)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def img2col_tensor(self):
    return self.operation.results[0]

  @builtins.property
  def transformed(self):
    return self.operation.results[1]

def structured_convert_conv2d_to_img2col(img2col_tensor, transformed, target, *, loc=None, ip=None) -> _Sequence[_ods_ir.Value]:
  return ConvertConv2DToImg2ColOp(img2col_tensor=img2col_tensor, transformed=transformed, target=target, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class ConvertToLoopsOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.structured.convert_to_loops"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, target, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(target)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def structured_convert_to_loops(result, target, *, loc=None, ip=None) -> _ods_ir.Value:
  return ConvertToLoopsOp(result=result, target=target, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class DecomposeInterfaceOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.structured.decompose_interface"

  _ODS_REGIONS = (0, True)

  def __init__(self, transformed, target, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(target)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(transformed)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def transformed(self):
    return self.operation.results[0]

def structured_decompose_interface(transformed, target, *, loc=None, ip=None) -> _ods_ir.Value:
  return DecomposeInterfaceOp(transformed=transformed, target=target, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class DecomposeOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.structured.decompose"

  _ODS_REGIONS = (0, True)

  def __init__(self, transformed, target, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(target)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(transformed)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def transformed(self):
    return self.operation.results[0]

def structured_decompose(transformed, target, *, loc=None, ip=None) -> _ods_ir.Value:
  return DecomposeOp(transformed=transformed, target=target, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class DecomposeWinogradOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.structured.decompose_winograd_op"

  _ODS_REGIONS = (0, True)

  def __init__(self, transformed, target, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(target)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(transformed)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def transformed(self):
    return self.operation.results[0]

def structured_decompose_winograd_op(transformed, target, *, loc=None, ip=None) -> _ods_ir.Value:
  return DecomposeWinogradOp(transformed=transformed, target=target, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class EliminateLinalgOpAnchoredEmptyTensorsOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.structured.eliminate_empty_tensors"

  _ODS_REGIONS = (0, True)

  def __init__(self, target, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(target)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self):
    return self.operation.operands[0]

def structured_eliminate_empty_tensors(target, *, loc=None, ip=None) -> _ods_ir.Operation:
  return EliminateLinalgOpAnchoredEmptyTensorsOp(target=target, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class FlattenElementwiseLinalgOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.structured.flatten_elementwise"

  _ODS_REGIONS = (0, True)

  def __init__(self, transformed, target, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(target)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(transformed)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def transformed(self):
    return self.operation.results[0]

def structured_flatten_elementwise(transformed, target, *, loc=None, ip=None) -> _ods_ir.Value:
  return FlattenElementwiseLinalgOp(transformed=transformed, target=target, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FuseIntoContainingOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.structured.fuse_into_containing_op"

  _ODS_REGIONS = (0, True)

  def __init__(self, fused_op, new_containing_op, producer_op, containing_op, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(producer_op)
    operands.append(containing_op)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(fused_op)
    results.append(new_containing_op)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def producer_op(self):
    return self.operation.operands[0]

  @builtins.property
  def containing_op(self):
    return self.operation.operands[1]

  @builtins.property
  def fused_op(self):
    return self.operation.results[0]

  @builtins.property
  def new_containing_op(self):
    return self.operation.results[1]

def structured_fuse_into_containing_op(fused_op, new_containing_op, producer_op, containing_op, *, loc=None, ip=None) -> _Sequence[_ods_ir.Value]:
  return FuseIntoContainingOp(fused_op=fused_op, new_containing_op=new_containing_op, producer_op=producer_op, containing_op=containing_op, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class FuseOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.structured.fuse"

  _ODS_REGIONS = (0, True)

  def __init__(self, transformed, loops, target, *, tile_sizes=None, tile_interchange=None, apply_cleanup=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(target)
    _ods_context = _ods_get_default_loc_context(loc)
    if tile_sizes is not None: attributes["tile_sizes"] = (tile_sizes if (
        isinstance(tile_sizes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(tile_sizes, context=_ods_context))
    if tile_interchange is not None: attributes["tile_interchange"] = (tile_interchange if (
        isinstance(tile_interchange, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(tile_interchange, context=_ods_context))
    if apply_cleanup is not None: attributes["apply_cleanup"] = (apply_cleanup if (
        isinstance(apply_cleanup, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(apply_cleanup, context=_ods_context))
    results.append(transformed)
    results.extend(loops)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def tile_sizes(self):
    return self.operation.attributes["tile_sizes"]

  @tile_sizes.setter
  def tile_sizes(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["tile_sizes"] = value

  @builtins.property
  def tile_interchange(self):
    return self.operation.attributes["tile_interchange"]

  @tile_interchange.setter
  def tile_interchange(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["tile_interchange"] = value

  @builtins.property
  def apply_cleanup(self):
    return self.operation.attributes["apply_cleanup"]

  @apply_cleanup.setter
  def apply_cleanup(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["apply_cleanup"] = value

  @builtins.property
  def transformed(self):
    return self.operation.results[0]

  @builtins.property
  def loops(self):
    _ods_variadic_group_length = len(self.operation.results) - 2 + 1
    return self.operation.results[1:1 + _ods_variadic_group_length]

def structured_fuse(transformed, loops, target, *, tile_sizes=None, tile_interchange=None, apply_cleanup=None, loc=None, ip=None) -> _Sequence[_ods_ir.Value]:
  return _get_op_result_or_op_results(FuseOp(transformed=transformed, loops=loops, target=target, tile_sizes=tile_sizes, tile_interchange=tile_interchange, apply_cleanup=apply_cleanup, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class GeneralizeOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.structured.generalize"

  _ODS_REGIONS = (0, True)

  def __init__(self, transformed, target, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(target)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(transformed)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def transformed(self):
    return self.operation.results[0]

def structured_generalize(transformed, target, *, loc=None, ip=None) -> _ods_ir.Value:
  return GeneralizeOp(transformed=transformed, target=target, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class HoistPadBuildPackingLoopNestOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.structured.hoist_pad.build_packing_loop_nest"

  _ODS_REGIONS = (0, True)

  def __init__(self, packing_loop, target, loop, *, transpose=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(target)
    operands.append(loop)
    _ods_context = _ods_get_default_loc_context(loc)
    if transpose is not None: attributes["transpose"] = (transpose if (
        isinstance(transpose, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DenseI64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('DenseI64ArrayAttr')(transpose, context=_ods_context))
    results.append(packing_loop)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def loop(self):
    return self.operation.operands[1]

  @builtins.property
  def transpose(self):
    return self.operation.attributes["transpose"]

  @transpose.setter
  def transpose(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["transpose"] = value

  @builtins.property
  def packing_loop(self):
    return self.operation.results[0]

def structured_hoist_pad_build_packing_loop_nest(packing_loop, target, loop, *, transpose=None, loc=None, ip=None) -> _ods_ir.Value:
  return HoistPadBuildPackingLoopNestOp(packing_loop=packing_loop, target=target, loop=loop, transpose=transpose, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class HoistPadOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.structured.hoist_pad"

  _ODS_REGIONS = (0, True)

  def __init__(self, transformed, target, num_loops, *, transpose=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(target)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["num_loops"] = (num_loops if (
    isinstance(num_loops, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(num_loops, context=_ods_context))
    if transpose is not None: attributes["transpose"] = (transpose if (
        isinstance(transpose, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DenseI64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('DenseI64ArrayAttr')(transpose, context=_ods_context))
    results.append(transformed)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def num_loops(self):
    return self.operation.attributes["num_loops"]

  @num_loops.setter
  def num_loops(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["num_loops"] = value

  @builtins.property
  def transpose(self):
    return self.operation.attributes["transpose"]

  @transpose.setter
  def transpose(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["transpose"] = value

  @builtins.property
  def transformed(self):
    return self.operation.results[0]

def structured_hoist_pad(transformed, target, num_loops, *, transpose=None, loc=None, ip=None) -> _ods_ir.Value:
  return HoistPadOp(transformed=transformed, target=target, num_loops=num_loops, transpose=transpose, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class HoistRedundantVectorBroadcastsOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.structured.hoist_redundant_vector_broadcasts"

  _ODS_REGIONS = (0, True)

  def __init__(self, transformed, target, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(target)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(transformed)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def transformed(self):
    return self.operation.results[0]

def structured_hoist_redundant_vector_broadcasts(transformed, target, *, loc=None, ip=None) -> _ods_ir.Value:
  return HoistRedundantVectorBroadcastsOp(transformed=transformed, target=target, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class HoistRedundantVectorTransfersOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.structured.hoist_redundant_vector_transfers"

  _ODS_REGIONS = (0, True)

  def __init__(self, transformed, target, *, verify_non_zero_trip=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(target)
    _ods_context = _ods_get_default_loc_context(loc)
    if bool(verify_non_zero_trip): attributes["verify_non_zero_trip"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    results.append(transformed)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def verify_non_zero_trip(self):
    return "verify_non_zero_trip" in self.operation.attributes

  @verify_non_zero_trip.setter
  def verify_non_zero_trip(self, value):
    if bool(value):
      self.operation.attributes["verify_non_zero_trip"] = _ods_ir.UnitAttr.get()
    elif "verify_non_zero_trip" in self.operation.attributes:
      del self.operation.attributes["verify_non_zero_trip"]

  @verify_non_zero_trip.deleter
  def verify_non_zero_trip(self):
    del self.operation.attributes["verify_non_zero_trip"]

  @builtins.property
  def transformed(self):
    return self.operation.results[0]

def structured_hoist_redundant_vector_transfers(transformed, target, *, verify_non_zero_trip=None, loc=None, ip=None) -> _ods_ir.Value:
  return HoistRedundantVectorTransfersOp(transformed=transformed, target=target, verify_non_zero_trip=verify_non_zero_trip, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class InsertSliceToCopyOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.structured.insert_slice_to_copy"

  _ODS_REGIONS = (0, True)

  def __init__(self, transformed, target, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(target)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(transformed)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def transformed(self):
    return self.operation.results[0]

def structured_insert_slice_to_copy(transformed, target, *, loc=None, ip=None) -> _ods_ir.Value:
  return InsertSliceToCopyOp(transformed=transformed, target=target, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class InterchangeOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.structured.interchange"

  _ODS_REGIONS = (0, True)

  def __init__(self, transformed, target, *, iterator_interchange=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(target)
    _ods_context = _ods_get_default_loc_context(loc)
    if iterator_interchange is not None: attributes["iterator_interchange"] = (iterator_interchange if (
        isinstance(iterator_interchange, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DenseI64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('DenseI64ArrayAttr')(iterator_interchange, context=_ods_context))
    results.append(transformed)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def iterator_interchange(self):
    if "iterator_interchange" not in self.operation.attributes:
      return None
    return self.operation.attributes["iterator_interchange"]

  @iterator_interchange.setter
  def iterator_interchange(self, value):
    if value is not None:
      self.operation.attributes["iterator_interchange"] = value
    elif "iterator_interchange" in self.operation.attributes:
      del self.operation.attributes["iterator_interchange"]

  @iterator_interchange.deleter
  def iterator_interchange(self):
    del self.operation.attributes["iterator_interchange"]

  @builtins.property
  def transformed(self):
    return self.operation.results[0]

def structured_interchange(transformed, target, *, iterator_interchange=None, loc=None, ip=None) -> _ods_ir.Value:
  return InterchangeOp(transformed=transformed, target=target, iterator_interchange=iterator_interchange, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class LinalgCopyToMemrefOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.structured.linalg_copy_to_memref"

  _ODS_REGIONS = (0, True)

  def __init__(self, transformed, target, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(target)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(transformed)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def transformed(self):
    return self.operation.results[0]

def structured_linalg_copy_to_memref(transformed, target, *, loc=None, ip=None) -> _ods_ir.Value:
  return LinalgCopyToMemrefOp(transformed=transformed, target=target, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class LowerPackOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.structured.lower_pack"

  _ODS_REGIONS = (0, True)

  def __init__(self, pad_op, expand_shape_op, transpose_op, target, *, lowerPadLikeWithInsertSlice=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(target)
    _ods_context = _ods_get_default_loc_context(loc)
    if lowerPadLikeWithInsertSlice is not None: attributes["lowerPadLikeWithInsertSlice"] = (lowerPadLikeWithInsertSlice if (
        isinstance(lowerPadLikeWithInsertSlice, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(lowerPadLikeWithInsertSlice, context=_ods_context))
    results.append(pad_op)
    results.append(expand_shape_op)
    results.append(transpose_op)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def lowerPadLikeWithInsertSlice(self):
    return self.operation.attributes["lowerPadLikeWithInsertSlice"]

  @lowerPadLikeWithInsertSlice.setter
  def lowerPadLikeWithInsertSlice(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["lowerPadLikeWithInsertSlice"] = value

  @builtins.property
  def pad_op(self):
    return self.operation.results[0]

  @builtins.property
  def expand_shape_op(self):
    return self.operation.results[1]

  @builtins.property
  def transpose_op(self):
    return self.operation.results[2]

def structured_lower_pack(pad_op, expand_shape_op, transpose_op, target, *, lower_pad_like_with_insert_slice=None, loc=None, ip=None) -> _Sequence[_ods_ir.Value]:
  return LowerPackOp(pad_op=pad_op, expand_shape_op=expand_shape_op, transpose_op=transpose_op, target=target, lowerPadLikeWithInsertSlice=lower_pad_like_with_insert_slice, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class LowerUnPackOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.structured.lower_unpack"

  _ODS_REGIONS = (0, True)

  def __init__(self, empty_op, transpose_op, collapse_shape_op, extract_slice_op, target, *, lowerUnpadLikeWithExtractSlice=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(target)
    _ods_context = _ods_get_default_loc_context(loc)
    if lowerUnpadLikeWithExtractSlice is not None: attributes["lowerUnpadLikeWithExtractSlice"] = (lowerUnpadLikeWithExtractSlice if (
        isinstance(lowerUnpadLikeWithExtractSlice, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(lowerUnpadLikeWithExtractSlice, context=_ods_context))
    results.append(empty_op)
    results.append(transpose_op)
    results.append(collapse_shape_op)
    results.append(extract_slice_op)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def lowerUnpadLikeWithExtractSlice(self):
    return self.operation.attributes["lowerUnpadLikeWithExtractSlice"]

  @lowerUnpadLikeWithExtractSlice.setter
  def lowerUnpadLikeWithExtractSlice(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["lowerUnpadLikeWithExtractSlice"] = value

  @builtins.property
  def empty_op(self):
    return self.operation.results[0]

  @builtins.property
  def transpose_op(self):
    return self.operation.results[1]

  @builtins.property
  def collapse_shape_op(self):
    return self.operation.results[2]

  @builtins.property
  def extract_slice_op(self):
    return self.operation.results[3]

def structured_lower_unpack(empty_op, transpose_op, collapse_shape_op, extract_slice_op, target, *, lower_unpad_like_with_extract_slice=None, loc=None, ip=None) -> _Sequence[_ods_ir.Value]:
  return LowerUnPackOp(empty_op=empty_op, transpose_op=transpose_op, collapse_shape_op=collapse_shape_op, extract_slice_op=extract_slice_op, target=target, lowerUnpadLikeWithExtractSlice=lower_unpad_like_with_extract_slice, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class MapCopyToThreadsOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.structured.gpu.map_copy_to_threads"

  _ODS_REGIONS = (0, True)

  def __init__(self, forall_op, tiled_op, target, total_num_threads, desired_bit_alignment, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(target)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["total_num_threads"] = (total_num_threads if (
    isinstance(total_num_threads, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(total_num_threads, context=_ods_context))
    attributes["desired_bit_alignment"] = (desired_bit_alignment if (
    isinstance(desired_bit_alignment, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(desired_bit_alignment, context=_ods_context))
    results.append(forall_op)
    results.append(tiled_op)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def total_num_threads(self):
    return self.operation.attributes["total_num_threads"]

  @total_num_threads.setter
  def total_num_threads(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["total_num_threads"] = value

  @builtins.property
  def desired_bit_alignment(self):
    return self.operation.attributes["desired_bit_alignment"]

  @desired_bit_alignment.setter
  def desired_bit_alignment(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["desired_bit_alignment"] = value

  @builtins.property
  def forall_op(self):
    return self.operation.results[0]

  @builtins.property
  def tiled_op(self):
    return self.operation.results[1]

def structured_gpu_map_copy_to_threads(forall_op, tiled_op, target, total_num_threads, desired_bit_alignment, *, loc=None, ip=None) -> _Sequence[_ods_ir.Value]:
  return MapCopyToThreadsOp(forall_op=forall_op, tiled_op=tiled_op, target=target, total_num_threads=total_num_threads, desired_bit_alignment=desired_bit_alignment, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class MatchOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.structured.match"

  _ODS_REGIONS = (0, True)

  def __init__(self, results_, target, *, ops=None, interface=None, op_attrs=None, filter_result_type=None, filter_operand_types=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(target)
    _ods_context = _ods_get_default_loc_context(loc)
    if ops is not None: attributes["ops"] = (ops if (
        isinstance(ops, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrArrayAttr')) else
          _ods_ir.AttrBuilder.get('StrArrayAttr')(ops, context=_ods_context))
    if interface is not None: attributes["interface"] = (interface if (
        isinstance(interface, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MatchInterfaceEnum')) else
          _ods_ir.AttrBuilder.get('MatchInterfaceEnum')(interface, context=_ods_context))
    if op_attrs is not None: attributes["op_attrs"] = (op_attrs if (
        isinstance(op_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictionaryAttr')) else
          _ods_ir.AttrBuilder.get('DictionaryAttr')(op_attrs, context=_ods_context))
    if filter_result_type is not None: attributes["filter_result_type"] = (filter_result_type if (
        isinstance(filter_result_type, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('TypeAttr')) else
          _ods_ir.AttrBuilder.get('TypeAttr')(filter_result_type, context=_ods_context))
    if filter_operand_types is not None: attributes["filter_operand_types"] = (filter_operand_types if (
        isinstance(filter_operand_types, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('TypeArrayAttr')) else
          _ods_ir.AttrBuilder.get('TypeArrayAttr')(filter_operand_types, context=_ods_context))
    results.append(results_)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def ops(self):
    if "ops" not in self.operation.attributes:
      return None
    return self.operation.attributes["ops"]

  @ops.setter
  def ops(self, value):
    if value is not None:
      self.operation.attributes["ops"] = value
    elif "ops" in self.operation.attributes:
      del self.operation.attributes["ops"]

  @ops.deleter
  def ops(self):
    del self.operation.attributes["ops"]

  @builtins.property
  def interface(self):
    if "interface" not in self.operation.attributes:
      return None
    return self.operation.attributes["interface"]

  @interface.setter
  def interface(self, value):
    if value is not None:
      self.operation.attributes["interface"] = value
    elif "interface" in self.operation.attributes:
      del self.operation.attributes["interface"]

  @interface.deleter
  def interface(self):
    del self.operation.attributes["interface"]

  @builtins.property
  def op_attrs(self):
    if "op_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["op_attrs"]

  @op_attrs.setter
  def op_attrs(self, value):
    if value is not None:
      self.operation.attributes["op_attrs"] = value
    elif "op_attrs" in self.operation.attributes:
      del self.operation.attributes["op_attrs"]

  @op_attrs.deleter
  def op_attrs(self):
    del self.operation.attributes["op_attrs"]

  @builtins.property
  def filter_result_type(self):
    if "filter_result_type" not in self.operation.attributes:
      return None
    return self.operation.attributes["filter_result_type"]

  @filter_result_type.setter
  def filter_result_type(self, value):
    if value is not None:
      self.operation.attributes["filter_result_type"] = value
    elif "filter_result_type" in self.operation.attributes:
      del self.operation.attributes["filter_result_type"]

  @filter_result_type.deleter
  def filter_result_type(self):
    del self.operation.attributes["filter_result_type"]

  @builtins.property
  def filter_operand_types(self):
    if "filter_operand_types" not in self.operation.attributes:
      return None
    return self.operation.attributes["filter_operand_types"]

  @filter_operand_types.setter
  def filter_operand_types(self, value):
    if value is not None:
      self.operation.attributes["filter_operand_types"] = value
    elif "filter_operand_types" in self.operation.attributes:
      del self.operation.attributes["filter_operand_types"]

  @filter_operand_types.deleter
  def filter_operand_types(self):
    del self.operation.attributes["filter_operand_types"]

  @builtins.property
  def results_(self):
    return self.operation.results[0]

def structured_match(results_, target, *, ops=None, interface=None, op_attrs=None, filter_result_type=None, filter_operand_types=None, loc=None, ip=None) -> _ods_ir.Value:
  return MatchOp(results_=results_, target=target, ops=ops, interface=interface, op_attrs=op_attrs, filter_result_type=filter_result_type, filter_operand_types=filter_operand_types, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MultiTileSizesOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.structured.multitile_sizes"

  _ODS_REGIONS = (0, True)

  def __init__(self, low_size, high_size, split_point, target, dimension, target_size, *, divisor=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(target)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dimension"] = (dimension if (
    isinstance(dimension, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(dimension, context=_ods_context))
    attributes["target_size"] = (target_size if (
    isinstance(target_size, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(target_size, context=_ods_context))
    if divisor is not None: attributes["divisor"] = (divisor if (
        isinstance(divisor, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(divisor, context=_ods_context))
    results.append(low_size)
    results.append(high_size)
    results.append(split_point)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def dimension(self):
    return self.operation.attributes["dimension"]

  @dimension.setter
  def dimension(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dimension"] = value

  @builtins.property
  def target_size(self):
    return self.operation.attributes["target_size"]

  @target_size.setter
  def target_size(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["target_size"] = value

  @builtins.property
  def divisor(self):
    return self.operation.attributes["divisor"]

  @divisor.setter
  def divisor(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["divisor"] = value

  @builtins.property
  def low_size(self):
    return self.operation.results[0]

  @builtins.property
  def high_size(self):
    return self.operation.results[1]

  @builtins.property
  def split_point(self):
    return self.operation.results[2]

def structured_multitile_sizes(low_size, high_size, split_point, target, dimension, target_size, *, divisor=None, loc=None, ip=None) -> _Sequence[_ods_ir.Value]:
  return MultiTileSizesOp(low_size=low_size, high_size=high_size, split_point=split_point, target=target, dimension=dimension, target_size=target_size, divisor=divisor, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class PackGreedilyOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.structured.pack_greedily"

  _ODS_REGIONS = (0, True)

  def __init__(self, packed_op, target, matmul_packed_sizes, *, static_matmul_packed_sizes=None, matmul_padded_sizes_next_multiple_of=None, matmul_inner_dims_order=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(target)
    operands.extend(_get_op_results_or_values(matmul_packed_sizes))
    _ods_context = _ods_get_default_loc_context(loc)
    if static_matmul_packed_sizes is not None: attributes["static_matmul_packed_sizes"] = (static_matmul_packed_sizes if (
        isinstance(static_matmul_packed_sizes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DenseI64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('DenseI64ArrayAttr')(static_matmul_packed_sizes, context=_ods_context))
    if matmul_padded_sizes_next_multiple_of is not None: attributes["matmul_padded_sizes_next_multiple_of"] = (matmul_padded_sizes_next_multiple_of if (
        isinstance(matmul_padded_sizes_next_multiple_of, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DenseI64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('DenseI64ArrayAttr')(matmul_padded_sizes_next_multiple_of, context=_ods_context))
    if matmul_inner_dims_order is not None: attributes["matmul_inner_dims_order"] = (matmul_inner_dims_order if (
        isinstance(matmul_inner_dims_order, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DenseI64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('DenseI64ArrayAttr')(matmul_inner_dims_order, context=_ods_context))
    results.append(packed_op)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def matmul_packed_sizes(self):
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[1:1 + _ods_variadic_group_length]

  @builtins.property
  def static_matmul_packed_sizes(self):
    return self.operation.attributes["static_matmul_packed_sizes"]

  @static_matmul_packed_sizes.setter
  def static_matmul_packed_sizes(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["static_matmul_packed_sizes"] = value

  @builtins.property
  def matmul_padded_sizes_next_multiple_of(self):
    return self.operation.attributes["matmul_padded_sizes_next_multiple_of"]

  @matmul_padded_sizes_next_multiple_of.setter
  def matmul_padded_sizes_next_multiple_of(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["matmul_padded_sizes_next_multiple_of"] = value

  @builtins.property
  def matmul_inner_dims_order(self):
    return self.operation.attributes["matmul_inner_dims_order"]

  @matmul_inner_dims_order.setter
  def matmul_inner_dims_order(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["matmul_inner_dims_order"] = value

  @builtins.property
  def packed_op(self):
    return self.operation.results[0]

def structured_pack_greedily(packed_op, target, matmul_packed_sizes, *, static_matmul_packed_sizes=None, matmul_padded_sizes_next_multiple_of=None, matmul_inner_dims_order=None, loc=None, ip=None) -> _ods_ir.Value:
  return PackGreedilyOp(packed_op=packed_op, target=target, matmul_packed_sizes=matmul_packed_sizes, static_matmul_packed_sizes=static_matmul_packed_sizes, matmul_padded_sizes_next_multiple_of=matmul_padded_sizes_next_multiple_of, matmul_inner_dims_order=matmul_inner_dims_order, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class PackOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.structured.pack"

  _ODS_REGIONS = (0, True)

  def __init__(self, packed_op, target, packed_sizes, *, static_packed_sizes=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(target)
    operands.extend(_get_op_results_or_values(packed_sizes))
    _ods_context = _ods_get_default_loc_context(loc)
    if static_packed_sizes is not None: attributes["static_packed_sizes"] = (static_packed_sizes if (
        isinstance(static_packed_sizes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DenseI64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('DenseI64ArrayAttr')(static_packed_sizes, context=_ods_context))
    results.append(packed_op)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def packed_sizes(self):
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[1:1 + _ods_variadic_group_length]

  @builtins.property
  def static_packed_sizes(self):
    return self.operation.attributes["static_packed_sizes"]

  @static_packed_sizes.setter
  def static_packed_sizes(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["static_packed_sizes"] = value

  @builtins.property
  def packed_op(self):
    return self.operation.results[0]

def structured_pack(packed_op, target, packed_sizes, *, static_packed_sizes=None, loc=None, ip=None) -> _ods_ir.Value:
  return PackOp(packed_op=packed_op, target=target, packed_sizes=packed_sizes, static_packed_sizes=static_packed_sizes, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class PackTransposeOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.structured.pack_transpose"

  _ODS_REGIONS = (0, True)

  def __init__(self, packed_op, pack_op, un_pack_op, target_pack_or_un_pack_op, target_linalg_op, *, outer_perm=None, inner_perm=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(target_pack_or_un_pack_op)
    operands.append(target_linalg_op)
    _ods_context = _ods_get_default_loc_context(loc)
    if outer_perm is not None: attributes["outer_perm"] = (outer_perm if (
        isinstance(outer_perm, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DenseI64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('DenseI64ArrayAttr')(outer_perm, context=_ods_context))
    if inner_perm is not None: attributes["inner_perm"] = (inner_perm if (
        isinstance(inner_perm, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DenseI64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('DenseI64ArrayAttr')(inner_perm, context=_ods_context))
    results.append(packed_op)
    results.append(pack_op)
    results.append(un_pack_op)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target_pack_or_un_pack_op(self):
    return self.operation.operands[0]

  @builtins.property
  def target_linalg_op(self):
    return self.operation.operands[1]

  @builtins.property
  def outer_perm(self):
    if "outer_perm" not in self.operation.attributes:
      return None
    return self.operation.attributes["outer_perm"]

  @outer_perm.setter
  def outer_perm(self, value):
    if value is not None:
      self.operation.attributes["outer_perm"] = value
    elif "outer_perm" in self.operation.attributes:
      del self.operation.attributes["outer_perm"]

  @outer_perm.deleter
  def outer_perm(self):
    del self.operation.attributes["outer_perm"]

  @builtins.property
  def inner_perm(self):
    if "inner_perm" not in self.operation.attributes:
      return None
    return self.operation.attributes["inner_perm"]

  @inner_perm.setter
  def inner_perm(self, value):
    if value is not None:
      self.operation.attributes["inner_perm"] = value
    elif "inner_perm" in self.operation.attributes:
      del self.operation.attributes["inner_perm"]

  @inner_perm.deleter
  def inner_perm(self):
    del self.operation.attributes["inner_perm"]

  @builtins.property
  def packed_op(self):
    return self.operation.results[0]

  @builtins.property
  def pack_op(self):
    return self.operation.results[1]

  @builtins.property
  def un_pack_op(self):
    return self.operation.results[2]

def structured_pack_transpose(packed_op, pack_op, un_pack_op, target_pack_or_un_pack_op, target_linalg_op, *, outer_perm=None, inner_perm=None, loc=None, ip=None) -> _Sequence[_ods_ir.Value]:
  return PackTransposeOp(packed_op=packed_op, pack_op=pack_op, un_pack_op=un_pack_op, target_pack_or_un_pack_op=target_pack_or_un_pack_op, target_linalg_op=target_linalg_op, outer_perm=outer_perm, inner_perm=inner_perm, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class PadOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.structured.pad"

  _ODS_REGIONS = (0, True)

  def __init__(self, padded, pad, copy, target, pad_to_multiple_of, *, padding_values=None, padding_dimensions=None, static_pad_to_multiple_of=None, nofold_flags=None, transpose_paddings=None, copy_back_op=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(target)
    operands.extend(_get_op_results_or_values(pad_to_multiple_of))
    _ods_context = _ods_get_default_loc_context(loc)
    if padding_values is not None: attributes["padding_values"] = (padding_values if (
        isinstance(padding_values, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('ArrayAttr')) else
          _ods_ir.AttrBuilder.get('ArrayAttr')(padding_values, context=_ods_context))
    if padding_dimensions is not None: attributes["padding_dimensions"] = (padding_dimensions if (
        isinstance(padding_dimensions, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(padding_dimensions, context=_ods_context))
    if static_pad_to_multiple_of is not None: attributes["static_pad_to_multiple_of"] = (static_pad_to_multiple_of if (
        isinstance(static_pad_to_multiple_of, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DenseI64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('DenseI64ArrayAttr')(static_pad_to_multiple_of, context=_ods_context))
    if nofold_flags is not None: attributes["nofold_flags"] = (nofold_flags if (
        isinstance(nofold_flags, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(nofold_flags, context=_ods_context))
    if transpose_paddings is not None: attributes["transpose_paddings"] = (transpose_paddings if (
        isinstance(transpose_paddings, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('anonymous_483')) else
          _ods_ir.AttrBuilder.get('anonymous_483')(transpose_paddings, context=_ods_context))
    if copy_back_op is not None: attributes["copy_back_op"] = (copy_back_op if (
        isinstance(copy_back_op, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(copy_back_op, context=_ods_context))
    results.append(padded)
    results.append(pad)
    results.append(copy)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def pad_to_multiple_of(self):
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[1:1 + _ods_variadic_group_length]

  @builtins.property
  def padding_values(self):
    return self.operation.attributes["padding_values"]

  @padding_values.setter
  def padding_values(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["padding_values"] = value

  @builtins.property
  def padding_dimensions(self):
    return self.operation.attributes["padding_dimensions"]

  @padding_dimensions.setter
  def padding_dimensions(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["padding_dimensions"] = value

  @builtins.property
  def static_pad_to_multiple_of(self):
    if "static_pad_to_multiple_of" not in self.operation.attributes:
      return None
    return self.operation.attributes["static_pad_to_multiple_of"]

  @static_pad_to_multiple_of.setter
  def static_pad_to_multiple_of(self, value):
    if value is not None:
      self.operation.attributes["static_pad_to_multiple_of"] = value
    elif "static_pad_to_multiple_of" in self.operation.attributes:
      del self.operation.attributes["static_pad_to_multiple_of"]

  @static_pad_to_multiple_of.deleter
  def static_pad_to_multiple_of(self):
    del self.operation.attributes["static_pad_to_multiple_of"]

  @builtins.property
  def nofold_flags(self):
    return self.operation.attributes["nofold_flags"]

  @nofold_flags.setter
  def nofold_flags(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["nofold_flags"] = value

  @builtins.property
  def transpose_paddings(self):
    return self.operation.attributes["transpose_paddings"]

  @transpose_paddings.setter
  def transpose_paddings(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["transpose_paddings"] = value

  @builtins.property
  def copy_back_op(self):
    return self.operation.attributes["copy_back_op"]

  @copy_back_op.setter
  def copy_back_op(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["copy_back_op"] = value

  @builtins.property
  def padded(self):
    return self.operation.results[0]

  @builtins.property
  def pad(self):
    return self.operation.results[1]

  @builtins.property
  def copy(self):
    return self.operation.results[2]

def structured_pad(padded, pad, copy, target, pad_to_multiple_of, *, padding_values=None, padding_dimensions=None, static_pad_to_multiple_of=None, nofold_flags=None, transpose_paddings=None, copy_back_op=None, loc=None, ip=None) -> _Sequence[_ods_ir.Value]:
  return PadOp(padded=padded, pad=pad, copy=copy, target=target, pad_to_multiple_of=pad_to_multiple_of, padding_values=padding_values, padding_dimensions=padding_dimensions, static_pad_to_multiple_of=static_pad_to_multiple_of, nofold_flags=nofold_flags, transpose_paddings=transpose_paddings, copy_back_op=copy_back_op, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class PromoteOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.structured.promote"

  _ODS_REGIONS = (0, True)

  def __init__(self, transformed, target, *, operands_to_promote=None, use_full_tile_buffers=None, use_full_tiles_by_default=None, use_alloca=None, memory_space=None, mapping=None, alignment=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(target)
    _ods_context = _ods_get_default_loc_context(loc)
    if operands_to_promote is not None: attributes["operands_to_promote"] = (operands_to_promote if (
        isinstance(operands_to_promote, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(operands_to_promote, context=_ods_context))
    if use_full_tile_buffers is not None: attributes["use_full_tile_buffers"] = (use_full_tile_buffers if (
        isinstance(use_full_tile_buffers, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolArrayAttr')) else
          _ods_ir.AttrBuilder.get('BoolArrayAttr')(use_full_tile_buffers, context=_ods_context))
    if bool(use_full_tiles_by_default): attributes["use_full_tiles_by_default"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    if bool(use_alloca): attributes["use_alloca"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    if memory_space is not None: attributes["memory_space"] = (memory_space if (
        isinstance(memory_space, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('AnyAttr')) else
          _ods_ir.AttrBuilder.get('AnyAttr')(memory_space, context=_ods_context))
    if mapping is not None: attributes["mapping"] = (mapping if (
        isinstance(mapping, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DeviceMappingArrayAttr')) else
          _ods_ir.AttrBuilder.get('DeviceMappingArrayAttr')(mapping, context=_ods_context))
    if alignment is not None: attributes["alignment"] = (alignment if (
        isinstance(alignment, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(alignment, context=_ods_context))
    results.append(transformed)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def operands_to_promote(self):
    return self.operation.attributes["operands_to_promote"]

  @operands_to_promote.setter
  def operands_to_promote(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["operands_to_promote"] = value

  @builtins.property
  def use_full_tile_buffers(self):
    return self.operation.attributes["use_full_tile_buffers"]

  @use_full_tile_buffers.setter
  def use_full_tile_buffers(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["use_full_tile_buffers"] = value

  @builtins.property
  def use_full_tiles_by_default(self):
    return "use_full_tiles_by_default" in self.operation.attributes

  @use_full_tiles_by_default.setter
  def use_full_tiles_by_default(self, value):
    if bool(value):
      self.operation.attributes["use_full_tiles_by_default"] = _ods_ir.UnitAttr.get()
    elif "use_full_tiles_by_default" in self.operation.attributes:
      del self.operation.attributes["use_full_tiles_by_default"]

  @use_full_tiles_by_default.deleter
  def use_full_tiles_by_default(self):
    del self.operation.attributes["use_full_tiles_by_default"]

  @builtins.property
  def use_alloca(self):
    return "use_alloca" in self.operation.attributes

  @use_alloca.setter
  def use_alloca(self, value):
    if bool(value):
      self.operation.attributes["use_alloca"] = _ods_ir.UnitAttr.get()
    elif "use_alloca" in self.operation.attributes:
      del self.operation.attributes["use_alloca"]

  @use_alloca.deleter
  def use_alloca(self):
    del self.operation.attributes["use_alloca"]

  @builtins.property
  def memory_space(self):
    if "memory_space" not in self.operation.attributes:
      return None
    return self.operation.attributes["memory_space"]

  @memory_space.setter
  def memory_space(self, value):
    if value is not None:
      self.operation.attributes["memory_space"] = value
    elif "memory_space" in self.operation.attributes:
      del self.operation.attributes["memory_space"]

  @memory_space.deleter
  def memory_space(self):
    del self.operation.attributes["memory_space"]

  @builtins.property
  def mapping(self):
    if "mapping" not in self.operation.attributes:
      return None
    return self.operation.attributes["mapping"]

  @mapping.setter
  def mapping(self, value):
    if value is not None:
      self.operation.attributes["mapping"] = value
    elif "mapping" in self.operation.attributes:
      del self.operation.attributes["mapping"]

  @mapping.deleter
  def mapping(self):
    del self.operation.attributes["mapping"]

  @builtins.property
  def alignment(self):
    if "alignment" not in self.operation.attributes:
      return None
    return self.operation.attributes["alignment"]

  @alignment.setter
  def alignment(self, value):
    if value is not None:
      self.operation.attributes["alignment"] = value
    elif "alignment" in self.operation.attributes:
      del self.operation.attributes["alignment"]

  @alignment.deleter
  def alignment(self):
    del self.operation.attributes["alignment"]

  @builtins.property
  def transformed(self):
    return self.operation.results[0]

def structured_promote(transformed, target, *, operands_to_promote=None, use_full_tile_buffers=None, use_full_tiles_by_default=None, use_alloca=None, memory_space=None, mapping=None, alignment=None, loc=None, ip=None) -> _ods_ir.Value:
  return PromoteOp(transformed=transformed, target=target, operands_to_promote=operands_to_promote, use_full_tile_buffers=use_full_tile_buffers, use_full_tiles_by_default=use_full_tiles_by_default, use_alloca=use_alloca, memory_space=memory_space, mapping=mapping, alignment=alignment, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ReplaceOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.structured.replace"

  _ODS_REGIONS = (1, True)

  def __init__(self, replacement, target, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(target)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(replacement)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def replacement(self):
    return self.operation.results[0]

  @builtins.property
  def bodyRegion(self):
    return self.regions[0]

def structured_replace(replacement, target, *, loc=None, ip=None) -> _ods_ir.Value:
  return ReplaceOp(replacement=replacement, target=target, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class RewriteInDestinationPassingStyleOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.structured.rewrite_in_destination_passing_style"

  _ODS_REGIONS = (0, True)

  def __init__(self, transformed, target, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(target)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(transformed)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def transformed(self):
    return self.operation.results[0]

def structured_rewrite_in_destination_passing_style(transformed, target, *, loc=None, ip=None) -> _ods_ir.Value:
  return RewriteInDestinationPassingStyleOp(transformed=transformed, target=target, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ScalarizeOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.structured.scalarize"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, target, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(target)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def structured_scalarize(result, target, *, loc=None, ip=None) -> _ods_ir.Value:
  return ScalarizeOp(result=result, target=target, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SpecializeOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.structured.specialize"

  _ODS_REGIONS = (0, True)

  def __init__(self, transformed, target, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(target)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(transformed)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def transformed(self):
    return self.operation.results[0]

def structured_specialize(transformed, target, *, loc=None, ip=None) -> _ods_ir.Value:
  return SpecializeOp(transformed=transformed, target=target, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SplitOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.structured.split"

  _ODS_REGIONS = (0, True)

  def __init__(self, split_list, target, dimension, static_chunk_sizes, *, dynamic_chunk_sizes=None, multiway=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(target)
    if dynamic_chunk_sizes is not None: operands.append(dynamic_chunk_sizes)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dimension"] = (dimension if (
    isinstance(dimension, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(dimension, context=_ods_context))
    attributes["static_chunk_sizes"] = (static_chunk_sizes if (
    isinstance(static_chunk_sizes, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(static_chunk_sizes, context=_ods_context))
    if bool(multiway): attributes["multiway"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    results.append(split_list)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def dynamic_chunk_sizes(self):
    return None if len(self.operation.operands) < 2 else self.operation.operands[1]

  @builtins.property
  def dimension(self):
    return self.operation.attributes["dimension"]

  @dimension.setter
  def dimension(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dimension"] = value

  @builtins.property
  def static_chunk_sizes(self):
    return self.operation.attributes["static_chunk_sizes"]

  @static_chunk_sizes.setter
  def static_chunk_sizes(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["static_chunk_sizes"] = value

  @builtins.property
  def multiway(self):
    return "multiway" in self.operation.attributes

  @multiway.setter
  def multiway(self, value):
    if bool(value):
      self.operation.attributes["multiway"] = _ods_ir.UnitAttr.get()
    elif "multiway" in self.operation.attributes:
      del self.operation.attributes["multiway"]

  @multiway.deleter
  def multiway(self):
    del self.operation.attributes["multiway"]

  @builtins.property
  def split_list(self):
    return self.operation.results[0]

def structured_split(split_list, target, dimension, static_chunk_sizes, *, dynamic_chunk_sizes=None, multiway=None, loc=None, ip=None) -> _ods_ir.Value:
  return SplitOp(split_list=split_list, target=target, dimension=dimension, static_chunk_sizes=static_chunk_sizes, dynamic_chunk_sizes=dynamic_chunk_sizes, multiway=multiway, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SplitReductionOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.structured.split_reduction"

  _ODS_REGIONS = (0, True)

  def __init__(self, init_or_alloc_op, fill_op, split_linalg_op, combining_linalg_op, target, *, split_factor=None, insert_split_dimension=None, inner_parallel=None, use_scaling_algorithm=None, use_alloc=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(target)
    _ods_context = _ods_get_default_loc_context(loc)
    if split_factor is not None: attributes["split_factor"] = (split_factor if (
        isinstance(split_factor, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(split_factor, context=_ods_context))
    if insert_split_dimension is not None: attributes["insert_split_dimension"] = (insert_split_dimension if (
        isinstance(insert_split_dimension, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(insert_split_dimension, context=_ods_context))
    if bool(inner_parallel): attributes["inner_parallel"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    if bool(use_scaling_algorithm): attributes["use_scaling_algorithm"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    if bool(use_alloc): attributes["use_alloc"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    results.append(init_or_alloc_op)
    results.append(fill_op)
    results.append(split_linalg_op)
    results.append(combining_linalg_op)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def split_factor(self):
    return self.operation.attributes["split_factor"]

  @split_factor.setter
  def split_factor(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["split_factor"] = value

  @builtins.property
  def insert_split_dimension(self):
    return self.operation.attributes["insert_split_dimension"]

  @insert_split_dimension.setter
  def insert_split_dimension(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["insert_split_dimension"] = value

  @builtins.property
  def inner_parallel(self):
    return "inner_parallel" in self.operation.attributes

  @inner_parallel.setter
  def inner_parallel(self, value):
    if bool(value):
      self.operation.attributes["inner_parallel"] = _ods_ir.UnitAttr.get()
    elif "inner_parallel" in self.operation.attributes:
      del self.operation.attributes["inner_parallel"]

  @inner_parallel.deleter
  def inner_parallel(self):
    del self.operation.attributes["inner_parallel"]

  @builtins.property
  def use_scaling_algorithm(self):
    return "use_scaling_algorithm" in self.operation.attributes

  @use_scaling_algorithm.setter
  def use_scaling_algorithm(self, value):
    if bool(value):
      self.operation.attributes["use_scaling_algorithm"] = _ods_ir.UnitAttr.get()
    elif "use_scaling_algorithm" in self.operation.attributes:
      del self.operation.attributes["use_scaling_algorithm"]

  @use_scaling_algorithm.deleter
  def use_scaling_algorithm(self):
    del self.operation.attributes["use_scaling_algorithm"]

  @builtins.property
  def use_alloc(self):
    return "use_alloc" in self.operation.attributes

  @use_alloc.setter
  def use_alloc(self, value):
    if bool(value):
      self.operation.attributes["use_alloc"] = _ods_ir.UnitAttr.get()
    elif "use_alloc" in self.operation.attributes:
      del self.operation.attributes["use_alloc"]

  @use_alloc.deleter
  def use_alloc(self):
    del self.operation.attributes["use_alloc"]

  @builtins.property
  def init_or_alloc_op(self):
    return self.operation.results[0]

  @builtins.property
  def fill_op(self):
    return self.operation.results[1]

  @builtins.property
  def split_linalg_op(self):
    return self.operation.results[2]

  @builtins.property
  def combining_linalg_op(self):
    return self.operation.results[3]

def structured_split_reduction(init_or_alloc_op, fill_op, split_linalg_op, combining_linalg_op, target, *, split_factor=None, insert_split_dimension=None, inner_parallel=None, use_scaling_algorithm=None, use_alloc=None, loc=None, ip=None) -> _Sequence[_ods_ir.Value]:
  return SplitReductionOp(init_or_alloc_op=init_or_alloc_op, fill_op=fill_op, split_linalg_op=split_linalg_op, combining_linalg_op=combining_linalg_op, target=target, split_factor=split_factor, insert_split_dimension=insert_split_dimension, inner_parallel=inner_parallel, use_scaling_algorithm=use_scaling_algorithm, use_alloc=use_alloc, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class TileReductionUsingForOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.structured.tile_reduction_using_for"

  _ODS_REGIONS = (0, True)

  def __init__(self, fill_op, split_op, combining_op, for_op, target, *, tile_sizes=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(target)
    _ods_context = _ods_get_default_loc_context(loc)
    if tile_sizes is not None: attributes["tile_sizes"] = (tile_sizes if (
        isinstance(tile_sizes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DenseI64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('DenseI64ArrayAttr')(tile_sizes, context=_ods_context))
    results.extend(fill_op)
    results.append(split_op)
    results.append(combining_op)
    results.append(for_op)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def tile_sizes(self):
    return self.operation.attributes["tile_sizes"]

  @tile_sizes.setter
  def tile_sizes(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["tile_sizes"] = value

  @builtins.property
  def fill_op(self):
    _ods_variadic_group_length = len(self.operation.results) - 4 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def split_op(self):
    _ods_variadic_group_length = len(self.operation.results) - 4 + 1
    return self.operation.results[1 + _ods_variadic_group_length - 1]

  @builtins.property
  def combining_op(self):
    _ods_variadic_group_length = len(self.operation.results) - 4 + 1
    return self.operation.results[2 + _ods_variadic_group_length - 1]

  @builtins.property
  def for_op(self):
    _ods_variadic_group_length = len(self.operation.results) - 4 + 1
    return self.operation.results[3 + _ods_variadic_group_length - 1]

def structured_tile_reduction_using_for(fill_op, split_op, combining_op, for_op, target, *, tile_sizes=None, loc=None, ip=None) -> _Sequence[_ods_ir.Value]:
  return _get_op_result_or_op_results(TileReductionUsingForOp(fill_op=fill_op, split_op=split_op, combining_op=combining_op, for_op=for_op, target=target, tile_sizes=tile_sizes, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class TileReductionUsingForallOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.structured.tile_reduction_using_forall"

  _ODS_REGIONS = (0, True)

  def __init__(self, fill_op, split_linalg_op, combining_linalg_op, forall_op, target, *, num_threads=None, tile_sizes=None, mapping=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(target)
    _ods_context = _ods_get_default_loc_context(loc)
    if num_threads is not None: attributes["num_threads"] = (num_threads if (
        isinstance(num_threads, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DenseI64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('DenseI64ArrayAttr')(num_threads, context=_ods_context))
    if tile_sizes is not None: attributes["tile_sizes"] = (tile_sizes if (
        isinstance(tile_sizes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DenseI64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('DenseI64ArrayAttr')(tile_sizes, context=_ods_context))
    if mapping is not None: attributes["mapping"] = (mapping if (
        isinstance(mapping, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DeviceMappingArrayAttr')) else
          _ods_ir.AttrBuilder.get('DeviceMappingArrayAttr')(mapping, context=_ods_context))
    results.extend(fill_op)
    results.append(split_linalg_op)
    results.append(combining_linalg_op)
    results.append(forall_op)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def num_threads(self):
    return self.operation.attributes["num_threads"]

  @num_threads.setter
  def num_threads(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["num_threads"] = value

  @builtins.property
  def tile_sizes(self):
    return self.operation.attributes["tile_sizes"]

  @tile_sizes.setter
  def tile_sizes(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["tile_sizes"] = value

  @builtins.property
  def mapping(self):
    if "mapping" not in self.operation.attributes:
      return None
    return self.operation.attributes["mapping"]

  @mapping.setter
  def mapping(self, value):
    if value is not None:
      self.operation.attributes["mapping"] = value
    elif "mapping" in self.operation.attributes:
      del self.operation.attributes["mapping"]

  @mapping.deleter
  def mapping(self):
    del self.operation.attributes["mapping"]

  @builtins.property
  def fill_op(self):
    _ods_variadic_group_length = len(self.operation.results) - 4 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def split_linalg_op(self):
    _ods_variadic_group_length = len(self.operation.results) - 4 + 1
    return self.operation.results[1 + _ods_variadic_group_length - 1]

  @builtins.property
  def combining_linalg_op(self):
    _ods_variadic_group_length = len(self.operation.results) - 4 + 1
    return self.operation.results[2 + _ods_variadic_group_length - 1]

  @builtins.property
  def forall_op(self):
    _ods_variadic_group_length = len(self.operation.results) - 4 + 1
    return self.operation.results[3 + _ods_variadic_group_length - 1]

def structured_tile_reduction_using_forall(fill_op, split_linalg_op, combining_linalg_op, forall_op, target, *, num_threads=None, tile_sizes=None, mapping=None, loc=None, ip=None) -> _Sequence[_ods_ir.Value]:
  return _get_op_result_or_op_results(TileReductionUsingForallOp(fill_op=fill_op, split_linalg_op=split_linalg_op, combining_linalg_op=combining_linalg_op, forall_op=forall_op, target=target, num_threads=num_threads, tile_sizes=tile_sizes, mapping=mapping, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class TileUsingForOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.structured.tile_using_for"

  _ODS_REGIONS = (0, True)

  def __init__(self, tiled_linalg_op, loops, target, dynamic_sizes, *, static_sizes=None, interchange=None, scalable_sizes=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(target)
    operands.extend(_get_op_results_or_values(dynamic_sizes))
    _ods_context = _ods_get_default_loc_context(loc)
    if static_sizes is not None: attributes["static_sizes"] = (static_sizes if (
        isinstance(static_sizes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DenseI64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('DenseI64ArrayAttr')(static_sizes, context=_ods_context))
    if interchange is not None: attributes["interchange"] = (interchange if (
        isinstance(interchange, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DenseI64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('DenseI64ArrayAttr')(interchange, context=_ods_context))
    if scalable_sizes is not None: attributes["scalable_sizes"] = (scalable_sizes if (
        isinstance(scalable_sizes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DenseBoolArrayAttr')) else
          _ods_ir.AttrBuilder.get('DenseBoolArrayAttr')(scalable_sizes, context=_ods_context))
    results.append(tiled_linalg_op)
    results.extend(loops)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def dynamic_sizes(self):
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[1:1 + _ods_variadic_group_length]

  @builtins.property
  def static_sizes(self):
    if "static_sizes" not in self.operation.attributes:
      return None
    return self.operation.attributes["static_sizes"]

  @static_sizes.setter
  def static_sizes(self, value):
    if value is not None:
      self.operation.attributes["static_sizes"] = value
    elif "static_sizes" in self.operation.attributes:
      del self.operation.attributes["static_sizes"]

  @static_sizes.deleter
  def static_sizes(self):
    del self.operation.attributes["static_sizes"]

  @builtins.property
  def interchange(self):
    if "interchange" not in self.operation.attributes:
      return None
    return self.operation.attributes["interchange"]

  @interchange.setter
  def interchange(self, value):
    if value is not None:
      self.operation.attributes["interchange"] = value
    elif "interchange" in self.operation.attributes:
      del self.operation.attributes["interchange"]

  @interchange.deleter
  def interchange(self):
    del self.operation.attributes["interchange"]

  @builtins.property
  def scalable_sizes(self):
    if "scalable_sizes" not in self.operation.attributes:
      return None
    return self.operation.attributes["scalable_sizes"]

  @scalable_sizes.setter
  def scalable_sizes(self, value):
    if value is not None:
      self.operation.attributes["scalable_sizes"] = value
    elif "scalable_sizes" in self.operation.attributes:
      del self.operation.attributes["scalable_sizes"]

  @scalable_sizes.deleter
  def scalable_sizes(self):
    del self.operation.attributes["scalable_sizes"]

  @builtins.property
  def tiled_linalg_op(self):
    return self.operation.results[0]

  @builtins.property
  def loops(self):
    _ods_variadic_group_length = len(self.operation.results) - 2 + 1
    return self.operation.results[1:1 + _ods_variadic_group_length]

def structured_tile_using_for(tiled_linalg_op, loops, target, dynamic_sizes, *, static_sizes=None, interchange=None, scalable_sizes=None, loc=None, ip=None) -> _Sequence[_ods_ir.Value]:
  return _get_op_result_or_op_results(TileUsingForOp(tiled_linalg_op=tiled_linalg_op, loops=loops, target=target, dynamic_sizes=dynamic_sizes, static_sizes=static_sizes, interchange=interchange, scalable_sizes=scalable_sizes, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class TileUsingForallOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.structured.tile_using_forall"

  _ODS_OPERAND_SEGMENTS = [1,-1,-1,0,0,]

  _ODS_REGIONS = (0, True)

  def __init__(self, tiled_op, forall_op, target, num_threads, tile_sizes, *, packed_num_threads=None, packed_tile_sizes=None, static_num_threads=None, static_tile_sizes=None, mapping=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(target)
    operands.append(_get_op_results_or_values(num_threads))
    operands.append(_get_op_results_or_values(tile_sizes))
    operands.append(packed_num_threads)
    operands.append(packed_tile_sizes)
    _ods_context = _ods_get_default_loc_context(loc)
    if static_num_threads is not None: attributes["static_num_threads"] = (static_num_threads if (
        isinstance(static_num_threads, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DenseI64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('DenseI64ArrayAttr')(static_num_threads, context=_ods_context))
    if static_tile_sizes is not None: attributes["static_tile_sizes"] = (static_tile_sizes if (
        isinstance(static_tile_sizes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DenseI64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('DenseI64ArrayAttr')(static_tile_sizes, context=_ods_context))
    if mapping is not None: attributes["mapping"] = (mapping if (
        isinstance(mapping, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DeviceMappingArrayAttr')) else
          _ods_ir.AttrBuilder.get('DeviceMappingArrayAttr')(mapping, context=_ods_context))
    results.append(tiled_op)
    results.append(forall_op)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def num_threads(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def tile_sizes(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def packed_num_threads(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def packed_tile_sizes(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 4)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def static_num_threads(self):
    if "static_num_threads" not in self.operation.attributes:
      return None
    return self.operation.attributes["static_num_threads"]

  @static_num_threads.setter
  def static_num_threads(self, value):
    if value is not None:
      self.operation.attributes["static_num_threads"] = value
    elif "static_num_threads" in self.operation.attributes:
      del self.operation.attributes["static_num_threads"]

  @static_num_threads.deleter
  def static_num_threads(self):
    del self.operation.attributes["static_num_threads"]

  @builtins.property
  def static_tile_sizes(self):
    if "static_tile_sizes" not in self.operation.attributes:
      return None
    return self.operation.attributes["static_tile_sizes"]

  @static_tile_sizes.setter
  def static_tile_sizes(self, value):
    if value is not None:
      self.operation.attributes["static_tile_sizes"] = value
    elif "static_tile_sizes" in self.operation.attributes:
      del self.operation.attributes["static_tile_sizes"]

  @static_tile_sizes.deleter
  def static_tile_sizes(self):
    del self.operation.attributes["static_tile_sizes"]

  @builtins.property
  def mapping(self):
    if "mapping" not in self.operation.attributes:
      return None
    return self.operation.attributes["mapping"]

  @mapping.setter
  def mapping(self, value):
    if value is not None:
      self.operation.attributes["mapping"] = value
    elif "mapping" in self.operation.attributes:
      del self.operation.attributes["mapping"]

  @mapping.deleter
  def mapping(self):
    del self.operation.attributes["mapping"]

  @builtins.property
  def tiled_op(self):
    return self.operation.results[0]

  @builtins.property
  def forall_op(self):
    return self.operation.results[1]

def structured_tile_using_forall(tiled_op, forall_op, target, num_threads, tile_sizes, *, packed_num_threads=None, packed_tile_sizes=None, static_num_threads=None, static_tile_sizes=None, mapping=None, loc=None, ip=None) -> _Sequence[_ods_ir.Value]:
  return TileUsingForallOp(tiled_op=tiled_op, forall_op=forall_op, target=target, num_threads=num_threads, tile_sizes=tile_sizes, packed_num_threads=packed_num_threads, packed_tile_sizes=packed_tile_sizes, static_num_threads=static_num_threads, static_tile_sizes=static_tile_sizes, mapping=mapping, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class TransposeConv2DOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.structured.transpose_conv2d"

  _ODS_REGIONS = (0, True)

  def __init__(self, transformed, target, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(target)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(transformed)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def transformed(self):
    return self.operation.results[0]

def structured_transpose_conv2d(transformed, target, *, loc=None, ip=None) -> _ods_ir.Value:
  return TransposeConv2DOp(transformed=transformed, target=target, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TransposeMatmulOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.structured.transpose_matmul"

  _ODS_REGIONS = (0, True)

  def __init__(self, transformed, target, *, inputToTranspose=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(target)
    _ods_context = _ods_get_default_loc_context(loc)
    if inputToTranspose is not None: attributes["inputToTranspose"] = (inputToTranspose if (
        isinstance(inputToTranspose, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('TransposeMatmulInput')) else
          _ods_ir.AttrBuilder.get('TransposeMatmulInput')(inputToTranspose, context=_ods_context))
    results.append(transformed)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def inputToTranspose(self):
    return self.operation.attributes["inputToTranspose"]

  @inputToTranspose.setter
  def inputToTranspose(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["inputToTranspose"] = value

  @builtins.property
  def transformed(self):
    return self.operation.results[0]

def structured_transpose_matmul(transformed, target, *, input_to_transpose=None, loc=None, ip=None) -> _ods_ir.Value:
  return TransposeMatmulOp(transformed=transformed, target=target, inputToTranspose=input_to_transpose, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class VectorizeChildrenAndApplyPatternsOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.structured.vectorize_children_and_apply_patterns"

  _ODS_REGIONS = (0, True)

  def __init__(self, transformed, target, *, vectorize_padding=None, vectorize_nd_extract=None, flatten_1d_depthwise_conv=None, disable_multi_reduction_to_contract_patterns=None, disable_transfer_permutation_map_lowering_patterns=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(target)
    _ods_context = _ods_get_default_loc_context(loc)
    if bool(vectorize_padding): attributes["vectorize_padding"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    if bool(vectorize_nd_extract): attributes["vectorize_nd_extract"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    if bool(flatten_1d_depthwise_conv): attributes["flatten_1d_depthwise_conv"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    if bool(disable_multi_reduction_to_contract_patterns): attributes["disable_multi_reduction_to_contract_patterns"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    if bool(disable_transfer_permutation_map_lowering_patterns): attributes["disable_transfer_permutation_map_lowering_patterns"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    results.append(transformed)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def vectorize_padding(self):
    return "vectorize_padding" in self.operation.attributes

  @vectorize_padding.setter
  def vectorize_padding(self, value):
    if bool(value):
      self.operation.attributes["vectorize_padding"] = _ods_ir.UnitAttr.get()
    elif "vectorize_padding" in self.operation.attributes:
      del self.operation.attributes["vectorize_padding"]

  @vectorize_padding.deleter
  def vectorize_padding(self):
    del self.operation.attributes["vectorize_padding"]

  @builtins.property
  def vectorize_nd_extract(self):
    return "vectorize_nd_extract" in self.operation.attributes

  @vectorize_nd_extract.setter
  def vectorize_nd_extract(self, value):
    if bool(value):
      self.operation.attributes["vectorize_nd_extract"] = _ods_ir.UnitAttr.get()
    elif "vectorize_nd_extract" in self.operation.attributes:
      del self.operation.attributes["vectorize_nd_extract"]

  @vectorize_nd_extract.deleter
  def vectorize_nd_extract(self):
    del self.operation.attributes["vectorize_nd_extract"]

  @builtins.property
  def flatten_1d_depthwise_conv(self):
    return "flatten_1d_depthwise_conv" in self.operation.attributes

  @flatten_1d_depthwise_conv.setter
  def flatten_1d_depthwise_conv(self, value):
    if bool(value):
      self.operation.attributes["flatten_1d_depthwise_conv"] = _ods_ir.UnitAttr.get()
    elif "flatten_1d_depthwise_conv" in self.operation.attributes:
      del self.operation.attributes["flatten_1d_depthwise_conv"]

  @flatten_1d_depthwise_conv.deleter
  def flatten_1d_depthwise_conv(self):
    del self.operation.attributes["flatten_1d_depthwise_conv"]

  @builtins.property
  def disable_multi_reduction_to_contract_patterns(self):
    return "disable_multi_reduction_to_contract_patterns" in self.operation.attributes

  @disable_multi_reduction_to_contract_patterns.setter
  def disable_multi_reduction_to_contract_patterns(self, value):
    if bool(value):
      self.operation.attributes["disable_multi_reduction_to_contract_patterns"] = _ods_ir.UnitAttr.get()
    elif "disable_multi_reduction_to_contract_patterns" in self.operation.attributes:
      del self.operation.attributes["disable_multi_reduction_to_contract_patterns"]

  @disable_multi_reduction_to_contract_patterns.deleter
  def disable_multi_reduction_to_contract_patterns(self):
    del self.operation.attributes["disable_multi_reduction_to_contract_patterns"]

  @builtins.property
  def disable_transfer_permutation_map_lowering_patterns(self):
    return "disable_transfer_permutation_map_lowering_patterns" in self.operation.attributes

  @disable_transfer_permutation_map_lowering_patterns.setter
  def disable_transfer_permutation_map_lowering_patterns(self, value):
    if bool(value):
      self.operation.attributes["disable_transfer_permutation_map_lowering_patterns"] = _ods_ir.UnitAttr.get()
    elif "disable_transfer_permutation_map_lowering_patterns" in self.operation.attributes:
      del self.operation.attributes["disable_transfer_permutation_map_lowering_patterns"]

  @disable_transfer_permutation_map_lowering_patterns.deleter
  def disable_transfer_permutation_map_lowering_patterns(self):
    del self.operation.attributes["disable_transfer_permutation_map_lowering_patterns"]

  @builtins.property
  def transformed(self):
    return self.operation.results[0]

def structured_vectorize_children_and_apply_patterns(transformed, target, *, vectorize_padding=None, vectorize_nd_extract=None, flatten_1d_depthwise_conv=None, disable_multi_reduction_to_contract_patterns=None, disable_transfer_permutation_map_lowering_patterns=None, loc=None, ip=None) -> _ods_ir.Value:
  return VectorizeChildrenAndApplyPatternsOp(transformed=transformed, target=target, vectorize_padding=vectorize_padding, vectorize_nd_extract=vectorize_nd_extract, flatten_1d_depthwise_conv=flatten_1d_depthwise_conv, disable_multi_reduction_to_contract_patterns=disable_multi_reduction_to_contract_patterns, disable_transfer_permutation_map_lowering_patterns=disable_transfer_permutation_map_lowering_patterns, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class VectorizeOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.structured.vectorize"

  _ODS_REGIONS = (0, True)

  def __init__(self, target, vector_sizes, *, static_vector_sizes=None, vectorize_nd_extract=None, scalable_sizes=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(target)
    operands.extend(_get_op_results_or_values(vector_sizes))
    _ods_context = _ods_get_default_loc_context(loc)
    if static_vector_sizes is not None: attributes["static_vector_sizes"] = (static_vector_sizes if (
        isinstance(static_vector_sizes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DenseI64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('DenseI64ArrayAttr')(static_vector_sizes, context=_ods_context))
    if bool(vectorize_nd_extract): attributes["vectorize_nd_extract"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    if scalable_sizes is not None: attributes["scalable_sizes"] = (scalable_sizes if (
        isinstance(scalable_sizes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DenseBoolArrayAttr')) else
          _ods_ir.AttrBuilder.get('DenseBoolArrayAttr')(scalable_sizes, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def vector_sizes(self):
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[1:1 + _ods_variadic_group_length]

  @builtins.property
  def static_vector_sizes(self):
    if "static_vector_sizes" not in self.operation.attributes:
      return None
    return self.operation.attributes["static_vector_sizes"]

  @static_vector_sizes.setter
  def static_vector_sizes(self, value):
    if value is not None:
      self.operation.attributes["static_vector_sizes"] = value
    elif "static_vector_sizes" in self.operation.attributes:
      del self.operation.attributes["static_vector_sizes"]

  @static_vector_sizes.deleter
  def static_vector_sizes(self):
    del self.operation.attributes["static_vector_sizes"]

  @builtins.property
  def vectorize_nd_extract(self):
    return "vectorize_nd_extract" in self.operation.attributes

  @vectorize_nd_extract.setter
  def vectorize_nd_extract(self, value):
    if bool(value):
      self.operation.attributes["vectorize_nd_extract"] = _ods_ir.UnitAttr.get()
    elif "vectorize_nd_extract" in self.operation.attributes:
      del self.operation.attributes["vectorize_nd_extract"]

  @vectorize_nd_extract.deleter
  def vectorize_nd_extract(self):
    del self.operation.attributes["vectorize_nd_extract"]

  @builtins.property
  def scalable_sizes(self):
    if "scalable_sizes" not in self.operation.attributes:
      return None
    return self.operation.attributes["scalable_sizes"]

  @scalable_sizes.setter
  def scalable_sizes(self, value):
    if value is not None:
      self.operation.attributes["scalable_sizes"] = value
    elif "scalable_sizes" in self.operation.attributes:
      del self.operation.attributes["scalable_sizes"]

  @scalable_sizes.deleter
  def scalable_sizes(self):
    del self.operation.attributes["scalable_sizes"]

def structured_vectorize(target, vector_sizes, *, static_vector_sizes=None, vectorize_nd_extract=None, scalable_sizes=None, loc=None, ip=None) -> _ods_ir.Operation:
  return VectorizeOp(target=target, vector_sizes=vector_sizes, static_vector_sizes=static_vector_sizes, vectorize_nd_extract=vectorize_nd_extract, scalable_sizes=scalable_sizes, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class WinogradConv2DOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.structured.winograd_conv2d"

  _ODS_REGIONS = (0, True)

  def __init__(self, transformed, target, m, r, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(target)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["m"] = (m if (
    isinstance(m, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(m, context=_ods_context))
    attributes["r"] = (r if (
    isinstance(r, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(r, context=_ods_context))
    results.append(transformed)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def m(self):
    return self.operation.attributes["m"]

  @m.setter
  def m(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["m"] = value

  @builtins.property
  def r(self):
    return self.operation.attributes["r"]

  @r.setter
  def r(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["r"] = value

  @builtins.property
  def transformed(self):
    return self.operation.results[0]

def structured_winograd_conv2d(transformed, target, m, r, *, loc=None, ip=None) -> _ods_ir.Value:
  return WinogradConv2DOp(transformed=transformed, target=target, m=m, r=r, loc=loc, ip=ip).result
